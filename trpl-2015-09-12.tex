% \documentclass[12pt]{article}
\documentclass[a4paper,]{book}

  \usepackage{lmodern}


\usepackage[a4paper]{geometry}

\usepackage{graphicx}

\usepackage{longtable}
\usepackage{booktabs}
\usepackage[htt]{hyphenat}

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}

\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi

% Break URLs in a few more places. (For breaking lines, not functionality!)
% cf. http://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url
\expandafter\def\expandafter\UrlBreaks\expandafter{\UrlBreaks%  save the current one
  \do\*\do\-\do\~\do\'\do\"\do\-}

\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={The Rust Team},
            pdftitle={The Rust Programming Language},
            colorlinks=false,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls

\renewcommand*{\hyperref}[2][\ar]{%
  \def\ar{#2}%
  #2 (\autoref{#1}, page~\pageref{#1})}

\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
    \usepackage{xeCJK}
    \setCJKmainfont{IPAexMincho}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{‚Ç¨}

  
  
      \setmonofont[Mapping=tex-ansi]{DejaVu Sans Mono}
  
  \fi

\setlength{\emergencystretch}{3em}  % prevent overfull lines

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}


\usepackage{xcolor}

  \usepackage{color}
  \usepackage{fancyvrb}
  \newcommand{\VerbBar}{|}
  \newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
  % Add ',fontsize=\small' for more characters per line
  \usepackage{framed}
  \definecolor{shadecolor}{RGB}{248,248,248}
  \newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
  \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
  \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
  \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
  \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
  \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
  \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
  \newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
  \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
  \newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
  \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
  \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
  \newcommand{\ImportTok}[1]{{#1}}
  \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
  \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
  \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
  \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
  \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
  \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
  \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
  \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
  \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{{#1}}}}
  \newcommand{\BuiltInTok}[1]{{#1}}
  \newcommand{\ExtensionTok}[1]{{#1}}
  \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
  \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{{#1}}}
  \newcommand{\RegionMarkerTok}[1]{{#1}}
  \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
  \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
  \newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
  \newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{{#1}}}}
  \newcommand{\NormalTok}[1]{{#1}}

  \usepackage{fancyvrb}

  % Make links footnotes instead of hotlinks:
  \renewcommand{\href}[2]{#2\footnote{\url{#1}}}

  \VerbatimFootnotes % allows verbatim text in footnotes

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\usepackage[font={footnotesize,sf}]{caption}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% - - -
% Make it fancy

% Headers and page numbering
\usepackage{fancyhdr}

% Set figure legends and captions to be smaller sized sans serif font
\usepackage[font={footnotesize,sf}]{caption}

% Chapter styling
\usepackage[grey]{quotchap}
\makeatletter
\renewcommand*{\chapnumfont}{%
  \thispagestyle{empty}
  \usefont{T1}{\@defaultcnfont}{b}{n}\fontsize{80}{100}\selectfont% Default: 100/130
  \color{chaptergrey}%
}
\makeatother

% - - -

  \title{The Rust Programming Language}
  \author{The Rust Team}
  \date{2015-09-12}

\begin{document}

  \maketitle



{
  \hypersetup{linkcolor=black}
  \setcounter{tocdepth}{2}
  \tableofcontents
  \newpage
}

\chapter{Introduction}\label{introduction}

Welcome! This book will teach you about the
\href{https://www.rust-lang.org}{Rust Programming Language}. Rust is a
systems programming language focused on three goals: safety, speed, and
concurrency. It maintains these goals without having a garbage
collector, making it a useful language for a number of use cases other
languages aren't good at: embedding in other languages, programs with
specific space and time requirements, and writing low-level code, like
device drivers and operating systems. It improves on current languages
targeting this space by having a number of compile-time safety checks
that produce no runtime overhead, while eliminating all data races. Rust
also aims to achieve `zero-cost abstractions' even though some of these
abstractions feel like those of a high-level language. Even then, Rust
still allows precise control like a low-level language would.

``The Rust Programming Language'' is split into eight sections. This
introduction is the first. After this:

\begin{itemize}
\tightlist
\item
  \hyperref[sec--getting-started]{Getting started} - Set up your
  computer for Rust development.
\item
  \hyperref[sec--learn-rust]{Learn Rust} - Learn Rust programming
  through small projects.
\item
  \hyperref[sec--effective-rust]{Effective Rust} - Higher-level concepts
  for writing excellent Rust code.
\item
  \hyperref[sec--syntax-and-semantics]{Syntax and Semantics} - Each bit
  of Rust, broken down into small chunks.
\item
  \hyperref[sec--nightly-rust]{Nightly Rust} - Cutting-edge features
  that aren't in stable builds yet.
\item
  \hyperref[sec--glossary]{Glossary} - A reference of terms used in the
  book.
\item
  \hyperref[sec--bibliography]{Bibliography} - Background on Rust's
  influences, papers about Rust.
\end{itemize}

After reading this introduction, you'll want to dive into either `Learn
Rust' or `Syntax and Semantics', depending on your preference: `Learn
Rust' if you want to dive in with a project, or `Syntax and Semantics'
if you prefer to start small, and learn a single concept thoroughly
before moving onto the next. Copious cross-linking connects these parts
together.

\subsection{Contributing}\label{contributing}

The source files from which this book is generated can be found on
Github:
\href{https://github.com/rust-lang/rust/tree/master/src/doc/trpl}{github.com/rust-lang/rust/tree/master/src/doc/trpl}

\section{A brief introduction to
Rust}\label{a-brief-introduction-to-rust}

Is Rust a language you might be interested in? Let's examine a few small
code samples to show off a few of its strengths.

The main concept that makes Rust unique is called `ownership'. Consider
this small example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This program makes a \hyperref[sec--variable-bindings]{variable binding}
named \texttt{x}. The value of this binding is a
\texttt{Vec\textless{}T\textgreater{}}, a `vector', that we create
through a \hyperref[sec--macros]{macro} defined in the standard library.
This macro is called \texttt{vec}, and we invoke macros with a
\texttt{!}. This follows a general principle of Rust: make things
explicit. Macros can do significantly more complicated things than
function calls, and so they're visually distinct. The \texttt{!} also
helps with parsing, making tooling easier to write, which is also
important.

We used \texttt{mut} to make \texttt{x} mutable: bindings are immutable
by default in Rust. We'll be mutating this vector later in the example.

It's also worth noting that we didn't need a type annotation here: while
Rust is statically typed, we didn't need to explicitly annotate the
type. Rust has type inference to balance out the power of static typing
with the verbosity of annotating types.

Rust prefers stack allocation to heap allocation: \texttt{x} is placed
directly on the stack. However, the
\texttt{Vec\textless{}T\textgreater{}} type allocates space for the
elements of the vector on the heap. If you're not familiar with this
distinction, you can ignore it for now, or check out
\hyperref[sec--the-stack-and-the-heap]{`The Stack and the Heap'}. As a
systems programming language, Rust gives you the ability to control how
your memory is allocated, but when we're getting started, it's less of a
big deal.

Earlier, we mentioned that `ownership' is the key new concept in Rust.
In Rust parlance, \texttt{x} is said to `own' the vector. This means
that when \texttt{x} goes out of scope, the vector's memory will be
de-allocated. This is done deterministically by the Rust compiler,
rather than through a mechanism such as a garbage collector. In other
words, in Rust, you don't call functions like \texttt{malloc} and
\texttt{free} yourself: the compiler statically determines when you need
to allocate or deallocate memory, and inserts those calls itself. To err
is to be human, but compilers never forget.

Let's add another line to our example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{];}

    \KeywordTok{let} \NormalTok{y = &x[}\DecValTok{0}\NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We've introduced another binding, \texttt{y}. In this case, \texttt{y}
is a `reference' to the first element of the vector. Rust's references
are similar to pointers in other languages, but with additional
compile-time safety checks. References interact with the ownership
system by \hyperref[sec--references-and-borrowing]{`borrowing'} what
they point to, rather than owning it. The difference is, when the
reference goes out of scope, it will not deallocate the underlying
memory. If it did, we'd de-allocate twice, which is bad!

Let's add a third line. It looks innocent enough, but causes a compiler
error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{];}

    \KeywordTok{let} \NormalTok{y = &x[}\DecValTok{0}\NormalTok{];}

    \NormalTok{x.push(}\StringTok{"foo"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{push} is a method on vectors that appends another element to the
end of the vector. When we try to compile this program, we get an error:

\begin{verbatim}
error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push("foo");
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
\end{verbatim}

Whew! The Rust compiler gives quite detailed errors at times, and this
is one of those times. As the error explains, while we made our binding
mutable, we still cannot call \texttt{push}. This is because we already
have a reference to an element of the vector, \texttt{y}. Mutating
something while another reference exists is dangerous, because we may
invalidate the reference. In this specific case, when we create the
vector, we may have only allocated space for two elements. Adding a
third would mean allocating a new chunk of memory for all those
elements, copying the old values over, and updating the internal pointer
to that memory. That all works just fine. The problem is that \texttt{y}
wouldn't get updated, and so we'd have a `dangling pointer'. That's bad.
Any use of \texttt{y} would be an error in this case, and so the
compiler has caught this for us.

So how do we solve this problem? There are two approaches we can take.
The first is making a copy rather than using a reference:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{];}

    \KeywordTok{let} \NormalTok{y = x[}\DecValTok{0}\NormalTok{].clone();}

    \NormalTok{x.push(}\StringTok{"foo"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Rust has \hyperref[move-semantics]{move semantics} by default, so if we
want to make a copy of some data, we call the \texttt{clone()} method.
In this example, \texttt{y} is no longer a reference to the vector
stored in \texttt{x}, but a copy of its first element, \texttt{"Hello"}.
Now that we don't have a reference, our \texttt{push()} works just fine.

If we truly want a reference, we need the other option: ensure that our
reference goes out of scope before we try to do the mutation. That looks
like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{];}

    \NormalTok{\{}
        \KeywordTok{let} \NormalTok{y = &x[}\DecValTok{0}\NormalTok{];}
    \NormalTok{\}}

    \NormalTok{x.push(}\StringTok{"foo"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We created an inner scope with an additional set of curly braces.
\texttt{y} will go out of scope before we call \texttt{push()}, and so
we're all good.

This concept of ownership isn't just good for preventing dangling
pointers, but an entire set of related problems, like iterator
invalidation, concurrency, and more.

\hyperdef{}{sec--getting-started}{\chapter{Getting
Started}\label{sec--getting-started}}

This first section of the book will get you going with Rust and its
tooling. First, we'll install Rust. Then, the classic `Hello World'
program. Finally, we'll talk about Cargo, Rust's build system and
package manager.

\section{Installing Rust}\label{sec--installing-rust}

The first step to using Rust is to install it! There are a number of
ways to install Rust, but the easiest is to use the \texttt{rustup}
script. If you're on Linux or a Mac, all you need to do is this:

\begin{quote}
Note: you don't need to type in the \texttt{\$}s, they just indicate the
start of each command. You'll see many tutorials and examples around the
web that follow this convention: \texttt{\$} for commands run as your
regular user, and \texttt{\#} for commands you should be running as an
administrator.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{curl} \NormalTok{-sf -L https://static.rust-lang.org/rustup.sh }\KeywordTok{|} \KeywordTok{sh}
\end{Highlighting}
\end{Shaded}

If you're concerned about the
\href{http://curlpipesh.tumblr.com}{potential insecurity} of using
\texttt{curl\ \textbar{}\ sh}, please keep reading and see our
disclaimer below. And feel free to use a two-step version of the
installation and examine our installation script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{curl} \NormalTok{-f -L https://static.rust-lang.org/rustup.sh -O}
\NormalTok{$ }\KeywordTok{sh} \NormalTok{rustup.sh}
\end{Highlighting}
\end{Shaded}

If you're on Windows, please download the appropriate
\href{https://www.rust-lang.org/install.html}{installer}. \textbf{NOTE:}
By default, the Windows installer will not add Rust to the \%PATH\%
system variable. If this is the only version of Rust you are installing
and you want to be able to run it from the command line, click on
``Advanced'' on the install dialog and on the ``Product Features'' page
ensure ``Add to PATH'' is installed on the local hard drive.

\subsubsection{Uninstalling}\label{uninstalling}

If you decide you don't want Rust anymore, we'll be a bit sad, but
that's okay. Not every programming language is great for everyone. Just
run the uninstall script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{sudo} \NormalTok{/usr/local/lib/rustlib/uninstall.sh}
\end{Highlighting}
\end{Shaded}

If you used the Windows installer, just re-run the \texttt{.msi} and it
will give you an uninstall option.

\subsubsection{That disclaimer we
promised}\label{that-disclaimer-we-promised}

Some people, and somewhat rightfully so, get very upset when we tell you
to \texttt{curl\ \textbar{}\ sh}. Basically, when you do this, you are
trusting that the good people who maintain Rust aren't going to hack
your computer and do bad things. That's a good instinct! If you're one
of those people, please check out the documentation on
\href{https://github.com/rust-lang/rust\#building-from-source}{building
Rust from Source}, or \href{https://www.rust-lang.org/install.html}{the
official binary downloads}.

\subsubsection{Platform support}\label{platform-support}

Oh, we should also mention the officially supported platforms:

\begin{itemize}
\tightlist
\item
  Windows (7, 8, Server 2008 R2)
\item
  Linux (2.6.18 or later, various distributions), x86 and x86-64
\item
  OSX 10.7 (Lion) or greater, x86 and x86-64
\end{itemize}

We extensively test Rust on these platforms, and a few others, too, like
Android. But these are the ones most likely to work, as they have the
most testing.

Finally, a comment about Windows. Rust considers Windows to be a
first-class platform upon release, but if we're honest, the Windows
experience isn't as integrated as the Linux/OS X experience is. We're
working on it! If anything does not work, it is a bug. Please let us
know if that happens. Each and every commit is tested against Windows
just like any other platform.

\subsubsection{After installation}\label{after-installation}

If you've got Rust installed, you can open up a shell, and type this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{rustc} \NormalTok{--version}
\end{Highlighting}
\end{Shaded}

You should see the version number, commit hash, and commit date. If you
just installed version 1.2.0, you should see:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rustc} \NormalTok{1.2.0 (082e47636 2015-08-03)}
\end{Highlighting}
\end{Shaded}

If you did, Rust has been installed successfully! Congrats!

If you didn't and you're on Windows, check that Rust is in your \%PATH\%
system variable. If it isn't, run the installer again, select ``Change''
on the ``Change, repair, or remove installation'' page and ensure ``Add
to PATH'' is installed on the local hard drive.

This installer also installs a copy of the documentation locally, so you
can read it offline. On UNIX systems, \texttt{/usr/local/share/doc/rust}
is the location. On Windows, it's in a \texttt{share/doc} directory,
inside wherever you installed Rust to.

If not, there are a number of places where you can get help. The easiest
is \href{irc://irc.mozilla.org/\#rust}{the \#rust IRC channel on
irc.mozilla.org}, which you can access through
\href{http://chat.mibbit.com/?server=irc.mozilla.org\&channel=\%23rust}{Mibbit}.
Click that link, and you'll be chatting with other Rustaceans (a silly
nickname we call ourselves), and we can help you out. Other great
resources include \href{https://users.rust-lang.org/}{the user's forum},
and \href{http://stackoverflow.com/questions/tagged/rust}{Stack
Overflow}.

\section{Hello, world!}\label{sec--hello-world}

Now that you have Rust installed, let's write your first Rust program.
It's traditional to make your first program in any new language one that
prints the text ``Hello, world!'' to the screen. The nice thing about
starting with such a simple program is that you can verify that your
compiler isn't just installed, but also working properly. And printing
information to the screen is a pretty common thing to do.

The first thing that we need to do is make a file to put our code in. I
like to make a \texttt{projects} directory in my home directory, and
keep all my projects there. Rust does not care where your code lives.

This actually leads to one other concern we should address: this guide
will assume that you have basic familiarity with the command line. Rust
itself makes no specific demands on your editing tooling, or where your
code lives. If you prefer an IDE to the command line, you may want to
check out \href{https://github.com/oakes/SolidOak}{SolidOak}, or
wherever plugins are for your favorite IDE. There are a number of
extensions of varying quality in development by the community. The Rust
team also ships
\href{https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md}{plugins
for various editors}. Configuring your editor or IDE is out of the scope
of this tutorial, so check the documentation for your setup,
specifically.

With that said, let's make a directory in our projects directory.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{mkdir} \NormalTok{~/projects}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{~/projects}
\NormalTok{$ }\KeywordTok{mkdir} \NormalTok{hello_world}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{hello_world}
\end{Highlighting}
\end{Shaded}

If you're on Windows and not using PowerShell, the
\texttt{\textasciitilde{}} may not work. Consult the documentation for
your shell for more details.

Let's make a new source file next. We'll call our file \texttt{main.rs}.
Rust files always end in a \texttt{.rs} extension. If you're using more
than one word in your filename, use an underscore:
\texttt{hello\_world.rs} rather than \texttt{helloworld.rs}.

Now that you've got your file open, type this in:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello, world!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Save the file, and then type this into your terminal window:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{rustc} \NormalTok{main.rs}
\NormalTok{$ }\KeywordTok{./main} \CommentTok{# or main.exe on Windows}
\KeywordTok{Hello}\NormalTok{, world!}
\end{Highlighting}
\end{Shaded}

Success! Let's go over what just happened in detail.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

These lines define a \emph{function} in Rust. The \texttt{main} function
is special: it's the beginning of every Rust program. The first line
says ``I'm declaring a function named \texttt{main} which takes no
arguments and returns nothing.'' If there were arguments, they would go
inside the parentheses (\texttt{(} and \texttt{)}), and because we
aren't returning anything from this function, we can omit the return
type entirely. We'll get to it later.

You'll also note that the function is wrapped in curly braces
(\texttt{\{} and \texttt{\}}). Rust requires these around all function
bodies. It is also considered good style to put the opening curly brace
on the same line as the function declaration, with one space in between.

Next up is this line:

\begin{Shaded}
\begin{Highlighting}[]
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello, world!"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

This line does all of the work in our little program. There are a number
of details that are important here. The first is that it's indented with
four spaces, not tabs. Please configure your editor of choice to insert
four spaces with the tab key. We provide some
\href{https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md}{sample
configurations for various editors}.

The second point is the \texttt{println!()} part. This is calling a Rust
\hyperref[sec--macros]{macro}, which is how metaprogramming is done in
Rust. If it were a function instead, it would look like this:
\texttt{println()}. For our purposes, we don't need to worry about this
difference. Just know that sometimes, you'll see a \texttt{!}, and that
means that you're calling a macro instead of a normal function. Rust
implements \texttt{println!} as a macro rather than a function for good
reasons, but that's an advanced topic. One last thing to mention: Rust's
macros are significantly different from C macros, if you've used those.
Don't be scared of using macros. We'll get to the details eventually,
you'll just have to trust us for now.

Next, \texttt{"Hello,\ world!"} is a `string'. Strings are a
surprisingly complicated topic in a systems programming language, and
this is a `statically allocated' string. If you want to read further
about allocation, check out \hyperref[sec--the-stack-and-the-heap]{the
stack and the heap}, but you don't need to right now if you don't want
to. We pass this string as an argument to \texttt{println!}, which
prints the string to the screen. Easy enough!

Finally, the line ends with a semicolon (\texttt{;}). Rust is an
\hyperref[expression-oriented-language]{`expression oriented' language},
which means that most things are expressions, rather than statements.
The \texttt{;} is used to indicate that this expression is over, and the
next one is ready to begin. Most lines of Rust code end with a
\texttt{;}.

Finally, actually compiling and running our program. We can compile with
our compiler, \texttt{rustc}, by passing it the name of our source file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{rustc} \NormalTok{main.rs}
\end{Highlighting}
\end{Shaded}

This is similar to \texttt{gcc} or \texttt{clang}, if you come from a C
or C++ background. Rust will output a binary executable. You can see it
with \texttt{ls}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{ls}
\KeywordTok{main}  \NormalTok{main.rs}
\end{Highlighting}
\end{Shaded}

Or on Windows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{dir}
\KeywordTok{main.exe}  \NormalTok{main.rs}
\end{Highlighting}
\end{Shaded}

There are now two files: our source code, with the \texttt{.rs}
extension, and the executable (\texttt{main.exe} on Windows,
\texttt{main} everywhere else)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{./main}  \CommentTok{# or main.exe on Windows}
\end{Highlighting}
\end{Shaded}

This prints out our \texttt{Hello,\ world!} text to our terminal.

If you come from a dynamic language like Ruby, Python, or JavaScript,
you may not be used to these two steps being separate. Rust is an
`ahead-of-time compiled language', which means that you can compile a
program, give it to someone else, and they don't need to have Rust
installed. If you give someone a \texttt{.rb} or \texttt{.py} or
\texttt{.js} file, they need to have a Ruby/Python/JavaScript
implementation installed, but you just need one command to both compile
and run your program. Everything is a tradeoff in language design, and
Rust has made its choice.

Congratulations! You have officially written a Rust program. That makes
you a Rust programmer! Welcome. üéäüéâüëç

Next, I'd like to introduce you to another tool, Cargo, which is used to
write real-world Rust programs. Just using \texttt{rustc} is nice for
simple things, but as your project grows, you'll want something to help
you manage all of the options that it has, and to make it easy to share
your code with other people and projects.

\section{Hello, Cargo!}\label{sec--hello-cargo}

\href{http://doc.crates.io}{Cargo} is a tool that Rustaceans use to help
manage their Rust projects. Cargo is currently in a pre-1.0 state, and
so it is still a work in progress. However, it is already good enough to
use for many Rust projects, and so it is assumed that Rust projects will
use Cargo from the beginning.

Cargo manages three things: building your code, downloading the
dependencies your code needs, and building those dependencies. At first,
your program doesn't have any dependencies, so we'll only be using the
first part of its functionality. Eventually, we'll add more. Since we
started off by using Cargo, it'll be easy to add later.

If we installed Rust via the official installers we will also have
Cargo. If we installed Rust some other way, we may want to
\href{https://github.com/rust-lang/cargo\#installing-cargo-from-nightlies}{check
the Cargo README} for specific instructions about installing it.

\subsubsection{Converting to Cargo}\label{converting-to-cargo}

Let's convert Hello World to Cargo.

To Cargo-ify our project, we need to do three things: Make a
\texttt{Cargo.toml} configuration file, put our source file in the right
place, and get rid of the old executable (\texttt{main.exe} on Windows,
\texttt{main} everywhere else). Let's do that part first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{mkdir} \NormalTok{src}
\NormalTok{$ }\KeywordTok{mv} \NormalTok{main.rs src/main.rs}
\NormalTok{$ }\KeywordTok{rm} \NormalTok{main  }\CommentTok{# or main.exe on Windows}
\end{Highlighting}
\end{Shaded}

Note that since we're creating an executable, we retain \texttt{main.rs}
as the source filename. If we want to make a library instead, we should
use \texttt{lib.rs}. This convention is used by Cargo to successfully
compile our projects, but it can be overridden if we wish. Custom file
locations for the entry point can be specified with a
\href{http://doc.crates.io/manifest.html\#configuring-a-target}{\texttt{{[}lib{]}}
or \texttt{{[}{[}bin{]}{]}}} key in the TOML file.

Cargo expects your source files to live inside a \texttt{src} directory.
That leaves the top level for other things, like READMEs, license
information, and anything not related to your code. Cargo helps us keep
our projects nice and tidy. A place for everything, and everything in
its place.

Next, our configuration file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{editor} \NormalTok{Cargo.toml}
\end{Highlighting}
\end{Shaded}

Make sure to get this name right: you need the capital \texttt{C}!

Put this inside:

\begin{verbatim}
[package]

name = "hello_world"
version = "0.0.1"
authors = [ "Your name <you@example.com>" ]
\end{verbatim}

This file is in the \href{https://github.com/toml-lang/toml}{TOML}
format. TOML is similar to INI, but has some extra goodies. According to
the TOML docs,

\begin{quote}
TOML aims to be a minimal configuration file format that's easy to read
due to obvious semantics. TOML is designed to map unambiguously to a
hash table. TOML should be easy to parse into data structures in a wide
variety of languages.
\end{quote}

Once we have this file in place in our project's root directory, we
should be ready to build! To do so, run:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{hello_world v0.0.1 (file:///home/yourname/projects/hello_world)}
\NormalTok{$ }\KeywordTok{./target/debug/hello_world}
\KeywordTok{Hello}\NormalTok{, world!}
\end{Highlighting}
\end{Shaded}

Bam! We built our project with \texttt{cargo\ build}, and ran it with
\texttt{./target/debug/hello\_world}. We can do both in one step with
\texttt{cargo\ run}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
     \KeywordTok{Running} \KeywordTok{`target/debug/hello_world`}
\KeywordTok{Hello}\NormalTok{, world!}
\end{Highlighting}
\end{Shaded}

Notice that we didn't re-build the project this time. Cargo figured out
that we hadn't changed the source file, and so it just ran the binary.
If we had made a modification, we would have seen it do both:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{hello_world v0.0.1 (file:///home/yourname/projects/hello_world)}
     \KeywordTok{Running} \KeywordTok{`target/debug/hello_world`}
\KeywordTok{Hello}\NormalTok{, world!}
\end{Highlighting}
\end{Shaded}

This hasn't bought us a whole lot over our simple use of \texttt{rustc},
but think about the future: when our project gets more complex, we need
to do more things to get all of the parts to properly compile. With
Cargo, as our project grows, we can just run \texttt{cargo\ build}, and
it'll work the right way.

When your project is finally ready for release, you can use
\texttt{cargo\ build\ -\/-release} to compile your project with
optimizations.

You'll also notice that Cargo has created a new file:
\texttt{Cargo.lock}.

\begin{verbatim}
[root]
name = "hello_world"
version = "0.0.1"
\end{verbatim}

The \texttt{Cargo.lock} file is used by Cargo to keep track of
dependencies in your application. Right now, we don't have any, so it's
a bit sparse. You won't ever need to touch this file yourself, just let
Cargo handle it.

That's it! We've successfully built \texttt{hello\_world} with Cargo.
Even though our program is simple, it's using much of the real tooling
that you'll use for the rest of your Rust career. You can expect to do
this to get started with virtually all Rust projects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{git} \NormalTok{clone someurl.com/foo}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{foo}
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
\end{Highlighting}
\end{Shaded}

\subsubsection{A New Project}\label{a-new-project}

You don't have to go through this whole process every time you want to
start a new project! Cargo has the ability to make a bare-bones project
directory in which you can start developing right away.

To start a new project with Cargo, use \texttt{cargo\ new}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{new hello_world --bin}
\end{Highlighting}
\end{Shaded}

We're passing \texttt{-\/-bin} because our goal is to get straight to
making an executable application, as opposed to a library. Executables
are often called `binaries.' (as in \texttt{/usr/bin}, if you're on a
Unix system)

Let's check out what Cargo has generated for us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cd} \NormalTok{hello_world}
\NormalTok{$ }\KeywordTok{tree} \NormalTok{.}
\KeywordTok{.}
\NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{Cargo.toml}
\NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{src}
    \NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{main.rs}

\KeywordTok{1} \NormalTok{directory, 2 files}
\end{Highlighting}
\end{Shaded}

If you don't have the \texttt{tree} command, you can probably get it
from your distribution's package manager. It's not necessary, but it's
certainly useful.

This is all we need to get started. First, let's check out
\texttt{Cargo.toml}:

\begin{verbatim}
[package]

name = "hello_world"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
\end{verbatim}

Cargo has populated this file with reasonable defaults based off the
arguments you gave it and your \texttt{git} global configuration. You
may notice that Cargo has also initialized the \texttt{hello\_world}
directory as a \texttt{git} repository.

Here's what's in \texttt{src/main.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello, world!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Cargo has generated a ``Hello World!'' for us, and you're ready to start
coding! Cargo has its own \href{http://doc.crates.io/guide.html}{guide}
which covers Cargo's features in much more depth.

Now that you've got the tools down, let's actually learn more about the
Rust language itself. These are the basics that will serve you well
through the rest of your time with Rust.

You have two options: Dive into a project with
`\hyperref[sec--learn-rust]{Learn Rust}', or start from the bottom and
work your way up with `\hyperref[sec--syntax-and-semantics]{Syntax and
Semantics}'. More experienced systems programmers will probably prefer
`Learn Rust', while those from dynamic backgrounds may enjoy either.
Different people learn differently! Choose whatever's right for you.

\hyperdef{}{sec--learn-rust}{\chapter{Learn
Rust}\label{sec--learn-rust}}

Welcome! This section has a few tutorials that teach you Rust through
building projects. You'll get a high-level overview, but we'll skim over
the details.

If you'd prefer a more `from the ground up'-style experience, check out
\hyperref[sec--syntax-and-semantics]{Syntax and Semantics}.

\section{Guessing Game}\label{sec--guessing-game}

For our first project, we'll implement a classic beginner programming
problem: the guessing game. Here's how it works: Our program will
generate a random integer between one and a hundred. It will then prompt
us to enter a guess. Upon entering our guess, it will tell us if we're
too low or too high. Once we guess correctly, it will congratulate us.
Sounds good?

\subsection{Set up}\label{set-up}

Let's set up a new project. Go to your projects directory. Remember how
we had to create our directory structure and a \texttt{Cargo.toml} for
\texttt{hello\_world}? Cargo has a command that does that for us. Let's
give it a shot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cd} \NormalTok{~/projects}
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{new guessing_game --bin}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{guessing_game}
\end{Highlighting}
\end{Shaded}

We pass the name of our project to \texttt{cargo\ new}, and then the
\texttt{-\/-bin} flag, since we're making a binary, rather than a
library.

Check out the generated \texttt{Cargo.toml}:

\begin{verbatim}
[package]

name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
\end{verbatim}

Cargo gets this information from your environment. If it's not correct,
go ahead and fix that.

Finally, Cargo generated a `Hello, world!' for us. Check out
\texttt{src/main.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello, world!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's try compiling what Cargo gave us:

\begin{verbatim}
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
\end{verbatim}

Excellent! Open up your \texttt{src/main.rs} again. We'll be writing all
of our code in this file.

Before we move on, let me show you one more Cargo command: \texttt{run}.
\texttt{cargo\ run} is kind of like \texttt{cargo\ build}, but it also
then runs the produced executable. Try it out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/debug/guessing_game`}
\KeywordTok{Hello}\NormalTok{, world!}
\end{Highlighting}
\end{Shaded}

Great! The \texttt{run} command comes in handy when you need to rapidly
iterate on a project. Our game is just such a project, we need to
quickly test each iteration before moving on to the next one.

\subsection{Processing a Guess}\label{processing-a-guess}

Let's get to it! The first thing we need to do for our guessing game is
allow our player to input a guess. Put this in your
\texttt{src/main.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"Failed to read line"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's a lot here! Let's go over it, bit by bit.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}
\end{Highlighting}
\end{Shaded}

We'll need to take user input, and then print the result as output. As
such, we need the \texttt{io} library from the standard library. Rust
only imports a few things by default into every program,
\href{http://doc.rust-lang.org/std/prelude/index.html}{the `prelude'}.
If it's not in the prelude, you'll have to \texttt{use} it directly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
\end{Highlighting}
\end{Shaded}

As you've seen before, the \texttt{main()} function is the entry point
into your program. The \texttt{fn} syntax declares a new function, the
\texttt{()}s indicate that there are no arguments, and \texttt{\{}
starts the body of the function. Because we didn't include a return
type, it's assumed to be \texttt{()}, an empty \hyperref[tuples]{tuple}.

\begin{Shaded}
\begin{Highlighting}[]
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

We previously learned that \texttt{println!()} is a
\hyperref[sec--macros]{macro} that prints a
\hyperref[sec--strings]{string} to the screen.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}
\end{Highlighting}
\end{Shaded}

Now we're getting interesting! There's a lot going on in this little
line. The first thing to notice is that this is a
\hyperref[sec--variable-bindings]{let statement}, which is used to
create `variable bindings'. They take this form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{foo = bar;}
\end{Highlighting}
\end{Shaded}

This will create a new binding named \texttt{foo}, and bind it to the
value \texttt{bar}. In many languages, this is called a `variable', but
Rust's variable bindings have a few tricks up their sleeves.

For example, they're \hyperref[sec--mutability]{immutable} by default.
That's why our example uses \texttt{mut}: it makes a binding mutable,
rather than immutable. \texttt{let} doesn't take a name on the left hand
side, it actually accepts a `\hyperref[sec--patterns]{pattern}'. We'll
use patterns later. It's easy enough to use for now:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{foo = }\DecValTok{5}\NormalTok{; }\CommentTok{// immutable.}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{bar = }\DecValTok{5}\NormalTok{; }\CommentTok{// mutable}
\end{Highlighting}
\end{Shaded}

Oh, and \texttt{//} will start a comment, until the end of the line.
Rust ignores everything in \hyperref[sec--comments]{comments}.

So now we know that \texttt{let\ mut\ guess} will introduce a mutable
binding named \texttt{guess}, but we have to look at the other side of
the \texttt{=} for what it's bound to: \texttt{String::new()}.

\texttt{String} is a string type, provided by the standard library. A
\href{http://doc.rust-lang.org/std/string/struct.String.html}{\texttt{String}}
is a growable, UTF-8 encoded bit of text.

The \texttt{::new()} syntax uses \texttt{::} because this is an
`associated function' of a particular type. That is to say, it's
associated with \texttt{String} itself, rather than a particular
instance of a \texttt{String}. Some languages call this a `static
method'.

This function is named \texttt{new()}, because it creates a new, empty
\texttt{String}. You'll find a \texttt{new()} function on many types, as
it's a common name for making a new value of some kind.

Let's move forward:

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"Failed to read line"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

That's a lot more! Let's go bit-by-bit. The first line has two parts.
Here's the first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{io::stdin()}
\end{Highlighting}
\end{Shaded}

Remember how we \texttt{use}d \texttt{std::io} on the first line of the
program? We're now calling an associated function on it. If we didn't
\texttt{use\ std::io}, we could have written this line as
\texttt{std::io::stdin()}.

This particular function returns a handle to the standard input for your
terminal. More specifically, a
\href{http://doc.rust-lang.org/std/io/struct.Stdin.html}{std::io::Stdin}.

The next part will use this handle to get input from the user:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.read_line(&}\KeywordTok{mut} \NormalTok{guess)}
\end{Highlighting}
\end{Shaded}

Here, we call the
\href{http://doc.rust-lang.org/std/io/struct.Stdin.html\#method.read_line}{\texttt{read\_line()}}
method on our handle. \hyperref[sec--method-syntax]{Methods} are like
associated functions, but are only available on a particular instance of
a type, rather than the type itself. We're also passing one argument to
\texttt{read\_line()}: \texttt{\&mut\ guess}.

Remember how we bound \texttt{guess} above? We said it was mutable.
However, \texttt{read\_line} doesn't take a \texttt{String} as an
argument: it takes a \texttt{\&mut\ String}. Rust has a feature called
`\hyperref[sec--references-and-borrowing]{references}', which allows you
to have multiple references to one piece of data, which can reduce
copying. References are a complex feature, as one of Rust's major
selling points is how safe and easy it is to use references. We don't
need to know a lot of those details to finish our program right now,
though. For now, all we need to know is that like \texttt{let} bindings,
references are immutable by default. Hence, we need to write
\texttt{\&mut\ guess}, rather than \texttt{\&guess}.

Why does \texttt{read\_line()} take a mutable reference to a string? Its
job is to take what the user types into standard input, and place that
into a string. So it takes that string as an argument, and in order to
add the input, it needs to be mutable.

But we're not quite done with this line of code, though. While it's a
single line of text, it's only the first part of the single logical line
of code:

\begin{Shaded}
\begin{Highlighting}[]
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"Failed to read line"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

When you call a method with the \texttt{.foo()} syntax, you may
introduce a newline and other whitespace. This helps you split up long
lines. We \emph{could} have done:

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess).ok().expect(}\StringTok{"failed to read line"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

But that gets hard to read. So we've split it up, three lines for three
method calls. We already talked about \texttt{read\_line()}, but what
about \texttt{ok()} and \texttt{expect()}? Well, we already mentioned
that \texttt{read\_line()} puts what the user types into the
\texttt{\&mut\ String} we pass it. But it also returns a value: in this
case, an
\href{http://doc.rust-lang.org/std/io/type.Result.html}{\texttt{io::Result}}.
Rust has a number of types named \texttt{Result} in its standard
library: a generic
\href{http://doc.rust-lang.org/std/result/enum.Result.html}{\texttt{Result}},
and then specific versions for sub-libraries, like \texttt{io::Result}.

The purpose of these \texttt{Result} types is to encode error handling
information. Values of the \texttt{Result} type, like any type, have
methods defined on them. In this case, \texttt{io::Result} has an
\texttt{ok()} method, which says `we want to assume this value is a
successful one. If not, just throw away the error information'. Why
throw it away? Well, for a basic program, we just want to print a
generic error, as basically any issue means we can't continue. The
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.ok}{\texttt{ok()}
method} returns a value which has another method defined on it:
\texttt{expect()}. The
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.expect}{\texttt{expect()}
method} takes a value it's called on, and if it isn't a successful one,
\hyperref[sec--error-handling]{\texttt{panic!}}s with a message you
passed it. A \texttt{panic!} like this will cause our program to crash,
displaying the message.

If we leave off calling these two methods, our program will compile, but
we'll get a warning:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{10}\NormalTok{:5: 10:39 warning: unused result which must be used,}
\CommentTok{#[warn(unused_must_use)] on by default}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{10}     \NormalTok{io::stdin()}\KeywordTok{.read_line}\NormalTok{(}\KeywordTok{&mut} \NormalTok{guess);}
                   \NormalTok{^}\KeywordTok{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
\end{Highlighting}
\end{Shaded}

Rust warns us that we haven't used the \texttt{Result} value. This
warning comes from a special annotation that \texttt{io::Result} has.
Rust is trying to tell you that you haven't handled a possible error.
The right way to suppress the error is to actually write error handling.
Luckily, if we just want to crash if there's a problem, we can use these
two little methods. If we can recover from the error somehow, we'd do
something else, but we'll save that for a future project.

There's just one line of this first example left:

\begin{Shaded}
\begin{Highlighting}[]
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints out the string we saved our input in. The \texttt{\{\}}s are
a placeholder, and so we pass it \texttt{guess} as an argument. If we
had multiple \texttt{\{\}}s, we would pass multiple arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = }\DecValTok{10}\NormalTok{;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"x and y: \{\} and \{\}"}\NormalTok{, x, y);}
\end{Highlighting}
\end{Shaded}

Easy.

Anyway, that's the tour. We can run what we have with
\texttt{cargo\ run}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/debug/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{6}
\KeywordTok{You} \NormalTok{guessed: 6}
\end{Highlighting}
\end{Shaded}

All right! Our first part is done: we can get input from the keyboard,
and then print it back out.

\subsection{Generating a secret
number}\label{generating-a-secret-number}

Next, we need to generate a secret number. Rust does not yet include
random number functionality in its standard library. The Rust team does,
however, provide a \href{https://crates.io/crates/rand}{\texttt{rand}
crate}. A `crate' is a package of Rust code. We've been building a
`binary crate', which is an executable. \texttt{rand} is a `library
crate', which contains code that's intended to be used with other
programs.

Using external crates is where Cargo really shines. Before we can write
the code using \texttt{rand}, we need to modify our \texttt{Cargo.toml}.
Open it up, and add these few lines at the bottom:

\begin{verbatim}
[dependencies]

rand="0.3.0"
\end{verbatim}

The \texttt{{[}dependencies{]}} section of \texttt{Cargo.toml} is like
the \texttt{{[}package{]}} section: everything that follows it is part
of it, until the next section starts. Cargo uses the dependencies
section to know what dependencies on external crates you have, and what
versions you require. In this case, we've specified version
\texttt{0.3.0}, which Cargo understands to be any release that's
compatible with this specific version. Cargo understands
\href{http://semver.org}{Semantic Versioning}, which is a standard for
writing version numbers. If we wanted to use only \texttt{0.3.0}
exactly, we could use \texttt{=0.3.0}. If we wanted to use the latest
version we could use \texttt{*}; We could use a range of versions.
\href{http://doc.crates.io/crates-io.html}{Cargo's documentation}
contains more details.

Now, without changing any of our code, let's build our project:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
    \KeywordTok{Updating} \NormalTok{registry }\KeywordTok{`https}\NormalTok{://github.com/rust-lang/crates.io-index}\KeywordTok{`}
 \KeywordTok{Downloading} \NormalTok{rand v0.3.8}
 \KeywordTok{Downloading} \NormalTok{libc v0.1.6}
   \KeywordTok{Compiling} \NormalTok{libc v0.1.6}
   \KeywordTok{Compiling} \NormalTok{rand v0.3.8}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
\end{Highlighting}
\end{Shaded}

(You may see different versions, of course.)

Lots of new output! Now that we have an external dependency, Cargo
fetches the latest versions of everything from the registry, which is a
copy of data from \href{https://crates.io}{Crates.io}. Crates.io is
where people in the Rust ecosystem post their open source Rust projects
for others to use.

After updating the registry, Cargo checks our
\texttt{{[}dependencies{]}} and downloads any we don't have yet. In this
case, while we only said we wanted to depend on \texttt{rand}, we've
also grabbed a copy of \texttt{libc}. This is because \texttt{rand}
depends on \texttt{libc} to work. After downloading them, it compiles
them, and then compiles our project.

If we run \texttt{cargo\ build} again, we'll get different output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
\end{Highlighting}
\end{Shaded}

That's right, no output! Cargo knows that our project has been built,
and that all of its dependencies are built, and so there's no reason to
do all that stuff. With nothing to do, it simply exits. If we open up
\texttt{src/main.rs} again, make a trivial change, and then save it
again, we'll just see one line:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
\end{Highlighting}
\end{Shaded}

So, we told Cargo we wanted any \texttt{0.3.x} version of \texttt{rand},
and so it fetched the latest version at the time this was written,
\texttt{v0.3.8}. But what happens when next week, version
\texttt{v0.3.9} comes out, with an important bugfix? While getting
bugfixes is important, what if \texttt{0.3.9} contains a regression that
breaks our code?

The answer to this problem is the \texttt{Cargo.lock} file you'll now
find in your project directory. When you build your project for the
first time, Cargo figures out all of the versions that fit your
criteria, and then writes them to the \texttt{Cargo.lock} file. When you
build your project in the future, Cargo will see that the
\texttt{Cargo.lock} file exists, and then use that specific version
rather than do all the work of figuring out versions again. This lets
you have a repeatable build automatically. In other words, we'll stay at
\texttt{0.3.8} until we explicitly upgrade, and so will anyone who we
share our code with, thanks to the lock file.

What about when we \emph{do} want to use \texttt{v0.3.9}? Cargo has
another command, \texttt{update}, which says `ignore the lock, figure
out all the latest versions that fit what we've specified. If that
works, write those versions out to the lock file'. But, by default,
Cargo will only look for versions larger than \texttt{0.3.0} and smaller
than \texttt{0.4.0}. If we want to move to \texttt{0.4.x}, we'd have to
update the \texttt{Cargo.toml} directly. When we do, the next time we
\texttt{cargo\ build}, Cargo will update the index and re-evaluate our
\texttt{rand} requirements.

There's a lot more to say about \href{http://doc.crates.io}{Cargo} and
\href{http://doc.crates.io/crates-io.html}{its ecosystem}, but for now,
that's all we need to know. Cargo makes it really easy to re-use
libraries, and so Rustaceans tend to write smaller projects which are
assembled out of a number of sub-packages.

Let's get on to actually \emph{using} \texttt{rand}. Here's our next
step:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first thing we've done is change the first line. It now says
\texttt{extern\ crate\ rand}. Because we declared \texttt{rand} in our
\texttt{{[}dependencies{]}}, we can use \texttt{extern\ crate} to let
Rust know we'll be making use of it. This also does the equivalent of a
\texttt{use\ rand;} as well, so we can make use of anything in the
\texttt{rand} crate by prefixing it with \texttt{rand::}.

Next, we added another \texttt{use} line: \texttt{use\ rand::Rng}. We're
going to use a method in a moment, and it requires that \texttt{Rng} be
in scope to work. The basic idea is this: methods are defined on
something called `traits', and for the method to work, it needs the
trait to be in scope. For more about the details, read the
\hyperref[sec--traits]{traits} section.

There are two other lines we added, in the middle:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}
\end{Highlighting}
\end{Shaded}

We use the \texttt{rand::thread\_rng()} function to get a copy of the
random number generator, which is local to the particular
\hyperref[sec--concurrency]{thread} of execution we're in. Because we
\texttt{use\ rand::Rng}'d above, it has a \texttt{gen\_range()} method
available. This method takes two arguments, and generates a number
between them. It's inclusive on the lower bound, but exclusive on the
upper bound, so we need \texttt{1} and \texttt{101} to get a number
ranging from one to a hundred.

The second line just prints out the secret number. This is useful while
we're developing our program, so we can easily test it out. But we'll be
deleting it for the final version. It's not much of a game if it prints
out the answer when you start it up!

Try running our new program a few times:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/debug/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{The} \NormalTok{secret number is: 7}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{4}
\KeywordTok{You} \NormalTok{guessed: 4}
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
     \KeywordTok{Running} \KeywordTok{`target/debug/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{The} \NormalTok{secret number is: 83}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{5}
\KeywordTok{You} \NormalTok{guessed: 5}
\end{Highlighting}
\end{Shaded}

Great! Next up: let's compare our guess to the secret guess.

\subsection{Comparing guesses}\label{comparing-guesses}

Now that we've got user input, let's compare our guess to the random
guess. Here's our next step, though it doesn't quite compile yet:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

    \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
        \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
        \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
        \NormalTok{Ordering::Equal   => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A few new bits here. The first is another \texttt{use}. We bring a type
called \texttt{std::cmp::Ordering} into scope. Then, five new lines at
the bottom that use it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
    \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
    \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
    \NormalTok{Ordering::Equal   => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{cmp()} method can be called on anything that can be
compared, and it takes a reference to the thing you want to compare it
to. It returns the \texttt{Ordering} type we \texttt{use}d earlier. We
use a \hyperref[sec--match]{\texttt{match}} statement to determine
exactly what kind of \texttt{Ordering} it is. \texttt{Ordering} is an
\hyperref[sec--enums]{\texttt{enum}}, short for `enumeration', which
looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \NormalTok{Foo \{}
    \NormalTok{Bar,}
    \NormalTok{Baz,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

With this definition, anything of type \texttt{Foo} can be either a
\texttt{Foo::Bar} or a \texttt{Foo::Baz}. We use the \texttt{::} to
indicate the namespace for a particular \texttt{enum} variant.

The
\href{http://doc.rust-lang.org/std/cmp/enum.Ordering.html}{\texttt{Ordering}}
enum has three possible variants: \texttt{Less}, \texttt{Equal}, and
\texttt{Greater}. The \texttt{match} statement takes a value of a type,
and lets you create an `arm' for each possible value. Since we have
three types of \texttt{Ordering}, we have three arms:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
    \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
    \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
    \NormalTok{Ordering::Equal   => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If it's \texttt{Less}, we print \texttt{Too\ small!}, if it's
\texttt{Greater}, \texttt{Too\ big!}, and if \texttt{Equal},
\texttt{You\ win!}. \texttt{match} is really useful, and is used often
in Rust.

I did mention that this won't quite compile yet, though. Let's try it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{28}\NormalTok{:21: 28:35 error: mismatched types:}
 \KeywordTok{expected} \KeywordTok{`&collections}\NormalTok{::string::String}\KeywordTok{`}\NormalTok{,}
    \KeywordTok{found} \KeywordTok{`&_`}
\KeywordTok{(expected} \NormalTok{struct }\KeywordTok{`collections}\NormalTok{::string::String}\KeywordTok{`}\NormalTok{,}
    \KeywordTok{found} \NormalTok{integral variable}\KeywordTok{)} \NormalTok{[}\KeywordTok{E0308}\NormalTok{]}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{28}     \NormalTok{match guess.cmp(}\KeywordTok{&secret_number}\NormalTok{) }\KeywordTok{\{}
                                   \NormalTok{^}\KeywordTok{~~~~~~~~~~~~~}
\KeywordTok{error}\NormalTok{: aborting due to previous error}
\KeywordTok{Could} \NormalTok{not compile }\KeywordTok{`guessing_game`}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Whew! This is a big error. The core of it is that we have `mismatched
types'. Rust has a strong, static type system. However, it also has type
inference. When we wrote \texttt{let\ guess\ =\ String::new()}, Rust was
able to infer that \texttt{guess} should be a \texttt{String}, and so it
doesn't make us write out the type. And with our
\texttt{secret\_number}, there are a number of types which can have a
value between one and a hundred: \texttt{i32}, a thirty-two-bit number,
or \texttt{u32}, an unsigned thirty-two-bit number, or \texttt{i64}, a
sixty-four-bit number or others. So far, that hasn't mattered, and so
Rust defaults to an \texttt{i32}. However, here, Rust doesn't know how
to compare the \texttt{guess} and the \texttt{secret\_number}. They need
to be the same type. Ultimately, we want to convert the \texttt{String}
we read as input into a real number type, for comparison. We can do that
with three more lines. Here's our new program:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

    \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= guess.trim().parse()}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"Please type a number!"}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

    \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
        \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
        \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
        \NormalTok{Ordering::Equal   => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The new three lines:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= guess.trim().parse()}
        \NormalTok{.ok()}
        \NormalTok{.expect(}\StringTok{"Please type a number!"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

Wait a minute, I thought we already had a \texttt{guess}? We do, but
Rust allows us to `shadow' the previous \texttt{guess} with a new one.
This is often used in this exact situation, where \texttt{guess} starts
as a \texttt{String}, but we want to convert it to an \texttt{u32}.
Shadowing lets us re-use the \texttt{guess} name, rather than forcing us
to come up with two unique names like \texttt{guess\_str} and
\texttt{guess}, or something else.

We bind \texttt{guess} to an expression that looks like something we
wrote earlier:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{guess.trim().parse()}
\end{Highlighting}
\end{Shaded}

Followed by an \texttt{ok().expect()} invocation. Here, \texttt{guess}
refers to the old \texttt{guess}, the one that was a \texttt{String}
with our input in it. The \texttt{trim()} method on \texttt{String}s
will eliminate any white space at the beginning and end of our string.
This is important, as we had to press the `return' key to satisfy
\texttt{read\_line()}. This means that if we type \texttt{5} and hit
return, \texttt{guess} looks like this: \texttt{5\textbackslash{}n}. The
\texttt{\textbackslash{}n} represents `newline', the enter key.
\texttt{trim()} gets rid of this, leaving our string with just the
\texttt{5}. The
\href{http://doc.rust-lang.org/std/primitive.str.html\#method.parse}{\texttt{parse()}
method on strings} parses a string into some kind of number. Since it
can parse a variety of numbers, we need to give Rust a hint as to the
exact type of number we want. Hence, \texttt{let\ guess:\ u32}. The
colon (\texttt{:}) after \texttt{guess} tells Rust we're going to
annotate its type. \texttt{u32} is an unsigned, thirty-two bit integer.
Rust has \hyperref[numeric-types]{a number of built-in number types},
but we've chosen \texttt{u32}. It's a good default choice for a small
positive number.

Just like \texttt{read\_line()}, our call to \texttt{parse()} could
cause an error. What if our string contained \texttt{Aüëç\%}? There'd be
no way to convert that to a number. As such, we'll do the same thing we
did with \texttt{read\_line()}: use the \texttt{ok()} and
\texttt{expect()} methods to crash if there's an error.

Let's try our program out!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{The} \NormalTok{secret number is: 58}
\KeywordTok{Please} \NormalTok{input your guess.}
  \KeywordTok{76}
\KeywordTok{You} \NormalTok{guessed: 76}
\KeywordTok{Too} \NormalTok{big!}
\end{Highlighting}
\end{Shaded}

Nice! You can see I even added spaces before my guess, and it still
figured out that I guessed 76. Run the program a few times, and verify
that guessing the number works, as well as guessing a number too small.

Now we've got most of the game working, but we can only make one guess.
Let's change that by adding loops!

\subsection{Looping}\label{looping}

The \texttt{loop} keyword gives us an infinite loop. Let's add that in:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \KeywordTok{loop} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

        \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

        \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= guess.trim().parse()}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"Please type a number!"}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

        \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
            \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
            \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
            \NormalTok{Ordering::Equal   => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And try it out. But wait, didn't we just add an infinite loop? Yup.
Remember our discussion about \texttt{parse()}? If we give a non-number
answer, we'll \texttt{return} and quit. Observe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{The} \NormalTok{secret number is: 59}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{45}
\KeywordTok{You} \NormalTok{guessed: 45}
\KeywordTok{Too} \NormalTok{small!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{60}
\KeywordTok{You} \NormalTok{guessed: 60}
\KeywordTok{Too} \NormalTok{big!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{59}
\KeywordTok{You} \NormalTok{guessed: 59}
\KeywordTok{You} \NormalTok{win!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{quit}
\KeywordTok{thread} \StringTok{'<main>'} \NormalTok{panicked at }\StringTok{'Please type a number!'}
\end{Highlighting}
\end{Shaded}

Ha! \texttt{quit} actually quits. As does any other non-number input.
Well, this is suboptimal to say the least. First, let's actually quit
when you win the game:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \KeywordTok{loop} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

        \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

        \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= guess.trim().parse()}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"Please type a number!"}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

        \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
            \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
            \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
            \NormalTok{Ordering::Equal   => \{}
                \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{);}
                \KeywordTok{break}\NormalTok{;}
            \NormalTok{\}}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By adding the \texttt{break} line after the \texttt{You\ win!}, we'll
exit the loop when we win. Exiting the loop also means exiting the
program, since it's the last thing in \texttt{main()}. We have just one
more tweak to make: when someone inputs a non-number, we don't want to
quit, we just want to ignore it. We can do that like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The secret number is: \{\}"}\NormalTok{, secret_number);}

    \KeywordTok{loop} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

        \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

        \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= }\KeywordTok{match} \NormalTok{guess.trim().parse() \{}
            \ConstantTok{Ok}\NormalTok{(num) => num,}
            \ConstantTok{Err}\NormalTok{(_) => }\KeywordTok{continue}\NormalTok{,}
        \NormalTok{\};}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

        \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
            \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
            \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
            \NormalTok{Ordering::Equal   => \{}
                \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{);}
                \KeywordTok{break}\NormalTok{;}
            \NormalTok{\}}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

These are the lines that changed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= }\KeywordTok{match} \NormalTok{guess.trim().parse() \{}
    \ConstantTok{Ok}\NormalTok{(num) => num,}
    \ConstantTok{Err}\NormalTok{(_) => }\KeywordTok{continue}\NormalTok{,}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

This is how you generally move from `crash on error' to `actually handle
the error', by switching from \texttt{ok().expect()} to a \texttt{match}
statement. The \texttt{Result} returned by \texttt{parse()} is an enum
just like \texttt{Ordering}, but in this case, each variant has some
data associated with it: \texttt{Ok} is a success, and \texttt{Err} is a
failure. Each contains more information: the successful parsed integer,
or an error type. In this case, we \texttt{match} on \texttt{Ok(num)},
which sets the inner value of the \texttt{Ok} to the name \texttt{num},
and then we just return it on the right-hand side. In the \texttt{Err}
case, we don't care what kind of error it is, so we just use \texttt{\_}
instead of a name. This ignores the error, and \texttt{continue} causes
us to go to the next iteration of the \texttt{loop}.

Now we should be good! Let's try:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{guessing_game v0.1.0 (file:///home/you/projects/guessing_game)}
     \KeywordTok{Running} \KeywordTok{`target/guessing_game`}
\KeywordTok{Guess} \NormalTok{the number!}
\KeywordTok{The} \NormalTok{secret number is: 61}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{10}
\KeywordTok{You} \NormalTok{guessed: 10}
\KeywordTok{Too} \NormalTok{small!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{99}
\KeywordTok{You} \NormalTok{guessed: 99}
\KeywordTok{Too} \NormalTok{big!}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{foo}
\KeywordTok{Please} \NormalTok{input your guess.}
\KeywordTok{61}
\KeywordTok{You} \NormalTok{guessed: 61}
\KeywordTok{You} \NormalTok{win!}
\end{Highlighting}
\end{Shaded}

Awesome! With one tiny last tweak, we have finished the guessing game.
Can you think of what it is? That's right, we don't want to print out
the secret number. It was good for testing, but it kind of ruins the
game. Here's our final source:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rand;}

\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::cmp::Ordering;}
\KeywordTok{use} \NormalTok{rand::Rng;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Guess the number!"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{secret_number = rand::thread_rng().gen_range(}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{);}

    \KeywordTok{loop} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Please input your guess."}\NormalTok{);}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{guess = }\DataTypeTok{String}\NormalTok{::new();}

        \NormalTok{io::stdin().read_line(&}\KeywordTok{mut} \NormalTok{guess)}
            \NormalTok{.ok()}
            \NormalTok{.expect(}\StringTok{"failed to read line"}\NormalTok{);}

        \KeywordTok{let} \NormalTok{guess: }\DataTypeTok{u32} \NormalTok{= }\KeywordTok{match} \NormalTok{guess.trim().parse() \{}
            \ConstantTok{Ok}\NormalTok{(num) => num,}
            \ConstantTok{Err}\NormalTok{(_) => }\KeywordTok{continue}\NormalTok{,}
        \NormalTok{\};}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You guessed: \{\}"}\NormalTok{, guess);}

        \KeywordTok{match} \NormalTok{guess.cmp(&secret_number) \{}
            \NormalTok{Ordering::Less    => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too small!"}\NormalTok{),}
            \NormalTok{Ordering::Greater => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Too big!"}\NormalTok{),}
            \NormalTok{Ordering::Equal   => \{}
                \PreprocessorTok{println!}\NormalTok{(}\StringTok{"You win!"}\NormalTok{);}
                \KeywordTok{break}\NormalTok{;}
            \NormalTok{\}}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Complete!}\label{complete}

At this point, you have successfully built the Guessing Game!
Congratulations!

This first project showed you a lot: \texttt{let}, \texttt{match},
methods, associated functions, using external crates, and more. Our next
project will show off even more.

\section{Dining Philosophers}\label{sec--dining-philosophers}

For our second project, let's look at a classic concurrency problem.
It's called `the dining philosophers'. It was originally conceived by
Dijkstra in 1965, but we'll use a lightly adapted version from
\href{http://www.usingcsp.com/cspbook.pdf}{this paper} by Tony Hoare in
1985.

\begin{quote}
In ancient times, a wealthy philanthropist endowed a College to
accommodate five eminent philosophers. Each philosopher had a room in
which they could engage in their professional activity of thinking;
there was also a common dining room, furnished with a circular table,
surrounded by five chairs, each labelled by the name of the philosopher
who was to sit in it. They sat anticlockwise around the table. To the
left of each philosopher there was laid a golden fork, and in the centre
stood a large bowl of spaghetti, which was constantly replenished. A
philosopher was expected to spend most of their time thinking; but when
they felt hungry, they went to the dining room, sat down in their own
chair, picked up their own fork on their left, and plunged it into the
spaghetti. But such is the tangled nature of spaghetti that a second
fork is required to carry it to the mouth. The philosopher therefore had
also to pick up the fork on their right. When they were finished they
would put down both their forks, get up from their chair, and continue
thinking. Of course, a fork can be used by only one philosopher at a
time. If the other philosopher wants it, they just have to wait until
the fork is available again.
\end{quote}

This classic problem shows off a few different elements of concurrency.
The reason is that it's actually slightly tricky to implement: a simple
implementation can deadlock. For example, let's consider a simple
algorithm that would solve this problem:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A philosopher picks up the fork on their left.
\item
  They then pick up the fork on their right.
\item
  They eat.
\item
  They return the forks.
\end{enumerate}

Now, let's imagine this sequence of events:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Philosopher 1 begins the algorithm, picking up the fork on their left.
\item
  Philosopher 2 begins the algorithm, picking up the fork on their left.
\item
  Philosopher 3 begins the algorithm, picking up the fork on their left.
\item
  Philosopher 4 begins the algorithm, picking up the fork on their left.
\item
  Philosopher 5 begins the algorithm, picking up the fork on their left.
\item
  \ldots{} ? All the forks are taken, but nobody can eat!
\end{enumerate}

There are different ways to solve this problem. We'll get to our
solution in the tutorial itself. For now, let's get started modelling
the problem itself. We'll start with the philosophers:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{p1 = Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p2 = Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p3 = Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p4 = Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p5 = Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here, we make a \hyperref[sec--structs]{\texttt{struct}} to represent a
philosopher. For now, a name is all we need. We choose the
\hyperref[sec--strings]{\texttt{String}} type for the name, rather than
\texttt{\&str}. Generally speaking, working with a type which owns its
data is easier than working with one that uses references.

Let's continue:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This \texttt{impl} block lets us define things on \texttt{Philosopher}
structs. In this case, we define an `associated function' called
\texttt{new}. The first line looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
\end{Highlighting}
\end{Shaded}

We take one argument, a \texttt{name}, of type \texttt{\&str}. This is a
reference to another string. It returns an instance of our
\texttt{Philosopher} struct.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Philosopher \{}
    \NormalTok{name: name.to_string(),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This creates a new \texttt{Philosopher}, and sets its \texttt{name} to
our \texttt{name} argument. Not just the argument itself, though, as we
call \texttt{.to\_string()} on it. This will create a copy of the string
that our \texttt{\&str} points to, and give us a new \texttt{String},
which is the type of the \texttt{name} field of \texttt{Philosopher}.

Why not accept a \texttt{String} directly? It's nicer to call. If we
took a \texttt{String}, but our caller had a \texttt{\&str}, they'd have
to call this method themselves. The downside of this flexibility is that
we \emph{always} make a copy. For this small program, that's not
particularly important, as we know we'll just be using short strings
anyway.

One last thing you'll notice: we just define a \texttt{Philosopher}, and
seemingly don't do anything with it. Rust is an `expression based'
language, which means that almost everything in Rust is an expression
which returns a value. This is true of functions as well, the last
expression is automatically returned. Since we create a new
\texttt{Philosopher} as the last expression of this function, we end up
returning it.

This name, \texttt{new()}, isn't anything special to Rust, but it is a
convention for functions that create new instances of structs. Before we
talk about why, let's look at \texttt{main()} again:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{#}
\NormalTok{#}
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{p1 = Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p2 = Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p3 = Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p4 = Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{);}
    \KeywordTok{let} \NormalTok{p5 = Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here, we create five variable bindings with five new philosophers. These
are my favorite five, but you can substitute anyone you want. If we
\emph{didn't} define that \texttt{new()} function, it would look like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{p1 = Philosopher \{ name: }\StringTok{"Judith Butler"}\NormalTok{.to_string() \};}
    \KeywordTok{let} \NormalTok{p2 = Philosopher \{ name: }\StringTok{"Gilles Deleuze"}\NormalTok{.to_string() \};}
    \KeywordTok{let} \NormalTok{p3 = Philosopher \{ name: }\StringTok{"Karl Marx"}\NormalTok{.to_string() \};}
    \KeywordTok{let} \NormalTok{p4 = Philosopher \{ name: }\StringTok{"Emma Goldman"}\NormalTok{.to_string() \};}
    \KeywordTok{let} \NormalTok{p5 = Philosopher \{ name: }\StringTok{"Michel Foucault"}\NormalTok{.to_string() \};}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That's much noisier. Using \texttt{new} has other advantages too, but
even in this simple case, it ends up being nicer to use.

Now that we've got the basics in place, there's a number of ways that we
can tackle the broader problem here. I like to start from the end first:
let's set up a way for each philosopher to finish eating. As a tiny
step, let's make a method, and then loop through all the philosophers,
calling it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
        \NormalTok{\}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{philosophers = }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{),}
    \NormalTok{];}

    \KeywordTok{for} \NormalTok{p }\KeywordTok{in} \NormalTok{&philosophers \{}
        \NormalTok{p.eat();}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's look at \texttt{main()} first. Rather than have five individual
variable bindings for our philosophers, we make a
\texttt{Vec\textless{}T\textgreater{}} of them instead.
\texttt{Vec\textless{}T\textgreater{}} is also called a `vector', and
it's a growable array type. We then use a
\hyperref[sec--for-loops]{\texttt{for}} loop to iterate through the
vector, getting a reference to each philosopher in turn.

In the body of the loop, we call \texttt{p.eat()}, which is defined
above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In Rust, methods take an explicit \texttt{self} parameter. That's why
\texttt{eat()} is a method, but \texttt{new} is an associated function:
\texttt{new()} has no \texttt{self}. For our first version of
\texttt{eat()}, we just print out the name of the philosopher, and
mention they're done eating. Running this program should give you the
following output:

\begin{verbatim}
Judith Butler is done eating.
Gilles Deleuze is done eating.
Karl Marx is done eating.
Emma Goldman is done eating.
Michel Foucault is done eating.
\end{verbatim}

Easy enough, they're all done! We haven't actually implemented the real
problem yet, though, so we're not done yet!

Next, we want to make our philosophers not just finish eating, but
actually eat. Here's the next version:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
        \NormalTok{\}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}

        \NormalTok{thread::sleep_ms(}\DecValTok{1000}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{philosophers = }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{),}
    \NormalTok{];}

    \KeywordTok{for} \NormalTok{p }\KeywordTok{in} \NormalTok{&philosophers \{}
        \NormalTok{p.eat();}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Just a few changes. Let's break it down.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}
\end{Highlighting}
\end{Shaded}

\texttt{use} brings names into scope. We're going to start using the
\texttt{thread} module from the standard library, and so we need to
\texttt{use} it.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}

        \NormalTok{thread::sleep_ms(}\DecValTok{1000}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
    \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We now print out two messages, with a \texttt{sleep\_ms()} in the
middle. This will simulate the time it takes a philosopher to eat.

If you run this program, you should see each philosopher eat in turn:

\begin{verbatim}
Judith Butler is eating.
Judith Butler is done eating.
Gilles Deleuze is eating.
Gilles Deleuze is done eating.
Karl Marx is eating.
Karl Marx is done eating.
Emma Goldman is eating.
Emma Goldman is done eating.
Michel Foucault is eating.
Michel Foucault is done eating.
\end{verbatim}

Excellent! We're getting there. There's just one problem: we aren't
actually operating in a concurrent fashion, which is a core part of the
problem!

To make our philosophers eat concurrently, we need to make a small
change. Here's the next iteration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
        \NormalTok{\}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}

        \NormalTok{thread::sleep_ms(}\DecValTok{1000}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{philosophers = }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{),}
    \NormalTok{];}

    \KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> = philosophers.into_iter().map(|p| \{}
        \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
            \NormalTok{p.eat();}
        \NormalTok{\})}
    \NormalTok{\}).collect();}

    \KeywordTok{for} \NormalTok{h }\KeywordTok{in} \NormalTok{handles \{}
        \NormalTok{h.join().unwrap();}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All we've done is change the loop in \texttt{main()}, and added a second
one! Here's the first change:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> = philosophers.into_iter().map(|p| \{}
    \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
        \NormalTok{p.eat();}
    \NormalTok{\})}
\NormalTok{\}).collect();}
\end{Highlighting}
\end{Shaded}

While this is only five lines, they're a dense five. Let's break it
down.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> =}
\end{Highlighting}
\end{Shaded}

We introduce a new binding, called \texttt{handles}. We've given it this
name because we are going to make some new threads, and that will return
some handles to those threads that let us control their operation. We
need to explicitly annotate the type here, though, due to an issue we'll
talk about later. The \texttt{\_} is a type placeholder. We're saying
``\texttt{handles} is a vector of something, but you can figure out what
that something is, Rust.''

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{philosophers.into_iter().map(|p| \{}
\end{Highlighting}
\end{Shaded}

We take our list of philosophers and call \texttt{into\_iter()} on it.
This creates an iterator that takes ownership of each philosopher. We
need to do this to pass them to our threads. We take that iterator and
call \texttt{map} on it, which takes a closure as an argument and calls
that closure on each element in turn.

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
        \NormalTok{p.eat();}
    \NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Here's where the concurrency happens. The \texttt{thread::spawn}
function takes a closure as an argument and executes that closure in a
new thread. This closure needs an extra annotation, \texttt{move}, to
indicate that the closure is going to take ownership of the values it's
capturing. Primarily, the \texttt{p} variable of the \texttt{map}
function.

Inside the thread, all we do is call \texttt{eat()} on \texttt{p}. Also
note that the call to \texttt{thread::spawn} lacks a trailing semicolon,
making this an expression. This distinction is important, yielding the
correct return value. For more details, read
\href{functions.html\#expressions-vs.-statements}{Expressions
vs.~Statements}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\}).collect();}
\end{Highlighting}
\end{Shaded}

Finally, we take the result of all those \texttt{map} calls and collect
them up. \texttt{collect()} will make them into a collection of some
kind, which is why we needed to annotate the return type: we want a
\texttt{Vec\textless{}T\textgreater{}}. The elements are the return
values of the \texttt{thread::spawn} calls, which are handles to those
threads. Whew!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{h }\KeywordTok{in} \NormalTok{handles \{}
    \NormalTok{h.join().unwrap();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

At the end of \texttt{main()}, we loop through the handles and call
\texttt{join()} on them, which blocks execution until the thread has
completed execution. This ensures that the threads complete their work
before the program exits.

If you run this program, you'll see that the philosophers eat out of
order! We have multi-threading!

\begin{verbatim}
Judith Butler is eating.
Gilles Deleuze is eating.
Karl Marx is eating.
Emma Goldman is eating.
Michel Foucault is eating.
Judith Butler is done eating.
Gilles Deleuze is done eating.
Karl Marx is done eating.
Emma Goldman is done eating.
Michel Foucault is done eating.
\end{verbatim}

But what about the forks? We haven't modeled them at all yet.

To do that, let's make a new \texttt{struct}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::sync::Mutex;}

\KeywordTok{struct} \NormalTok{Table \{}
    \NormalTok{forks: }\DataTypeTok{Vec}\NormalTok{<Mutex<()>>,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This \texttt{Table} has a vector of \texttt{Mutex}es. A mutex is a way
to control concurrency: only one thread can access the contents at once.
This is exactly the property we need with our forks. We use an empty
tuple, \texttt{()}, inside the mutex, since we're not actually going to
use the value, just hold onto it.

Let's modify the program to use the \texttt{Table}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}
\KeywordTok{use} \NormalTok{std::sync::\{Mutex, Arc\};}

\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{left: }\DataTypeTok{usize}\NormalTok{,}
    \NormalTok{right: }\DataTypeTok{usize}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Philosopher \{}
    \KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{, left: }\DataTypeTok{usize}\NormalTok{, right: }\DataTypeTok{usize}\NormalTok{) -> Philosopher \{}
        \NormalTok{Philosopher \{}
            \NormalTok{name: name.to_string(),}
            \NormalTok{left: left,}
            \NormalTok{right: right,}
        \NormalTok{\}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{, table: &Table) \{}
        \KeywordTok{let} \NormalTok{_left = table.forks[}\KeywordTok{self}\NormalTok{.left].lock().unwrap();}
        \KeywordTok{let} \NormalTok{_right = table.forks[}\KeywordTok{self}\NormalTok{.right].lock().unwrap();}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}

        \NormalTok{thread::sleep_ms(}\DecValTok{1000}\NormalTok{);}

        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Table \{}
    \NormalTok{forks: }\DataTypeTok{Vec}\NormalTok{<Mutex<()>>,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{table = Arc::new(Table \{ forks: }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
    \NormalTok{]\});}

    \KeywordTok{let} \NormalTok{philosophers = }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{),}
        \NormalTok{Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{),}
    \NormalTok{];}

    \KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> = philosophers.into_iter().map(|p| \{}
        \KeywordTok{let} \NormalTok{table = table.clone();}

        \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
            \NormalTok{p.eat(&table);}
        \NormalTok{\})}
    \NormalTok{\}).collect();}

    \KeywordTok{for} \NormalTok{h }\KeywordTok{in} \NormalTok{handles \{}
        \NormalTok{h.join().unwrap();}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Lots of changes! However, with this iteration, we've got a working
program. Let's go over the details:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::sync::\{Mutex, Arc\};}
\end{Highlighting}
\end{Shaded}

We're going to use another structure from the \texttt{std::sync}
package: \texttt{Arc\textless{}T\textgreater{}}. We'll talk more about
it when we use it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Philosopher \{}
    \NormalTok{name: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{left: }\DataTypeTok{usize}\NormalTok{,}
    \NormalTok{right: }\DataTypeTok{usize}\NormalTok{,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We need to add two more fields to our \texttt{Philosopher}. Each
philosopher is going to have two forks: the one on their left, and the
one on their right. We'll use the \texttt{usize} type to indicate them,
as it's the type that you index vectors with. These two values will be
the indexes into the \texttt{forks} our \texttt{Table} has.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{new(name: &}\DataTypeTok{str}\NormalTok{, left: }\DataTypeTok{usize}\NormalTok{, right: }\DataTypeTok{usize}\NormalTok{) -> Philosopher \{}
    \NormalTok{Philosopher \{}
        \NormalTok{name: name.to_string(),}
        \NormalTok{left: left,}
        \NormalTok{right: right,}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We now need to construct those \texttt{left} and \texttt{right} values,
so we add them to \texttt{new()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{eat(&}\KeywordTok{self}\NormalTok{, table: &Table) \{}
    \KeywordTok{let} \NormalTok{_left = table.forks[}\KeywordTok{self}\NormalTok{.left].lock().unwrap();}
    \KeywordTok{let} \NormalTok{_right = table.forks[}\KeywordTok{self}\NormalTok{.right].lock().unwrap();}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}

    \NormalTok{thread::sleep_ms(}\DecValTok{1000}\NormalTok{);}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} is done eating."}\NormalTok{, }\KeywordTok{self}\NormalTok{.name);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We have two new lines. We've also added an argument, \texttt{table}. We
access the \texttt{Table}'s list of forks, and then use
\texttt{self.left} and \texttt{self.right} to access the fork at that
particular index. That gives us access to the \texttt{Mutex} at that
index, and we call \texttt{lock()} on it. If the mutex is currently
being accessed by someone else, we'll block until it becomes available.

The call to \texttt{lock()} might fail, and if it does, we want to
crash. In this case, the error that could happen is that the mutex is
\href{http://doc.rust-lang.org/std/sync/struct.Mutex.html\#poisoning}{`poisoned'},
which is what happens when the thread panics while the lock is held.
Since this shouldn't happen, we just use \texttt{unwrap()}.

One other odd thing about these lines: we've named the results
\texttt{\_left} and \texttt{\_right}. What's up with that underscore?
Well, we aren't planning on \emph{using} the value inside the lock. We
just want to acquire it. As such, Rust will warn us that we never use
the value. By using the underscore, we tell Rust that this is what we
intended, and it won't throw a warning.

What about releasing the lock? Well, that will happen when
\texttt{\_left} and \texttt{\_right} go out of scope, automatically.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{let} \NormalTok{table = Arc::new(Table \{ forks: }\PreprocessorTok{vec!}\NormalTok{[}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
        \NormalTok{Mutex::new(()),}
    \NormalTok{]\});}
\end{Highlighting}
\end{Shaded}

Next, in \texttt{main()}, we make a new \texttt{Table} and wrap it in an
\texttt{Arc\textless{}T\textgreater{}}. `arc' stands for `atomic
reference count', and we need that to share our \texttt{Table} across
multiple threads. As we share it, the reference count will go up, and
when each thread ends, it will go back down.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{philosophers = }\PreprocessorTok{vec!}\NormalTok{[}
    \NormalTok{Philosopher::new(}\StringTok{"Judith Butler"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{),}
    \NormalTok{Philosopher::new(}\StringTok{"Gilles Deleuze"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
    \NormalTok{Philosopher::new(}\StringTok{"Karl Marx"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{),}
    \NormalTok{Philosopher::new(}\StringTok{"Emma Goldman"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{),}
    \NormalTok{Philosopher::new(}\StringTok{"Michel Foucault"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{),}
\NormalTok{];}
\end{Highlighting}
\end{Shaded}

We need to pass in our \texttt{left} and \texttt{right} values to the
constructors for our \texttt{Philosopher}s. But there's one more detail
here, and it's \emph{very} important. If you look at the pattern, it's
all consistent until the very end. Monsieur Foucault should have
\texttt{4,\ 0} as arguments, but instead, has \texttt{0,\ 4}. This is
what prevents deadlock, actually: one of our philosophers is left
handed! This is one way to solve the problem, and in my opinion, it's
the simplest.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> = philosophers.into_iter().map(|p| \{}
    \KeywordTok{let} \NormalTok{table = table.clone();}

    \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
        \NormalTok{p.eat(&table);}
    \NormalTok{\})}
\NormalTok{\}).collect();}
\end{Highlighting}
\end{Shaded}

Finally, inside of our \texttt{map()}/\texttt{collect()} loop, we call
\texttt{table.clone()}. The \texttt{clone()} method on
\texttt{Arc\textless{}T\textgreater{}} is what bumps up the reference
count, and when it goes out of scope, it decrements the count. This is
needed so that we know how many references to \texttt{table} exist
across our threads. If we didn't have a count, we wouldn't know how to
deallocate it.

You'll notice we can introduce a new binding to \texttt{table} here, and
it will shadow the old one. This is often used so that you don't need to
come up with two unique names.

With this, our program works! Only two philosophers can eat at any one
time, and so you'll get some output like this:

\begin{verbatim}
Gilles Deleuze is eating.
Emma Goldman is eating.
Emma Goldman is done eating.
Gilles Deleuze is done eating.
Judith Butler is eating.
Karl Marx is eating.
Judith Butler is done eating.
Michel Foucault is eating.
Karl Marx is done eating.
Michel Foucault is done eating.
\end{verbatim}

Congrats! You've implemented a classic concurrency problem in Rust.

\section{Rust Inside Other
Languages}\label{sec--rust-inside-other-languages}

For our third project, we're going to choose something that shows off
one of Rust's greatest strengths: a lack of a substantial runtime.

As organizations grow, they increasingly rely on a multitude of
programming languages. Different programming languages have different
strengths and weaknesses, and a polyglot stack lets you use a particular
language where its strengths make sense and a different one where it's
weak.

A very common area where many programming languages are weak is in
runtime performance of programs. Often, using a language that is slower,
but offers greater programmer productivity, is a worthwhile trade-off.
To help mitigate this, they provide a way to write some of your system
in C and then call that C code as though it were written in the
higher-level language. This is called a `foreign function interface',
often shortened to `FFI'.

Rust has support for FFI in both directions: it can call into C code
easily, but crucially, it can also be called \emph{into} as easily as C.
Combined with Rust's lack of a garbage collector and low runtime
requirements, this makes Rust a great candidate to embed inside of other
languages when you need that extra oomph.

There is a whole \hyperref[sec--ffi]{chapter devoted to FFI} and its
specifics elsewhere in the book, but in this chapter, we'll examine this
particular use-case of FFI, with examples in Ruby, Python, and
JavaScript.

\subsection{The problem}\label{the-problem}

There are many different projects we could choose here, but we're going
to pick an example where Rust has a clear advantage over many other
languages: numeric computing and threading.

Many languages, for the sake of consistency, place numbers on the heap,
rather than on the stack. Especially in languages that focus on
object-oriented programming and use garbage collection, heap allocation
is the default. Sometimes optimizations can stack allocate particular
numbers, but rather than relying on an optimizer to do its job, we may
want to ensure that we're always using primitive number types rather
than some sort of object type.

Second, many languages have a `global interpreter lock' (GIL), which
limits concurrency in many situations. This is done in the name of
safety, which is a positive effect, but it limits the amount of work
that can be done at the same time, which is a big negative.

To emphasize these two aspects, we're going to create a little project
that uses these two aspects heavily. Since the focus of the example is
to embed Rust into other languages, rather than the problem itself,
we'll just use a toy example:

\begin{quote}
Start ten threads. Inside each thread, count from one to five million.
After all ten threads are finished, print out `done!'.
\end{quote}

I chose five million based on my particular computer. Here's an example
of this code in Ruby:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threads = []}

\DecValTok{10}\NormalTok{.times }\KeywordTok{do}
  \NormalTok{threads << }\DataTypeTok{Thread}\NormalTok{.new }\KeywordTok{do}
    \NormalTok{count = }\DecValTok{0}

    \DecValTok{5_000_000}\NormalTok{.times }\KeywordTok{do}
      \NormalTok{count += }\DecValTok{1}
    \KeywordTok{end}

    \NormalTok{count}
  \KeywordTok{end}
\KeywordTok{end}

\NormalTok{threads.each }\KeywordTok{do} \NormalTok{|t|}
  \NormalTok{puts }\StringTok{"Thread finished with count=}\OtherTok{#\{}\NormalTok{t.value}\OtherTok{\}}\StringTok{"}
\KeywordTok{end}
\NormalTok{puts }\StringTok{"done!"}
\end{Highlighting}
\end{Shaded}

Try running this example, and choose a number that runs for a few
seconds. Depending on your computer's hardware, you may have to increase
or decrease the number.

On my system, running this program takes \texttt{2.156} seconds. And, if
I use some sort of process monitoring tool, like \texttt{top}, I can see
that it only uses one core on my machine. That's the GIL kicking in.

While it's true that this is a synthetic program, one can imagine many
problems that are similar to this in the real world. For our purposes,
spinning up a few busy threads represents some sort of parallel,
expensive computation.

\subsection{A Rust library}\label{a-rust-library}

Let's rewrite this problem in Rust. First, let's make a new project with
Cargo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{new embed}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{embed}
\end{Highlighting}
\end{Shaded}

This program is fairly easy to write in Rust:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{fn} \NormalTok{process() \{}
    \KeywordTok{let} \NormalTok{handles: }\DataTypeTok{Vec}\NormalTok{<_> = (}\DecValTok{0.}\NormalTok{.}\DecValTok{10}\NormalTok{).map(|_| \{}
        \NormalTok{thread::spawn(|| \{}
            \KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{0}\NormalTok{;}
            \KeywordTok{for} \NormalTok{_ }\KeywordTok{in} \NormalTok{(}\DecValTok{0.}\NormalTok{.}\DecValTok{5_000_000}\NormalTok{) \{}
                \NormalTok{x += }\DecValTok{1}
            \NormalTok{\}}
            \NormalTok{x}
        \NormalTok{\})}
    \NormalTok{\}).collect();}

    \KeywordTok{for} \NormalTok{h }\KeywordTok{in} \NormalTok{handles \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Thread finished with count=\{\}"}\NormalTok{,}
        \NormalTok{h.join().map_err(|_| }\StringTok{"Could not join a thread!"}\NormalTok{).unwrap());}
    \NormalTok{\}}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"done!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Some of this should look familiar from previous examples. We spin up ten
threads, collecting them into a \texttt{handles} vector. Inside of each
thread, we loop five million times, and add one to \texttt{x} each time.
Finally, we join on each thread.

Right now, however, this is a Rust library, and it doesn't expose
anything that's callable from C. If we tried to hook this up to another
language right now, it wouldn't work. We only need to make two small
changes to fix this, though. The first is to modify the beginning of our
code:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{no_mangle}\AttributeTok{]}
\KeywordTok{pub} \KeywordTok{extern} \KeywordTok{fn} \NormalTok{process() \{}
\end{Highlighting}
\end{Shaded}

We have to add a new attribute, \texttt{no\_mangle}. When you create a
Rust library, it changes the name of the function in the compiled
output. The reasons for this are outside the scope of this tutorial, but
in order for other languages to know how to call the function, we can't
do that. This attribute turns that behavior off.

The other change is the \texttt{pub\ extern}. The \texttt{pub} means
that this function should be callable from outside of this module, and
the \texttt{extern} says that it should be able to be called from C.
That's it! Not a whole lot of change.

The second thing we need to do is to change a setting in our
\texttt{Cargo.toml}. Add this at the bottom:

\begin{verbatim}
[lib]
name = "embed"
crate-type = ["dylib"]
\end{verbatim}

This tells Rust that we want to compile our library into a standard
dynamic library. By default, Rust compiles an `rlib', a Rust-specific
format.

Let's build the project now:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build --release}
   \KeywordTok{Compiling} \NormalTok{embed v0.1.0 (file:///home/steve/src/embed)}
\end{Highlighting}
\end{Shaded}

We've chosen \texttt{cargo\ build\ -\/-release}, which builds with
optimizations on. We want this to be as fast as possible! You can find
the output of the library in \texttt{target/release}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{ls} \NormalTok{target/release/}
\KeywordTok{build}  \NormalTok{deps  examples  libembed.so  native}
\end{Highlighting}
\end{Shaded}

That \texttt{libembed.so} is our `shared object' library. We can use
this file just like any shared object library written in C! As an aside,
this may be \texttt{embed.dll} or \texttt{libembed.dylib}, depending on
the platform.

Now that we've got our Rust library built, let's use it from our Ruby.

\subsection{Ruby}\label{ruby}

Open up an \texttt{embed.rb} file inside of our project, and do this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{require }\StringTok{'ffi'}

\KeywordTok{module} \DataTypeTok{Hello}
  \NormalTok{extend }\DataTypeTok{FFI}\NormalTok{::}\DataTypeTok{Library}
  \NormalTok{ffi_lib }\StringTok{'target/release/libembed.so'}
  \NormalTok{attach_function }\StringTok{:process}\NormalTok{, [], }\StringTok{:void}
\KeywordTok{end}

\DataTypeTok{Hello}\NormalTok{.process}

\NormalTok{puts }\StringTok{'done!'}
\end{Highlighting}
\end{Shaded}

Before we can run this, we need to install the \texttt{ffi} gem:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{gem} \NormalTok{install ffi }\CommentTok{# this may need sudo}
\KeywordTok{Fetching}\NormalTok{: ffi-1.9.8.gem (100%)}
\KeywordTok{Building} \NormalTok{native extensions.  This could take a while...}
\KeywordTok{Successfully} \NormalTok{installed ffi-1.9.8}
\KeywordTok{Parsing} \NormalTok{documentation for ffi-1.9.8}
\KeywordTok{Installing} \NormalTok{ri documentation for ffi-1.9.8}
\KeywordTok{Done} \NormalTok{installing documentation for ffi after 0 seconds}
\KeywordTok{1} \NormalTok{gem installed}
\end{Highlighting}
\end{Shaded}

And finally, we can try running it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{ruby} \NormalTok{embed.rb}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{Thread} \NormalTok{finished with count=5000000}
\KeywordTok{done}\NormalTok{!}
\KeywordTok{done}\NormalTok{!}
\NormalTok{$}
\end{Highlighting}
\end{Shaded}

Whoa, that was fast! On my system, this took \texttt{0.086} seconds,
rather than the two seconds the pure Ruby version took. Let's break down
this Ruby code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{require }\StringTok{'ffi'}
\end{Highlighting}
\end{Shaded}

We first need to require the \texttt{ffi} gem. This lets us interface
with our Rust library like a C library.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{module} \DataTypeTok{Hello}
  \NormalTok{extend }\DataTypeTok{FFI}\NormalTok{::}\DataTypeTok{Library}
  \NormalTok{ffi_lib }\StringTok{'target/release/libembed.so'}
\end{Highlighting}
\end{Shaded}

The \texttt{Hello} module is used to attach the native functions from
the shared library. Inside, we \texttt{extend} the necessary
\texttt{FFI::Library} module and then call \texttt{ffi\_lib} to load up
our shared object library. We just pass it the path that our library is
stored, which, as we saw before, is \texttt{target/release/libembed.so}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{attach_function }\StringTok{:process}\NormalTok{, [], }\StringTok{:void}
\end{Highlighting}
\end{Shaded}

The \texttt{attach\_function} method is provided by the FFI gem. It's
what connects our \texttt{process()} function in Rust to a Ruby function
of the same name. Since \texttt{process()} takes no arguments, the
second parameter is an empty array, and since it returns nothing, we
pass \texttt{:void} as the final argument.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Hello}\NormalTok{.process}
\end{Highlighting}
\end{Shaded}

This is the actual call into Rust. The combination of our
\texttt{module} and the call to \texttt{attach\_function} sets this all
up. It looks like a Ruby function but is actually Rust!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{puts }\StringTok{'done!'}
\end{Highlighting}
\end{Shaded}

Finally, as per our project's requirements, we print out \texttt{done!}.

That's it! As we've seen, bridging between the two languages is really
easy, and buys us a lot of performance.

Next, let's try Python!

\subsection{Python}\label{python}

Create an \texttt{embed.py} file in this directory, and put this in it:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from} \NormalTok{ctypes }\ImportTok{import} \NormalTok{cdll}

\NormalTok{lib }\OperatorTok{=} \NormalTok{cdll.LoadLibrary(}\StringTok{"target/release/libembed.so"}\NormalTok{)}

\NormalTok{lib.process()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"done!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Even easier! We use \texttt{cdll} from the \texttt{ctypes} module. A
quick call to \texttt{LoadLibrary} later, and we can call
\texttt{process()}.

On my system, this takes \texttt{0.017} seconds. Speedy!

\subsection{Node.js}\label{node.js}

Node isn't a language, but it's currently the dominant implementation of
server-side JavaScript.

In order to do FFI with Node, we first need to install the library:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{npm} \NormalTok{install ffi}
\end{Highlighting}
\end{Shaded}

After that installs, we can use it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var} \NormalTok{ffi }\OperatorTok{=} \AttributeTok{require}\NormalTok{(}\StringTok{'ffi'}\NormalTok{)}\OperatorTok{;}

\KeywordTok{var} \NormalTok{lib }\OperatorTok{=} \VariableTok{ffi}\NormalTok{.}\AttributeTok{Library}\NormalTok{(}\StringTok{'target/release/libembed'}\OperatorTok{,} \OperatorTok{\{}
  \StringTok{'process'}\OperatorTok{:} \NormalTok{[}\StringTok{'void'}\OperatorTok{,} \NormalTok{[]]}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\VariableTok{lib}\NormalTok{.}\AttributeTok{process}\NormalTok{()}\OperatorTok{;}

\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"done!"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It looks more like the Ruby example than the Python example. We use the
\texttt{ffi} module to get access to \texttt{ffi.Library()}, which loads
up our shared object. We need to annotate the return type and argument
types of the function, which are \texttt{void} for return and an empty
array to signify no arguments. From there, we just call it and print the
result.

On my system, this takes a quick \texttt{0.092} seconds.

\subsection{Conclusion}\label{conclusion}

As you can see, the basics of doing this are \emph{very} easy. Of
course, there's a lot more that we could do here. Check out the
\hyperref[sec--ffi]{FFI} chapter for more details.

\hyperdef{}{sec--effective-rust}{\chapter{Effective
Rust}\label{sec--effective-rust}}

So you've learned how to write some Rust code. But there's a difference
between writing \emph{any} Rust code and writing \emph{good} Rust code.

This section consists of relatively independent tutorials which show you
how to take your Rust to the next level. Common patterns and standard
library features will be introduced. Read these sections in any order of
your choosing.

\hyperdef{}{sec--the-stack-and-the-heap}{\section{The Stack and the
Heap}\label{sec--the-stack-and-the-heap}}

As a systems language, Rust operates at a low level. If you're coming
from a high-level language, there are some aspects of systems
programming that you may not be familiar with. The most important one is
how memory works, with a stack and a heap. If you're familiar with how
C-like languages use stack allocation, this chapter will be a refresher.
If you're not, you'll learn about this more general concept, but with a
Rust-y focus.

\subsection{Memory management}\label{memory-management}

These two terms are about memory management. The stack and the heap are
abstractions that help you determine when to allocate and deallocate
memory.

Here's a high-level comparison:

The stack is very fast, and is where memory is allocated in Rust by
default. But the allocation is local to a function call, and is limited
in size. The heap, on the other hand, is slower, and is explicitly
allocated by your program. But it's effectively unlimited in size, and
is globally accessible.

\subsection{The Stack}\label{the-stack}

Let's talk about this Rust program:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{42}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This program has one variable binding, \texttt{x}. This memory needs to
be allocated from somewhere. Rust `stack allocates' by default, which
means that basic values `go on the stack'. What does that mean?

Well, when a function gets called, some memory gets allocated for all of
its local variables and some other information. This is called a `stack
frame', and for the purpose of this tutorial, we're going to ignore the
extra information and just consider the local variables we're
allocating. So in this case, when \texttt{main()} is run, we'll allocate
a single 32-bit integer for our stack frame. This is automatically
handled for you, as you can see; we didn't have to write any special
Rust code or anything.

When the function is over, its stack frame gets deallocated. This
happens automatically, we didn't have to do anything special here.

That's all there is for this simple program. The key thing to understand
here is that stack allocation is very, very fast. Since we know all the
local variables we have ahead of time, we can grab the memory all at
once. And since we'll throw them all away at the same time as well, we
can get rid of it very fast too.

The downside is that we can't keep values around if we need them for
longer than a single function. We also haven't talked about what the
word, `stack', means. To do that, we need a slightly more complicated
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo() \{}
    \KeywordTok{let} \NormalTok{y = }\DecValTok{5}\NormalTok{;}
    \KeywordTok{let} \NormalTok{z = }\DecValTok{100}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{42}\NormalTok{;}

    \NormalTok{foo();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This program has three variables total: two in \texttt{foo()}, one in
\texttt{main()}. Just as before, when \texttt{main()} is called, a
single integer is allocated for its stack frame. But before we can show
what happens when \texttt{foo()} is called, we need to visualize what's
going on with memory. Your operating system presents a view of memory to
your program that's pretty simple: a huge list of addresses, from 0 to a
large number, representing how much RAM your computer has. For example,
if you have a gigabyte of RAM, your addresses go from \texttt{0} to
\texttt{1,073,741,823}. That number comes from 2\textsuperscript{30},
the number of bytes in a gigabyte.

This memory is kind of like a giant array: addresses start at zero and
go up to the final number. So here's a diagram of our first stack frame:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

We've got \texttt{x} located at address \texttt{0}, with the value
\texttt{42}.

When \texttt{foo()} is called, a new stack frame is allocated:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2 & z & 100\tabularnewline
1 & y & 5\tabularnewline
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

Because \texttt{0} was taken by the first frame, \texttt{1} and
\texttt{2} are used for \texttt{foo()}'s stack frame. It grows upward,
the more functions we call.

There's some important things we have to take note of here. The numbers
0, 1, and 2 are all solely for illustrative purposes, and bear no
relationship to the actual numbers the computer will actually use. In
particular, the series of addresses are in reality going to be separated
by some number of bytes that separate each address, and that separation
may even exceed the size of the value being stored.

After \texttt{foo()} is over, its frame is deallocated:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

And then, after \texttt{main()}, even this last value goes away. Easy!

It's called a `stack' because it works like a stack of dinner plates:
the first plate you put down is the last plate to pick back up. Stacks
are sometimes called `last in, first out queues' for this reason, as the
last value you put on the stack is the first one you retrieve from it.

Let's try a three-deep example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{bar() \{}
    \KeywordTok{let} \NormalTok{i = }\DecValTok{6}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{foo() \{}
    \KeywordTok{let} \NormalTok{a = }\DecValTok{5}\NormalTok{;}
    \KeywordTok{let} \NormalTok{b = }\DecValTok{100}\NormalTok{;}
    \KeywordTok{let} \NormalTok{c = }\DecValTok{1}\NormalTok{;}

    \NormalTok{bar();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{42}\NormalTok{;}

    \NormalTok{foo();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Okay, first, we call \texttt{main()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

Next up, \texttt{main()} calls \texttt{foo()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
3 & c & 1\tabularnewline
2 & b & 100\tabularnewline
1 & a & 5\tabularnewline
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

And then \texttt{foo()} calls \texttt{bar()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
4 & i & 6\tabularnewline
3 & c & 1\tabularnewline
2 & b & 100\tabularnewline
1 & a & 5\tabularnewline
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

Whew! Our stack is growing tall.

After \texttt{bar()} is over, its frame is deallocated, leaving just
\texttt{foo()} and \texttt{main()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
3 & c & 1\tabularnewline
2 & b & 100\tabularnewline
1 & a & 5\tabularnewline
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

And then \texttt{foo()} ends, leaving just \texttt{main()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
0 & x & 42\tabularnewline
\bottomrule
\end{longtable}

And then we're done. Getting the hang of it? It's like piling up dishes:
you add to the top, you take away from the top.

\subsection{The Heap}\label{the-heap}

Now, this works pretty well, but not everything can work like this.
Sometimes, you need to pass some memory between different functions, or
keep it alive for longer than a single function's execution. For this,
we can use the heap.

In Rust, you can allocate memory on the heap with the
\href{http://doc.rust-lang.org/std/boxed/index.html}{\texttt{Box\textless{}T\textgreater{}}
type}. Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DataTypeTok{Box}\NormalTok{::new(}\DecValTok{5}\NormalTok{);}
    \KeywordTok{let} \NormalTok{y = }\DecValTok{42}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here's what happens in memory when \texttt{main()} is called:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
1 & y & 42\tabularnewline
0 & x & ??????\tabularnewline
\bottomrule
\end{longtable}

We allocate space for two variables on the stack. \texttt{y} is
\texttt{42}, as it always has been, but what about \texttt{x}? Well,
\texttt{x} is a \texttt{Box\textless{}i32\textgreater{}}, and boxes
allocate memory on the heap. The actual value of the box is a structure
which has a pointer to `the heap'. When we start executing the function,
and \texttt{Box::new()} is called, it allocates some memory for the
heap, and puts \texttt{5} there. The memory now looks like this:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 5\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
1 & y & 42\tabularnewline
0 & x & ‚Üí 2\textsuperscript{30}\tabularnewline
\bottomrule
\end{longtable}

We have 2\textsuperscript{30} in our hypothetical computer with 1GB of
RAM. And since our stack grows from zero, the easiest place to allocate
memory is from the other end. So our first value is at the highest place
in memory. And the value of the struct at \texttt{x} has a
\hyperref[sec--raw-pointers]{raw pointer} to the place we've allocated
on the heap, so the value of \texttt{x} is 2\textsuperscript{30}, the
memory location we've asked for.

We haven't really talked too much about what it actually means to
allocate and deallocate memory in these contexts. Getting into very deep
detail is out of the scope of this tutorial, but what's important to
point out here is that the heap isn't just a stack that grows from the
opposite end. We'll have an example of this later in the book, but
because the heap can be allocated and freed in any order, it can end up
with `holes'. Here's a diagram of the memory layout of a program which
has been running for a while now:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 5\tabularnewline
(2\textsuperscript{30}) - 1 & &\tabularnewline
(2\textsuperscript{30}) - 2 & &\tabularnewline
(2\textsuperscript{30}) - 3 & & 42\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
3 & y & ‚Üí (2\textsuperscript{30}) - 3\tabularnewline
2 & y & 42\tabularnewline
1 & y & 42\tabularnewline
0 & x & ‚Üí 2\textsuperscript{30}\tabularnewline
\bottomrule
\end{longtable}

In this case, we've allocated four things on the heap, but deallocated
two of them. There's a gap between 2\textsuperscript{30} and
(2\textsuperscript{30}) - 3 which isn't currently being used. The
specific details of how and why this happens depends on what kind of
strategy you use to manage the heap. Different programs can use
different `memory allocators', which are libraries that manage this for
you. Rust programs use
\href{http://www.canonware.com/jemalloc/}{jemalloc} for this purpose.

Anyway, back to our example. Since this memory is on the heap, it can
stay alive longer than the function which allocates the box. In this
case, however, it doesn't.\footnote{We can make the memory live longer
  by transferring ownership, sometimes called `moving out of the box'.
  More complex examples will be covered later.} When the function is
over, we need to free the stack frame for \texttt{main()}.
\texttt{Box\textless{}T\textgreater{}}, though, has a trick up its
sleeve: \hyperref[sec--drop]{Drop}. The implementation of \texttt{Drop}
for \texttt{Box} deallocates the memory that was allocated when it was
created. Great! So when \texttt{x} goes away, it first frees the memory
allocated on the heap:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
1 & y & 42\tabularnewline
0 & x & ??????\tabularnewline
\bottomrule
\end{longtable}

And then the stack frame goes away, freeing all of our memory.

\subsection{Arguments and borrowing}\label{arguments-and-borrowing}

We've got some basic examples with the stack and the heap going, but
what about function arguments and borrowing? Here's a small Rust
program:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(i: &}\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{z = }\DecValTok{42}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
    \KeywordTok{let} \NormalTok{y = &x;}

    \NormalTok{foo(y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When we enter \texttt{main()}, memory looks like this:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
1 & y & ‚Üí 0\tabularnewline
0 & x & 5\tabularnewline
\bottomrule
\end{longtable}

\texttt{x} is a plain old \texttt{5}, and \texttt{y} is a reference to
\texttt{x}. So its value is the memory location that \texttt{x} lives
at, which in this case is \texttt{0}.

What about when we call \texttt{foo()}, passing \texttt{y} as an
argument?

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
3 & z & 42\tabularnewline
2 & i & ‚Üí 0\tabularnewline
1 & y & ‚Üí 0\tabularnewline
0 & x & 5\tabularnewline
\bottomrule
\end{longtable}

Stack frames aren't just for local bindings, they're for arguments too.
So in this case, we need to have both \texttt{i}, our argument, and
\texttt{z}, our local variable binding. \texttt{i} is a copy of the
argument, \texttt{y}. Since \texttt{y}'s value is \texttt{0}, so is
\texttt{i}'s.

This is one reason why borrowing a variable doesn't deallocate any
memory: the value of a reference is just a pointer to a memory location.
If we got rid of the underlying memory, things wouldn't work very well.

\subsection{A complex example}\label{a-complex-example}

Okay, let's go through this complex program step-by-step:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(x: &}\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{y = }\DecValTok{10}\NormalTok{;}
    \KeywordTok{let} \NormalTok{z = &y;}

    \NormalTok{baz(z);}
    \NormalTok{bar(x, z);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{bar(a: &}\DataTypeTok{i32}\NormalTok{, b: &}\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{c = }\DecValTok{5}\NormalTok{;}
    \KeywordTok{let} \NormalTok{d = }\DataTypeTok{Box}\NormalTok{::new(}\DecValTok{5}\NormalTok{);}
    \KeywordTok{let} \NormalTok{e = &d;}

    \NormalTok{baz(e);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{baz(f: &}\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{g = }\DecValTok{100}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{h = }\DecValTok{3}\NormalTok{;}
    \KeywordTok{let} \NormalTok{i = }\DataTypeTok{Box}\NormalTok{::new(}\DecValTok{20}\NormalTok{);}
    \KeywordTok{let} \NormalTok{j = &h;}

    \NormalTok{foo(j);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

First, we call \texttt{main()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

We allocate memory for \texttt{j}, \texttt{i}, and \texttt{h}.
\texttt{i} is on the heap, and so has a value pointing there.

Next, at the end of \texttt{main()}, \texttt{foo()} gets called:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

Space gets allocated for \texttt{x}, \texttt{y}, and \texttt{z}. The
argument \texttt{x} has the same value as \texttt{j}, since that's what
we passed it in. It's a pointer to the \texttt{0} address, since
\texttt{j} points at \texttt{h}.

Next, \texttt{foo()} calls \texttt{baz()}, passing \texttt{z}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
7 & g & 100\tabularnewline
6 & f & ‚Üí 4\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

We've allocated memory for \texttt{f} and \texttt{g}. \texttt{baz()} is
very short, so when it's over, we get rid of its stack frame:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

Next, \texttt{foo()} calls \texttt{bar()} with \texttt{x} and
\texttt{z}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
(2\textsuperscript{30}) - 1 & & 5\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
10 & e & ‚Üí 9\tabularnewline
9 & d & ‚Üí (2\textsuperscript{30}) - 1\tabularnewline
8 & c & 5\tabularnewline
7 & b & ‚Üí 4\tabularnewline
6 & a & ‚Üí 0\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

We end up allocating another value on the heap, and so we have to
subtract one from 2\textsuperscript{30}. It's easier to just write that
than \texttt{1,073,741,823}. In any case, we set up the variables as
usual.

At the end of \texttt{bar()}, it calls \texttt{baz()}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
(2\textsuperscript{30}) - 1 & & 5\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
12 & g & 100\tabularnewline
11 & f & ‚Üí 9\tabularnewline
10 & e & ‚Üí 9\tabularnewline
9 & d & ‚Üí (2\textsuperscript{30}) - 1\tabularnewline
8 & c & 5\tabularnewline
7 & b & ‚Üí 4\tabularnewline
6 & a & ‚Üí 0\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

With this, we're at our deepest point! Whew! Congrats for following
along this far.

After \texttt{baz()} is over, we get rid of \texttt{f} and \texttt{g}:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
(2\textsuperscript{30}) - 1 & & 5\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
10 & e & ‚Üí 9\tabularnewline
9 & d & ‚Üí (2\textsuperscript{30}) - 1\tabularnewline
8 & c & 5\tabularnewline
7 & b & ‚Üí 4\tabularnewline
6 & a & ‚Üí 0\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

Next, we return from \texttt{bar()}. \texttt{d} in this case is a
\texttt{Box\textless{}T\textgreater{}}, so it also frees what it points
to: (2\textsuperscript{30}) - 1.

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
5 & z & ‚Üí 4\tabularnewline
4 & y & 10\tabularnewline
3 & x & ‚Üí 0\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

And after that, \texttt{foo()} returns:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Address & Name & Value\tabularnewline
\midrule
\endhead
2\textsuperscript{30} & & 20\tabularnewline
\ldots{} & \ldots{} & \ldots{}\tabularnewline
2 & j & ‚Üí 0\tabularnewline
1 & i & ‚Üí 2\textsuperscript{30}\tabularnewline
0 & h & 3\tabularnewline
\bottomrule
\end{longtable}

And then, finally, \texttt{main()}, which cleans the rest up. When
\texttt{i} is \texttt{Drop}ped, it will clean up the last of the heap
too.

\subsection{What do other languages
do?}\label{what-do-other-languages-do}

Most languages with a garbage collector heap-allocate by default. This
means that every value is boxed. There are a number of reasons why this
is done, but they're out of scope for this tutorial. There are some
possible optimizations that don't make it true 100\% of the time, too.
Rather than relying on the stack and \texttt{Drop} to clean up memory,
the garbage collector deals with the heap instead.

\subsection{Which to use?}\label{which-to-use}

So if the stack is faster and easier to manage, why do we need the heap?
A big reason is that Stack-allocation alone means you only have LIFO
semantics for reclaiming storage. Heap-allocation is strictly more
general, allowing storage to be taken from and returned to the pool in
arbitrary order, but at a complexity cost.

Generally, you should prefer stack allocation, and so, Rust
stack-allocates by default. The LIFO model of the stack is simpler, at a
fundamental level. This has two big impacts: runtime efficiency and
semantic impact.

\subsubsection{Runtime Efficiency}\label{runtime-efficiency}

Managing the memory for the stack is trivial: The machine just
increments or decrements a single value, the so-called ``stack
pointer''. Managing memory for the heap is non-trivial: heap-allocated
memory is freed at arbitrary points, and each block of heap-allocated
memory can be of arbitrary size, the memory manager must generally work
much harder to identify memory for reuse.

If you'd like to dive into this topic in greater detail,
\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688}{this
paper} is a great introduction.

\subsubsection{Semantic impact}\label{semantic-impact}

Stack-allocation impacts the Rust language itself, and thus the
developer's mental model. The LIFO semantics is what drives how the Rust
language handles automatic memory management. Even the deallocation of a
uniquely-owned heap-allocated box can be driven by the stack-based LIFO
semantics, as discussed throughout this chapter. The flexibility
(i.e.~expressiveness) of non LIFO-semantics means that in general the
compiler cannot automatically infer at compile-time where memory should
be freed; it has to rely on dynamic protocols, potentially from outside
the language itself, to drive deallocation (reference counting, as used
by \texttt{Rc\textless{}T\textgreater{}} and
\texttt{Arc\textless{}T\textgreater{}}, is one example of this).

When taken to the extreme, the increased expressive power of heap
allocation comes at the cost of either significant runtime support
(e.g.~in the form of a garbage collector) or significant programmer
effort (in the form of explicit memory management calls that require
verification not provided by the Rust compiler).

\hyperdef{}{sec--testing}{\section{Testing}\label{sec--testing}}

\begin{quote}
Program testing can be a very effective way to show the presence of
bugs, but it is hopelessly inadequate for showing their absence.

Edsger W. Dijkstra, ``The Humble Programmer'' (1972)
\end{quote}

Let's talk about how to test Rust code. What we will not be talking
about is the right way to test Rust code. There are many schools of
thought regarding the right and wrong way to write tests. All of these
approaches use the same basic tools, and so we'll show you the syntax
for using them.

\subsection{\texorpdfstring{The \texttt{test}
attribute}{The test attribute}}\label{the-test-attribute}

At its simplest, a test in Rust is a function that's annotated with the
\texttt{test} attribute. Let's make a new project with Cargo called
\texttt{adder}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{new adder}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{adder}
\end{Highlighting}
\end{Shaded}

Cargo will automatically generate a simple test when you make a new
project. Here's the contents of \texttt{src/lib.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the \texttt{\#{[}test{]}}. This attribute indicates that this is a
test function. It currently has no body. That's good enough to pass! We
can run the tests with \texttt{cargo\ test}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

Cargo compiled and ran our tests. There are two sets of output here: one
for the test we wrote, and another for documentation tests. We'll talk
about those later. For now, see this line:

\begin{verbatim}
test it_works ... ok
\end{verbatim}

Note the \texttt{it\_works}. This comes from the name of our function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{it_works() \{}
\end{Highlighting}
\end{Shaded}

We also get a summary line:

\begin{verbatim}
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
\end{verbatim}

So why does our do-nothing test pass? Any test which doesn't
\texttt{panic!} passes, and any test that does \texttt{panic!} fails.
Let's make our test fail:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert!}\NormalTok{(}\ConstantTok{false}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{assert!} is a macro provided by Rust which takes one argument:
if the argument is \texttt{true}, nothing happens. If the argument is
false, it \texttt{panic!}s. Let's run our tests again:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... FAILED}

\KeywordTok{failures}\NormalTok{:}

\KeywordTok{----} \NormalTok{it_works stdout ----}
        \KeywordTok{thread} \StringTok{'it_works'} \NormalTok{panicked at }\StringTok{'assertion failed: false'}\NormalTok{, /home/steve/tmp/adder}
\NormalTok{‚Ü≥ }\KeywordTok{/src}\NormalTok{/lib.rs:}\KeywordTok{3}



\KeywordTok{failures}\NormalTok{:}
    \KeywordTok{it_works}

\KeywordTok{test} \NormalTok{result: FAILED. 0 passed}\KeywordTok{;} \KeywordTok{1} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

\KeywordTok{thread} \StringTok{'<main>'} \NormalTok{panicked at }\StringTok{'Some tests failed'}\NormalTok{, /home/steve/src/rust/src/libtest/lib.}
\NormalTok{‚Ü≥ }\KeywordTok{rs}\NormalTok{:247}
\end{Highlighting}
\end{Shaded}

Rust indicates that our test failed:

\begin{verbatim}
test it_works ... FAILED
\end{verbatim}

And that's reflected in the summary line:

\begin{verbatim}
test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
\end{verbatim}

We also get a non-zero status code. We can use \texttt{\$?} on OS X and
Linux:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{echo} \OtherTok{$?}
\KeywordTok{101}
\end{Highlighting}
\end{Shaded}

On Windows, if you're using \texttt{cmd}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{>} \KeywordTok{echo} \NormalTok{%ERRORLEVEL%}
\end{Highlighting}
\end{Shaded}

And if you're using PowerShell:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{>} \KeywordTok{echo} \OtherTok{$LASTEXITCODE} \CommentTok{# the code itself}
\KeywordTok{>} \KeywordTok{echo} \OtherTok{$?} \CommentTok{# a boolean, fail or succeed}
\end{Highlighting}
\end{Shaded}

This is useful if you want to integrate \texttt{cargo\ test} into other
tooling.

We can invert our test's failure with another attribute:
\texttt{should\_panic}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\AttributeTok{#[}\NormalTok{should_panic}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert!}\NormalTok{(}\ConstantTok{false}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This test will now succeed if we \texttt{panic!} and fail if we
complete. Let's try it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

Rust provides another macro, \texttt{assert\_eq!}, that compares two
arguments for equality:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\AttributeTok{#[}\NormalTok{should_panic}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Does this test pass or fail? Because of the \texttt{should\_panic}
attribute, it passes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

\texttt{should\_panic} tests can be fragile, as it's hard to guarantee
that the test didn't fail for an unexpected reason. To help with this,
an optional \texttt{expected} parameter can be added to the
\texttt{should\_panic} attribute. The test harness will make sure that
the failure message contains the provided text. A safer version of the
example above would be:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\AttributeTok{#[}\NormalTok{should_panic}\AttributeTok{(}\NormalTok{expected }\AttributeTok{=} \StringTok{"assertion failed"}\AttributeTok{)]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That's all there is to the basics! Let's write one `real' test:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{add_two(a: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{a + }\DecValTok{2}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is a very common use of \texttt{assert\_eq!}: call some function
with some known arguments and compare it to the expected output.

\subsection{\texorpdfstring{The \texttt{ignore}
attribute}{The ignore attribute}}\label{the-ignore-attribute}

Sometimes a few specific tests can be very time-consuming to execute.
These can be disabled by default by using the \texttt{ignore} attribute:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\AttributeTok{#[}\NormalTok{ignore}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{expensive_test() \{}
    \CommentTok{// code that takes an hour to run}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we run our tests and see that \texttt{it\_works} is run, but
\texttt{expensive\_test} is not:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{2 tests}
\KeywordTok{test} \NormalTok{expensive_test ... ignored}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{1} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

The expensive tests can be run explicitly using
\texttt{cargo\ test\ -\/-\ -\/-ignored}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test -- --ignored}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{expensive_test ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

The \texttt{-\/-ignored} argument is an argument to the test binary, and
not to cargo, which is why the command is
\texttt{cargo\ test\ -\/-\ -\/-ignored}.

\subsection{\texorpdfstring{The \texttt{tests}
module}{The tests module}}\label{the-tests-module}

There is one way in which our existing example is not idiomatic: it's
missing the \texttt{tests} module. The idiomatic way of writing our
example looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{add_two(a: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{a + }\DecValTok{2}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{tests \{}
    \KeywordTok{use} \KeywordTok{super}\NormalTok{::add_two;}

    \AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
    \KeywordTok{fn} \NormalTok{it_works() \{}
        \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's a few changes here. The first is the introduction of a
\texttt{mod\ tests} with a \texttt{cfg} attribute. The module allows us
to group all of our tests together, and to also define helper functions
if needed, that don't become a part of the rest of our crate. The
\texttt{cfg} attribute only compiles our test code if we're currently
trying to run the tests. This can save compile time, and also ensures
that our tests are entirely left out of a normal build.

The second change is the \texttt{use} declaration. Because we're in an
inner module, we need to bring our test function into scope. This can be
annoying if you have a large module, and so this is a common use of
globs. Let's change our \texttt{src/lib.rs} to make use of it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{add_two(a: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{a + }\DecValTok{2}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{tests \{}
    \KeywordTok{use} \KeywordTok{super}\NormalTok{::*;}

    \AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
    \KeywordTok{fn} \NormalTok{it_works() \{}
        \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the different \texttt{use} line. Now we run our tests:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
    \KeywordTok{Updating} \NormalTok{registry }\KeywordTok{`https}\NormalTok{://github.com/rust-lang/crates.io-index}\KeywordTok{`}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{tests::it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

It works!

The current convention is to use the \texttt{tests} module to hold your
``unit-style'' tests. Anything that just tests one small bit of
functionality makes sense to go here. But what about
``integration-style'' tests instead? For that, we have the
\texttt{tests} directory

\subsection{\texorpdfstring{The \texttt{tests}
directory}{The tests directory}}\label{the-tests-directory}

To write an integration test, let's make a \texttt{tests} directory, and
put a \texttt{tests/lib.rs} file inside, with this as its contents:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{adder;}

\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{it_works() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, adder::add_two(}\DecValTok{2}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This looks similar to our previous tests, but slightly different. We now
have an \texttt{extern\ crate\ adder} at the top. This is because the
tests in the \texttt{tests} directory are an entirely separate crate,
and so we need to import our library. This is also why \texttt{tests} is
a suitable place to write integration-style tests: they use the library
like any other consumer of it would.

Let's run them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/you/projects/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{tests::it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

     \KeywordTok{Running} \NormalTok{target/lib-c18e7d3494509e74}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{0 tests}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

Now we have three sections: our previous test is also run, as well as
our new one.

That's all there is to the \texttt{tests} directory. The \texttt{tests}
module isn't needed here, since the whole thing is focused on tests.

Let's finally check out that third section: documentation tests.

\subsection{Documentation tests}\label{documentation-tests}

Nothing is better than documentation with examples. Nothing is worse
than examples that don't actually work, because the code has changed
since the documentation has been written. To this end, Rust supports
automatically running examples in your documentation (\textbf{note:}
this only works in library crates, not binary crates). Here's a
fleshed-out \texttt{src/lib.rs} with examples:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//! The `adder` crate provides functions that add numbers to other numbers.}
\CommentTok{//!}
\CommentTok{//! # Examples}
\CommentTok{//!}
\CommentTok{//! ```}
\CommentTok{//! assert_eq!(4, adder::add_two(2));}
\CommentTok{//! ```}

\CommentTok{/// This function adds two to its argument.}
\CommentTok{///}
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// use adder::add_two;}
\CommentTok{///}
\CommentTok{/// assert_eq!(4, add_two(2));}
\CommentTok{/// ```}
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{add_two(a: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{a + }\DecValTok{2}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{tests \{}
    \KeywordTok{use} \KeywordTok{super}\NormalTok{::*;}

    \AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
    \KeywordTok{fn} \NormalTok{it_works() \{}
        \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the module-level documentation with \texttt{//!} and the
function-level documentation with \texttt{///}. Rust's documentation
supports Markdown in comments, and so triple graves mark code blocks. It
is conventional to include the \texttt{\#\ Examples} section, exactly
like that, with examples following.

Let's run the tests again:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/steve/tmp/adder)}
     \KeywordTok{Running} \NormalTok{target/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{tests::it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

     \KeywordTok{Running} \NormalTok{target/lib-c18e7d3494509e74}

\KeywordTok{running} \NormalTok{1 test}
\KeywordTok{test} \NormalTok{it_works ... ok}

\KeywordTok{test} \NormalTok{result: ok. 1 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}

   \KeywordTok{Doc-tests} \NormalTok{adder}

\KeywordTok{running} \NormalTok{2 tests}
\KeywordTok{test} \NormalTok{add_two_0 ... ok}
\KeywordTok{test} \NormalTok{_0 ... ok}

\KeywordTok{test} \NormalTok{result: ok. 2 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{0} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{0} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

Now we have all three kinds of tests running! Note the names of the
documentation tests: the \texttt{\_0} is generated for the module test,
and \texttt{add\_two\_0} for the function test. These will auto
increment with names like \texttt{add\_two\_1} as you add more examples.

\section{Conditional Compilation}\label{sec--conditional-compilation}

Rust has a special attribute, \texttt{\#{[}cfg{]}}, which allows you to
compile code based on a flag passed to the compiler. It has two forms:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{foo}\AttributeTok{)]}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{bar }\AttributeTok{=} \StringTok{"baz"}\AttributeTok{)]}
\end{Highlighting}
\end{Shaded}

They also have some helpers:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{any}\AttributeTok{(}\NormalTok{unix}\AttributeTok{,} \NormalTok{windows}\AttributeTok{))]}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{all}\AttributeTok{(}\NormalTok{unix}\AttributeTok{,} \NormalTok{target_pointer_width }\AttributeTok{=} \StringTok{"32"}\AttributeTok{))]}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{not}\AttributeTok{(}\NormalTok{foo}\AttributeTok{))]}
\end{Highlighting}
\end{Shaded}

These can nest arbitrarily:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{any}\AttributeTok{(}\NormalTok{not}\AttributeTok{(}\NormalTok{unix}\AttributeTok{),} \NormalTok{all}\AttributeTok{(}\NormalTok{target_os}\AttributeTok{=}\StringTok{"macos"}\AttributeTok{,} \NormalTok{target_arch }\AttributeTok{=} \StringTok{"powerpc"}\AttributeTok{)))]}
\end{Highlighting}
\end{Shaded}

As for how to enable or disable these switches, if you're using Cargo,
they get set in the
\href{http://doc.crates.io/manifest.html\#the-\%5Bfeatures\%5D-section}{\texttt{{[}features{]}}
section} of your \texttt{Cargo.toml}:

\begin{verbatim}
[features]
# no features by default
default = []

# The ‚Äúsecure-password‚Äù feature depends on the bcrypt package.
secure-password = ["bcrypt"]
\end{verbatim}

When you do this, Cargo passes along a flag to \texttt{rustc}:

\begin{verbatim}
--cfg feature="${feature_name}"
\end{verbatim}

The sum of these \texttt{cfg} flags will determine which ones get
activated, and therefore, which code gets compiled. Let's take this
code:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{feature }\AttributeTok{=} \StringTok{"foo"}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{foo \{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we compile it with \texttt{cargo\ build\ -\/-features\ "foo"}, it
will send the \texttt{-\/-cfg\ feature="foo"} flag to \texttt{rustc},
and the output will have the \texttt{mod\ foo} in it. If we compile it
with a regular \texttt{cargo\ build}, no extra flags get passed on, and
so, no \texttt{foo} module will exist.

\subsection{cfg\_attr}\label{cfgux5fattr}

You can also set another attribute based on a \texttt{cfg} variable with
\texttt{cfg\_attr}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg_attr}\AttributeTok{(}\NormalTok{a}\AttributeTok{,} \NormalTok{b}\AttributeTok{)]}
\end{Highlighting}
\end{Shaded}

Will be the same as \texttt{\#{[}b{]}} if \texttt{a} is set by
\texttt{cfg} attribute, and nothing otherwise.

\subsection{cfg!}\label{cfg}

The \texttt{cfg!} \hyperref[sec--compiler-plugins]{syntax extension}
lets you use these kinds of flags elsewhere in your code, too:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \PreprocessorTok{cfg!}\NormalTok{(target_os = }\StringTok{"macos"}\NormalTok{) || }\PreprocessorTok{cfg!}\NormalTok{(target_os = }\StringTok{"ios"}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Think Different!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

These will be replaced by a \texttt{true} or \texttt{false} at
compile-time, depending on the configuration settings.

\hyperdef{}{sec--documentation}{\section{Documentation}\label{sec--documentation}}

Documentation is an important part of any software project, and it's
first-class in Rust. Let's talk about the tooling Rust gives you to
document your project.

\subsubsection{\texorpdfstring{About
\texttt{rustdoc}}{About rustdoc}}\label{about-rustdoc}

The Rust distribution includes a tool, \texttt{rustdoc}, that generates
documentation. \texttt{rustdoc} is also used by Cargo through
\texttt{cargo\ doc}.

Documentation can be generated in two ways: from source code, and from
standalone Markdown files.

\subsubsection{Documenting source code}\label{documenting-source-code}

The primary way of documenting a Rust project is through annotating the
source code. You can use documentation comments for this purpose:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// Constructs a new `Rc<T>`.}
\CommentTok{///}
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// use std::rc::Rc;}
\CommentTok{///}
\CommentTok{/// let five = Rc::new(5);}
\CommentTok{/// ```}
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{new(value: T) -> Rc<T> \{}
    \CommentTok{// implementation goes here}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code generates documentation that looks
\href{https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html\#method.new}{like
this}. I've left the implementation out, with a regular comment in its
place.

The first thing to notice about this annotation is that it uses
\texttt{///} instead of \texttt{//}. The triple slash indicates a
documentation comment.

Documentation comments are written in Markdown.

Rust keeps track of these comments, and uses them when generating
documentation. This is important when documenting things like enums:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// The `Option` type. See [the module level documentation](../) for more.}
\KeywordTok{enum} \DataTypeTok{Option}\NormalTok{<T> \{}
    \CommentTok{/// No value}
    \ConstantTok{None}\NormalTok{,}
    \CommentTok{/// Some value `T`}
    \ConstantTok{Some}\NormalTok{(T),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above works, but this does not:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// The `Option` type. See [the module level documentation](../) for more.}
\KeywordTok{enum} \DataTypeTok{Option}\NormalTok{<T> \{}
    \ConstantTok{None}\NormalTok{, }\CommentTok{/// No value}
    \ConstantTok{Some}\NormalTok{(T), }\CommentTok{/// Some value `T`}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You'll get an error:

\begin{verbatim}
hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
\end{verbatim}

This \href{https://github.com/rust-lang/rust/issues/22547}{unfortunate
error} is correct: documentation comments apply to the thing after them,
and there's nothing after that last comment.

\paragraph{Writing documentation
comments}\label{writing-documentation-comments}

Anyway, let's cover each part of this comment in detail:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// Constructs a new `Rc<T>`.}
\end{Highlighting}
\end{Shaded}

The first line of a documentation comment should be a short summary of
its functionality. One sentence. Just the basics. High level.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{///}
\CommentTok{/// Other details about constructing `Rc<T>`s, maybe describing complicated}
\CommentTok{/// semantics, maybe additional options, all kinds of stuff.}
\CommentTok{///}
\end{Highlighting}
\end{Shaded}

Our original example had just a summary line, but if we had more things
to say, we could have added more explanation in a new paragraph.

\subparagraph{Special sections}\label{special-sections}

Next, are special sections. These are indicated with a header,
\texttt{\#}. There are four kinds of headers that are commonly used.
They aren't special syntax, just convention, for now.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Panics}
\end{Highlighting}
\end{Shaded}

Unrecoverable misuses of a function (i.e.~programming errors) in Rust
are usually indicated by panics, which kill the whole current thread at
the very least. If your function has a non-trivial contract like this,
that is detected/enforced by panics, documenting it is very important.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Failures}
\end{Highlighting}
\end{Shaded}

If your function or method returns a
\texttt{Result\textless{}T,\ E\textgreater{}}, then describing the
conditions under which it returns \texttt{Err(E)} is a nice thing to do.
This is slightly less important than \texttt{Panics}, because failure is
encoded into the type system, but it's still a good thing to do.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Safety}
\end{Highlighting}
\end{Shaded}

If your function is \texttt{unsafe}, you should explain which invariants
the caller is responsible for upholding.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// use std::rc::Rc;}
\CommentTok{///}
\CommentTok{/// let five = Rc::new(5);}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

Fourth, \texttt{Examples}. Include one or more examples of using your
function or method, and your users will love you for it. These examples
go inside of code block annotations, which we'll talk about in a moment,
and can have more than one section:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// Simple `&str` patterns:}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// let v: Vec<&str> = "Mary had a little lamb".split(' ').collect();}
\CommentTok{/// assert_eq!(v, vec!["Mary", "had", "a", "little", "lamb"]);}
\CommentTok{/// ```}
\CommentTok{///}
\CommentTok{/// More complex patterns with a lambda:}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// let v: Vec<&str> = "abc1def2ghi".split(|c: char| c.is_numeric()).collect();}
\CommentTok{/// assert_eq!(v, vec!["abc", "def", "ghi"]);}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

Let's discuss the details of these code blocks.

\subparagraph{Code block annotations}\label{code-block-annotations}

To write some Rust code in a comment, use the triple graves:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```}
\CommentTok{/// println!("Hello, world");}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

If you want something that's not Rust code, you can add an annotation:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```c}
\CommentTok{/// printf("Hello, world\textbackslash{}n");}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

This will highlight according to whatever language you're showing off.
If you're just showing plain text, choose \texttt{text}.

It's important to choose the correct annotation here, because
\texttt{rustdoc} uses it in an interesting way: It can be used to
actually test your examples in a library crate, so that they don't get
out of date. If you have some C code but \texttt{rustdoc} thinks it's
Rust because you left off the annotation, \texttt{rustdoc} will complain
when trying to generate the documentation.

\subsubsection{Documentation as tests}\label{documentation-as-tests}

Let's discuss our sample example documentation:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```}
\CommentTok{/// println!("Hello, world");}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

You'll notice that you don't need a \texttt{fn\ main()} or anything
here. \texttt{rustdoc} will automatically add a main() wrapper around
your code, and in the right place. For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```}
\CommentTok{/// use std::rc::Rc;}
\CommentTok{///}
\CommentTok{/// let five = Rc::new(5);}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

This will end up testing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{use} \NormalTok{std::rc::Rc;}
    \KeywordTok{let} \NormalTok{five = Rc::new(}\DecValTok{5}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here's the full algorithm rustdoc uses to postprocess examples:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Any leading \texttt{\#!{[}foo{]}} attributes are left intact as crate
  attributes.
\item
  Some common \texttt{allow} attributes are inserted, including
  \texttt{unused\_variables}, \texttt{unused\_assignments},
  \texttt{unused\_mut}, \texttt{unused\_attributes}, and
  \texttt{dead\_code}. Small examples often trigger these lints.
\item
  If the example does not contain \texttt{extern\ crate}, then
  \texttt{extern\ crate\ \ \ \ \textless{}mycrate\textgreater{};} is
  inserted.
\item
  Finally, if the example does not contain \texttt{fn\ main}, the
  remainder of the text is wrapped in
  \texttt{fn\ main()\ \{\ your\_code\ \}}
\end{enumerate}

Sometimes, this isn't enough, though. For example, all of these code
samples with \texttt{///} we've been talking about? The raw text:

\begin{verbatim}
/// Some documentation.
# fn foo() {}
\end{verbatim}

looks different than the output:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// Some documentation.}
\end{Highlighting}
\end{Shaded}

Yes, that's right: you can add lines that start with \texttt{\#}, and
they will be hidden from the output, but will be used when compiling
your code. You can use this to your advantage. In this case,
documentation comments need to apply to some kind of function, so if I
want to show you just a documentation comment, I need to add a little
function definition below it. At the same time, it's just there to
satisfy the compiler, so hiding it makes the example more clear. You can
use this technique to explain longer examples in detail, while still
preserving the testability of your documentation. For example, this
code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = }\DecValTok{6}\NormalTok{;}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x + y);}
\end{Highlighting}
\end{Shaded}

Here's an explanation, rendered:

First, we set \texttt{x} to five:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Next, we set \texttt{y} to six:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{y = }\DecValTok{6}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Finally, we print the sum of \texttt{x} and \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x + y);}
\end{Highlighting}
\end{Shaded}

Here's the same explanation, in raw text:

\begin{quote}
First, we set \texttt{x} to five:

\begin{verbatim}
let x = 5;
# let y = 6;
# println!("{}", x + y);
\end{verbatim}

Next, we set \texttt{y} to six:

\begin{verbatim}
# let x = 5;
let y = 6;
# println!("{}", x + y);
\end{verbatim}

Finally, we print the sum of \texttt{x} and \texttt{y}:

\begin{verbatim}
# let x = 5;
# let y = 6;
println!("{}", x + y);
\end{verbatim}
\end{quote}

By repeating all parts of the example, you can ensure that your example
still compiles, while only showing the parts that are relevant to that
part of your explanation.

\paragraph{Documenting macros}\label{documenting-macros}

Here's an example of documenting a macro:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// Panic with a given message unless an expression evaluates to true.}
\CommentTok{///}
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// # #[macro_use] extern crate foo;}
\CommentTok{/// # fn main() \{}
\CommentTok{/// panic_unless!(1 + 1 == 2, ‚ÄúMath is broken.‚Äù);}
\CommentTok{/// # \}}
\CommentTok{/// ```}
\CommentTok{///}
\CommentTok{/// ```should_panic}
\CommentTok{/// # #[macro_use] extern crate foo;}
\CommentTok{/// # fn main() \{}
\CommentTok{/// panic_unless!(true == false, ‚ÄúI‚Äôm broken.‚Äù);}
\CommentTok{/// # \}}
\CommentTok{/// ```}
\AttributeTok{#[}\NormalTok{macro_export}\AttributeTok{]}
\PreprocessorTok{macro_rules!} \NormalTok{panic_unless \{}
    \NormalTok{($condition:expr, $($rest:expr),+) => (\{ }\KeywordTok{if} \NormalTok{! $condition \{ }\PreprocessorTok{panic!}\NormalTok{($($rest),+); \} \}}
\NormalTok{‚Ü≥ );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You'll note three things: we need to add our own \texttt{extern\ crate}
line, so that we can add the \texttt{\#{[}macro\_use{]}} attribute.
Second, we'll need to add our own \texttt{main()} as well. Finally, a
judicious use of \texttt{\#} to comment out those two things, so they
don't show up in the output.

\paragraph{Running documentation
tests}\label{running-documentation-tests}

To run the tests, either

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{rustdoc} \NormalTok{--test path/to/my/crate/root.rs}
\CommentTok{# or}
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{test}
\end{Highlighting}
\end{Shaded}

That's right, \texttt{cargo\ test} tests embedded documentation too.
\textbf{However, \texttt{cargo\ test} will not test binary crates, only
library ones.} This is due to the way \texttt{rustdoc} works: it links
against the library to be tested, but with a binary, there's nothing to
link to.

There are a few more annotations that are useful to help
\texttt{rustdoc} do the right thing when testing your code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```ignore}
\CommentTok{/// fn foo() \{}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

The \texttt{ignore} directive tells Rust to ignore your code. This is
almost never what you want, as it's the most generic. Instead, consider
annotating it with \texttt{text} if it's not code, or using \texttt{\#}s
to get a working example that only shows the part you care about.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```should_panic}
\CommentTok{/// assert!(false);}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

\texttt{should\_panic} tells \texttt{rustdoc} that the code should
compile correctly, but not actually pass as a test.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// ```no_run}
\CommentTok{/// loop \{}
\CommentTok{///     println!("Hello, world");}
\CommentTok{/// \}}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

The \texttt{no\_run} attribute will compile your code, but not run it.
This is important for examples such as ``Here's how to start up a
network service,'' which you would want to make sure compile, but might
run in an infinite loop!

\paragraph{Documenting modules}\label{documenting-modules}

Rust has another kind of doc comment, \texttt{//!}. This comment doesn't
document the next item, but the enclosing item. In other words:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{foo \{}
    \CommentTok{//! This is documentation for the `foo` module.}
    \CommentTok{//!}
    \CommentTok{//! # Examples}

    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is where you'll see \texttt{//!} used most often: for module
documentation. If you have a module in \texttt{foo.rs}, you'll often
open its code and see this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//! A module for using `foo`s.}
\CommentTok{//!}
\CommentTok{//! The `foo` module contains a lot of useful functionality blah blah blah}
\end{Highlighting}
\end{Shaded}

\paragraph{Documentation comment
style}\label{documentation-comment-style}

Check out
\href{https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md}{RFC
505} for full conventions around the style and format of documentation.

\subsubsection{Other documentation}\label{other-documentation}

All of this behavior works in non-Rust source files too. Because
comments are written in Markdown, they're often \texttt{.md} files.

When you write documentation in Markdown files, you don't need to prefix
the documentation with comments. For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// use std::rc::Rc;}
\CommentTok{///}
\CommentTok{/// let five = Rc::new(5);}
\CommentTok{/// ```}
\end{Highlighting}
\end{Shaded}

is just

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{### Examples}

\NormalTok{```}
\NormalTok{use std::rc::Rc;}

\NormalTok{let five = Rc::new(5);}
\NormalTok{```}
\end{Highlighting}
\end{Shaded}

when it's in a Markdown file. There is one wrinkle though: Markdown
files need to have a title like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{% The title}

\NormalTok{This is the example documentation.}
\end{Highlighting}
\end{Shaded}

This \texttt{\%} line needs to be the very first line of the file.

\subsubsection{\texorpdfstring{\texttt{doc}
attributes}{doc attributes}}\label{doc-attributes}

At a deeper level, documentation comments are sugar for documentation
attributes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// this}

\AttributeTok{#[}\NormalTok{doc}\AttributeTok{=}\StringTok{"this"}\AttributeTok{]}
\end{Highlighting}
\end{Shaded}

are the same, as are these:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//! this}

\AttributeTok{#![}\NormalTok{doc}\AttributeTok{=}\StringTok{"/// this"}\AttributeTok{]}
\end{Highlighting}
\end{Shaded}

You won't often see this attribute used for writing documentation, but
it can be useful when changing some options, or when writing a macro.

\paragraph{Re-exports}\label{re-exports}

\texttt{rustdoc} will show the documentation for a public re-export in
both places:

\begin{verbatim}
extern crate foo;

pub use foo::bar;
\end{verbatim}

This will create documentation for bar both inside the documentation for
the crate \texttt{foo}, as well as the documentation for your crate. It
will use the same documentation in both places.

This behavior can be suppressed with \texttt{no\_inline}:

\begin{verbatim}
extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
\end{verbatim}

\paragraph{Controlling HTML}\label{controlling-html}

You can control a few aspects of the HTML that \texttt{rustdoc}
generates through the \texttt{\#!{[}doc{]}} version of the attribute:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{doc}\AttributeTok{(}\NormalTok{html_logo_url }\AttributeTok{=} \StringTok{"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png"}\AttributeTok{,}
       \NormalTok{html_favicon_url }\AttributeTok{=} \StringTok{"https://www.rust-lang.org/favicon.ico"}\AttributeTok{,}
       \NormalTok{html_root_url }\AttributeTok{=} \StringTok{"https://doc.rust-lang.org/"}\AttributeTok{)]}
\end{Highlighting}
\end{Shaded}

This sets a few different options, with a logo, favicon, and a root URL.

\subsubsection{Generation options}\label{generation-options}

\texttt{rustdoc} also contains a few other options on the command line,
for further customization:

\begin{itemize}
\tightlist
\item
  \texttt{-\/-html-in-header\ FILE}: includes the contents of FILE at
  the end of the
  \texttt{\textless{}head\textgreater{}...\textless{}/head\textgreater{}}
  section.
\item
  \texttt{-\/-html-before-content\ FILE}: includes the contents of FILE
  directly after \texttt{\textless{}body\textgreater{}}, before the
  rendered content (including the search bar).
\item
  \texttt{-\/-html-after-content\ FILE}: includes the contents of FILE
  after all the rendered content.
\end{itemize}

\subsubsection{Security note}\label{security-note}

The Markdown in documentation comments is placed without processing into
the final webpage. Be careful with literal HTML:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// <script>alert(document.cookie)</script>}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--iterators}{\section{Iterators}\label{sec--iterators}}

Let's talk about loops.

Remember Rust's \texttt{for} loop? Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{x }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now that you know more Rust, we can talk in detail about how this works.
Ranges (the \texttt{0..10}) are `iterators'. An iterator is something
that we can call the \texttt{.next()} method on repeatedly, and it gives
us a sequence of things.

Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{range = }\DecValTok{0.}\NormalTok{.}\DecValTok{10}\NormalTok{;}

\KeywordTok{loop} \NormalTok{\{}
    \KeywordTok{match} \NormalTok{range.next() \{}
        \ConstantTok{Some}\NormalTok{(x) => \{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
        \NormalTok{\},}
        \ConstantTok{None} \NormalTok{=> \{ }\KeywordTok{break} \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We make a mutable binding to the range, which is our iterator. We then
\texttt{loop}, with an inner \texttt{match}. This \texttt{match} is used
on the result of \texttt{range.next()}, which gives us a reference to
the next value of the iterator. \texttt{next} returns an
\texttt{Option\textless{}i32\textgreater{}}, in this case, which will be
\texttt{Some(i32)} when we have a value and \texttt{None} once we run
out. If we get \texttt{Some(i32)}, we print it out, and if we get
\texttt{None}, we \texttt{break} out of the loop.

This code sample is basically the same as our \texttt{for} loop version.
The \texttt{for} loop is just a handy way to write this
\texttt{loop}/\texttt{match}/\texttt{break} construct.

\texttt{for} loops aren't the only thing that uses iterators, however.
Writing your own iterator involves implementing the \texttt{Iterator}
trait. While doing that is outside of the scope of this guide, Rust
provides a number of useful iterators to accomplish various tasks.
Before we talk about those, we should talk about a Rust anti-pattern.
And that's using ranges like this.

Yes, we just talked about how ranges are cool. But ranges are also very
primitive. For example, if you needed to iterate over the contents of a
vector, you may be tempted to write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \DecValTok{0.}\NormalTok{.nums.len() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, nums[i]);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is strictly worse than using an actual iterator. You can iterate
over vectors directly, so write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{num }\KeywordTok{in} \NormalTok{&nums \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, num);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are two reasons for this. First, this more directly expresses what
we mean. We iterate through the entire vector, rather than iterating
through indexes, and then indexing the vector. Second, this version is
more efficient: the first version will have extra bounds checking
because it used indexing, \texttt{nums{[}i{]}}. But since we yield a
reference to each element of the vector in turn with the iterator,
there's no bounds checking in the second example. This is very common
with iterators: we can ignore unnecessary bounds checks, but still know
that we're safe.

There's another detail here that's not 100\% clear because of how
\texttt{println!} works. \texttt{num} is actually of type
\texttt{\&i32}. That is, it's a reference to an \texttt{i32}, not an
\texttt{i32} itself. \texttt{println!} handles the dereferencing for us,
so we don't see it. This code works fine too:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{num }\KeywordTok{in} \NormalTok{&nums \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, *num);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we're explicitly dereferencing \texttt{num}. Why does
\texttt{\&nums} give us references? Firstly, because we explicitly asked
it to with \texttt{\&}. Secondly, if it gave us the data itself, we
would have to be its owner, which would involve making a copy of the
data and giving us the copy. With references, we're just borrowing a
reference to the data, and so it's just passing a reference, without
needing to do the move.

So, now that we've established that ranges are often not what you want,
let's talk about what you do want instead.

There are three broad classes of things that are relevant here:
iterators, \emph{iterator adapters}, and \emph{consumers}. Here's some
definitions:

\begin{itemize}
\tightlist
\item
  \emph{iterators} give you a sequence of values.
\item
  \emph{iterator adapters} operate on an iterator, producing a new
  iterator with a different output sequence.
\item
  \emph{consumers} operate on an iterator, producing some final set of
  values.
\end{itemize}

Let's talk about consumers first, since you've already seen an iterator,
ranges.

\subsubsection{Consumers}\label{consumers}

A \emph{consumer} operates on an iterator, returning some kind of value
or values. The most common consumer is \texttt{collect()}. This code
doesn't quite compile, but it shows the intention:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{one_to_one_hundred = (}\DecValTok{1.}\NormalTok{.}\DecValTok{101}\NormalTok{).collect();}
\end{Highlighting}
\end{Shaded}

As you can see, we call \texttt{collect()} on our iterator.
\texttt{collect()} takes as many values as the iterator will give it,
and returns a collection of the results. So why won't this compile? Rust
can't determine what type of things you want to collect, and so you need
to let it know. Here's the version that does compile:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{one_to_one_hundred = (}\DecValTok{1.}\NormalTok{.}\DecValTok{101}\NormalTok{).collect::<}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>>();}
\end{Highlighting}
\end{Shaded}

If you remember, the \texttt{::\textless{}\textgreater{}} syntax allows
us to give a type hint, and so we tell it that we want a vector of
integers. You don't always need to use the whole type, though. Using a
\texttt{\_} will let you provide a partial hint:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{one_to_one_hundred = (}\DecValTok{1.}\NormalTok{.}\DecValTok{101}\NormalTok{).collect::<}\DataTypeTok{Vec}\NormalTok{<_>>();}
\end{Highlighting}
\end{Shaded}

This says ``Collect into a \texttt{Vec\textless{}T\textgreater{}},
please, but infer what the \texttt{T} is for me.'' \texttt{\_} is
sometimes called a ``type placeholder'' for this reason.

\texttt{collect()} is the most common consumer, but there are others
too. \texttt{find()} is one:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{greater_than_forty_two = (}\DecValTok{0.}\NormalTok{.}\DecValTok{100}\NormalTok{)}
                             \NormalTok{.find(|x| *x > }\DecValTok{42}\NormalTok{);}

\KeywordTok{match} \NormalTok{greater_than_forty_two \{}
    \ConstantTok{Some}\NormalTok{(_) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"We got some numbers!"}\NormalTok{),}
    \ConstantTok{None} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"No numbers found :("}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{find} takes a closure, and works on a reference to each element
of an iterator. This closure returns \texttt{true} if the element is the
element we're looking for, and \texttt{false} otherwise. Because we
might not find a matching element, \texttt{find} returns an
\texttt{Option} rather than the element itself.

Another important consumer is \texttt{fold}. Here's what it looks like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{sum = (}\DecValTok{1.}\NormalTok{.}\DecValTok{4}\NormalTok{).fold(}\DecValTok{0}\NormalTok{, |sum, x| sum + x);}
\end{Highlighting}
\end{Shaded}

\texttt{fold()} is a consumer that looks like this:
\texttt{fold(base,\ \textbar{}accumulator,\ element\textbar{}\ ...)}. It
takes two arguments: the first is an element called the \emph{base}. The
second is a closure that itself takes two arguments: the first is called
the \emph{accumulator}, and the second is an \emph{element}. Upon each
iteration, the closure is called, and the result is the value of the
accumulator on the next iteration. On the first iteration, the base is
the value of the accumulator.

Okay, that's a bit confusing. Let's examine the values of all of these
things in this iterator:

\begin{longtable}[c]{@{}llll@{}}
\toprule
base & accumulator & element & closure result\tabularnewline
\midrule
\endhead
0 & 0 & 1 & 1\tabularnewline
0 & 1 & 2 & 3\tabularnewline
0 & 3 & 3 & 6\tabularnewline
\bottomrule
\end{longtable}

We called \texttt{fold()} with these arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.fold(}\DecValTok{0}\NormalTok{, |sum, x| sum + x);}
\end{Highlighting}
\end{Shaded}

So, \texttt{0} is our base, \texttt{sum} is our accumulator, and
\texttt{x} is our element. On the first iteration, we set \texttt{sum}
to \texttt{0}, and \texttt{x} is the first element of \texttt{nums},
\texttt{1}. We then add \texttt{sum} and \texttt{x}, which gives us
\texttt{0\ +\ 1\ =\ 1}. On the second iteration, that value becomes our
accumulator, \texttt{sum}, and the element is the second element of the
array, \texttt{2}. \texttt{1\ +\ 2\ =\ 3}, and so that becomes the value
of the accumulator for the last iteration. On that iteration, \texttt{x}
is the last element, \texttt{3}, and \texttt{3\ +\ 3\ =\ 6}, which is
our final result for our sum. \texttt{1\ +\ 2\ +\ 3\ =\ 6}, and that's
the result we got.

Whew. \texttt{fold} can be a bit strange the first few times you see it,
but once it clicks, you can use it all over the place. Any time you have
a list of things, and you want a single result, \texttt{fold} is
appropriate.

Consumers are important due to one additional property of iterators we
haven't talked about yet: laziness. Let's talk some more about
iterators, and you'll see why consumers matter.

\subsubsection{Iterators}\label{iterators}

As we've said before, an iterator is something that we can call the
\texttt{.next()} method on repeatedly, and it gives us a sequence of
things. Because you need to call the method, this means that iterators
can be \emph{lazy} and not generate all of the values upfront. This
code, for example, does not actually generate the numbers \texttt{1-99},
instead creating a value that merely represents the sequence:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\DecValTok{1.}\NormalTok{.}\DecValTok{100}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Since we didn't do anything with the range, it didn't generate the
sequence. Let's add the consumer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = (}\DecValTok{1.}\NormalTok{.}\DecValTok{100}\NormalTok{).collect::<}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>>();}
\end{Highlighting}
\end{Shaded}

Now, \texttt{collect()} will require that the range gives it some
numbers, and so it will do the work of generating the sequence.

Ranges are one of two basic iterators that you'll see. The other is
\texttt{iter()}. \texttt{iter()} can turn a vector into a simple
iterator that gives you each element in turn:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{num }\KeywordTok{in} \NormalTok{nums.iter() \{}
   \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, num);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

These two basic iterators should serve you well. There are some more
advanced iterators, including ones that are infinite.

That's enough about iterators. Iterator adapters are the last concept we
need to talk about with regards to iterators. Let's get to it!

\subsubsection{Iterator adapters}\label{iterator-adapters}

\emph{Iterator adapters} take an iterator and modify it somehow,
producing a new iterator. The simplest one is called \texttt{map}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1.}\NormalTok{.}\DecValTok{100}\NormalTok{).map(|x| x + }\DecValTok{1}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{map} is called upon another iterator, and produces a new
iterator where each element reference has the closure it's been given as
an argument called on it. So this would give us the numbers from
\texttt{2-100}. Well, almost! If you compile the example, you'll get a
warning:

\begin{verbatim}
warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{verbatim}

Laziness strikes again! That closure will never execute. This example
doesn't print any numbers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1.}\NormalTok{.}\DecValTok{100}\NormalTok{).map(|x| }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x));}
\end{Highlighting}
\end{Shaded}

If you are trying to execute a closure on an iterator for its side
effects, just use \texttt{for} instead.

There are tons of interesting iterator adapters. \texttt{take(n)} will
return an iterator over the next \texttt{n} elements of the original
iterator. Note that this has no side effect on the original iterator.
Let's try it out with our infinite iterator from before:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{(}\DecValTok{1.}\NormalTok{.).take(}\DecValTok{5}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, i);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print

\begin{verbatim}
1
2
3
4
5
\end{verbatim}

\texttt{filter()} is an adapter that takes a closure as an argument.
This closure returns \texttt{true} or \texttt{false}. The new iterator
\texttt{filter()} produces only the elements that that closure returns
\texttt{true} for:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{(}\DecValTok{1.}\NormalTok{.}\DecValTok{100}\NormalTok{).filter(|&x| x % }\DecValTok{2} \NormalTok{== }\DecValTok{0}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, i);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print all of the even numbers between one and a hundred. (Note
that because \texttt{filter} doesn't consume the elements that are being
iterated over, it is passed a reference to each element, and thus the
filter predicate uses the \texttt{\&x} pattern to extract the integer
itself.)

You can chain all three things together: start with an iterator, adapt
it a few times, and then consume the result. Check it out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1.}\NormalTok{.)}
    \NormalTok{.filter(|&x| x % }\DecValTok{2} \NormalTok{== }\DecValTok{0}\NormalTok{)}
    \NormalTok{.filter(|&x| x % }\DecValTok{3} \NormalTok{== }\DecValTok{0}\NormalTok{)}
    \NormalTok{.take(}\DecValTok{5}\NormalTok{)}
    \NormalTok{.collect::<}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>>();}
\end{Highlighting}
\end{Shaded}

This will give you a vector containing \texttt{6}, \texttt{12},
\texttt{18}, \texttt{24}, and \texttt{30}.

This is just a small taste of what iterators, iterator adapters, and
consumers can help you with. There are a number of really useful
iterators, and you can write your own as well. Iterators provide a safe,
efficient way to manipulate all kinds of lists. They're a little unusual
at first, but if you play with them, you'll get hooked. For a full list
of the different iterators and consumers, check out the
\href{http://doc.rust-lang.org/std/iter/index.html}{iterator module
documentation}.

\hyperdef{}{sec--concurrency}{\section{Concurrency}\label{sec--concurrency}}

Concurrency and parallelism are incredibly important topics in computer
science, and are also a hot topic in industry today. Computers are
gaining more and more cores, yet many programmers aren't prepared to
fully utilize them.

Rust's memory safety features also apply to its concurrency story too.
Even concurrent Rust programs must be memory safe, having no data races.
Rust's type system is up to the task, and gives you powerful ways to
reason about concurrent code at compile time.

Before we talk about the concurrency features that come with Rust, it's
important to understand something: Rust is low-level enough that the
vast majority of this is provided by the standard library, not by the
language. This means that if you don't like some aspect of the way Rust
handles concurrency, you can implement an alternative way of doing
things. \href{https://github.com/carllerche/mio}{mio} is a real-world
example of this principle in action.

\subsubsection{\texorpdfstring{Background: \texttt{Send} and
\texttt{Sync}}{Background: Send and Sync}}\label{background-send-and-sync}

Concurrency is difficult to reason about. In Rust, we have a strong,
static type system to help us reason about our code. As such, Rust gives
us two traits to help us make sense of code that can possibly be
concurrent.

\paragraph{\texorpdfstring{\texttt{Send}}{Send}}\label{send}

The first trait we're going to talk about is
\href{http://doc.rust-lang.org/std/marker/trait.Send.html}{\texttt{Send}}.
When a type \texttt{T} implements \texttt{Send}, it indicates to the
compiler that something of this type is able to have ownership
transferred safely between threads.

This is important to enforce certain restrictions. For example, if we
have a channel connecting two threads, we would want to be able to send
some data down the channel and to the other thread. Therefore, we'd
ensure that \texttt{Send} was implemented for that type.

In the opposite way, if we were wrapping a library with FFI that isn't
threadsafe, we wouldn't want to implement \texttt{Send}, and so the
compiler will help us enforce that it can't leave the current thread.

\paragraph{\texorpdfstring{\texttt{Sync}}{Sync}}\label{sync}

The second of these traits is called
\href{http://doc.rust-lang.org/std/marker/trait.Sync.html}{\texttt{Sync}}.
When a type \texttt{T} implements \texttt{Sync}, it indicates to the
compiler that something of this type has no possibility of introducing
memory unsafety when used from multiple threads concurrently.

For example, sharing immutable data with an atomic reference count is
threadsafe. Rust provides a type like this,
\texttt{Arc\textless{}T\textgreater{}}, and it implements \texttt{Sync},
so it is safe to share between threads.

These two traits allow you to use the type system to make strong
guarantees about the properties of your code under concurrency. Before
we demonstrate why, we need to learn how to create a concurrent Rust
program in the first place!

\subsubsection{Threads}\label{threads}

Rust's standard library provides a library for threads, which allow you
to run Rust code in parallel. Here's a basic example of using
\texttt{std::thread}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{fn} \NormalTok{main() \{}
    \NormalTok{thread::spawn(|| \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello from a thread!"}\NormalTok{);}
    \NormalTok{\});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{thread::spawn()} method accepts a closure, which is executed
in a new thread. It returns a handle to the thread, that can be used to
wait for the child thread to finish and extract its result:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{handle = thread::spawn(|| \{}
        \StringTok{"Hello from a thread!"}
    \NormalTok{\});}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, handle.join().unwrap());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Many languages have the ability to execute threads, but it's wildly
unsafe. There are entire books about how to prevent errors that occur
from shared mutable state. Rust helps out with its type system here as
well, by preventing data races at compile time. Let's talk about how you
actually share things between threads.

\subsubsection{Safe Shared Mutable
State}\label{safe-shared-mutable-state}

Due to Rust's type system, we have a concept that sounds like a lie:
``safe shared mutable state.'' Many programmers agree that shared
mutable state is very, very bad.

Someone once said this:

\begin{quote}
Shared mutable state is the root of all evil. Most languages attempt to
deal with this problem through the `mutable' part, but Rust deals with
it by solving the `shared' part.
\end{quote}

The same \hyperref[sec--ownership]{ownership system} that helps prevent
using pointers incorrectly also helps rule out data races, one of the
worst kinds of concurrency bugs.

As an example, here is a Rust program that would have a data race in
many languages. It will not compile:

\begin{verbatim}
use std::thread;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
\end{verbatim}

This gives us an error:

\begin{verbatim}
8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
\end{verbatim}

Rust knows this wouldn't be safe! If we had a reference to \texttt{data}
in each thread, and the thread takes ownership of the reference, we'd
have three owners!

So, we need some type that lets us have more than one reference to a
value and that we can share between threads, that is it must implement
\texttt{Sync}.

We'll use \texttt{Arc\textless{}T\textgreater{}}, rust's standard atomic
reference count type, which wraps a value up with some extra runtime
bookkeeping which allows us to share the ownership of the value between
multiple references at the same time.

The bookkeeping consists of a count of how many of these references
exist to the value, hence the reference count part of the name.

The Atomic part means \texttt{Arc\textless{}T\textgreater{}} can safely
be accessed from multiple threads. To do this the compiler guarantees
that mutations of the internal count use indivisible operations which
can't have data races.

\begin{verbatim}
use std::thread;
use std::sync::Arc;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
\end{verbatim}

We now call \texttt{clone()} on our
\texttt{Arc\textless{}T\textgreater{}}, which increases the internal
count. This handle is then moved into the new thread.

And\ldots{} still gives us an error.

\begin{verbatim}
<anon>:11:24 error: cannot borrow immutable borrowed content as mutable
<anon>:11                    data[i] += 1;
                             ^~~~
\end{verbatim}

\texttt{Arc\textless{}T\textgreater{}} assumes one more property about
its contents to ensure that it is safe to share across threads: it
assumes its contents are \texttt{Sync}. This is true for our value if
it's immutable, but we want to be able to mutate it, so we need
something else to persuade the borrow checker we know what we're doing.

It looks like we need some type that allows us to safely mutate a shared
value, for example a type that that can ensure only one thread at a time
is able to mutate the value inside it at any one time.

For that, we can use the \texttt{Mutex\textless{}T\textgreater{}} type!

Here's the working version:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::sync::\{Arc, Mutex\};}
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{data = Arc::new(Mutex::new(}\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]));}

    \KeywordTok{for} \NormalTok{i }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{3} \NormalTok{\{}
        \KeywordTok{let} \NormalTok{data = data.clone();}
        \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
            \KeywordTok{let} \KeywordTok{mut} \NormalTok{data = data.lock().unwrap();}
            \NormalTok{data[i] += }\DecValTok{1}\NormalTok{;}
        \NormalTok{\});}
    \NormalTok{\}}

    \NormalTok{thread::sleep_ms(}\DecValTok{50}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we'd tried to use \texttt{Mutex\textless{}T\textgreater{}} without
wrapping it in an \texttt{Arc\textless{}T\textgreater{}} we would have
seen another error like:

\begin{verbatim}
error: the trait `core::marker::Send` is not implemented for the type `std::sync::mute
‚Ü≥ x::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]
 thread::spawn(move || {
                  ^~~~~~~~~~~~~
note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent be
‚Ü≥ tween threads safely
 thread::spawn(move || {
                  ^~~~~~~~~~~~~
\end{verbatim}

You see,
\href{http://doc.rust-lang.org/std/sync/struct.Mutex.html}{\texttt{Mutex}}
has a
\href{http://doc.rust-lang.org/std/sync/struct.Mutex.html\#method.lock}{\texttt{lock}}
method which has this signature:

\begin{verbatim}
fn lock(&self) -> LockResult<MutexGuard<T>>
\end{verbatim}

and because \texttt{Send} is not implemented for
\texttt{MutexGuard\textless{}T\textgreater{}}, we couldn't have
transferred the guard across thread boundaries on it's own.

Let's examine the body of the thread more closely:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{data = data.lock().unwrap();}
    \NormalTok{data[i] += }\DecValTok{1}\NormalTok{;}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

First, we call \texttt{lock()}, which acquires the mutex's lock. Because
this may fail, it returns an
\texttt{Result\textless{}T,\ E\textgreater{}}, and because this is just
an example, we \texttt{unwrap()} it to get a reference to the data. Real
code would have more robust error handling here. We're then free to
mutate it, since we have the lock.

Lastly, while the threads are running, we wait on a short timer. But
this is not ideal: we may have picked a reasonable amount of time to
wait but it's more likely we'll either be waiting longer than necessary
or not long enough, depending on just how much time the threads actually
take to finish computing when the program runs.

A more precise alternative to the timer would be to use one of the
mechanisms provided by the Rust standard library for synchronizing
threads with each other. Let's talk about one of them: channels.

\subsubsection{Channels}\label{channels}

Here's a version of our code that uses channels for synchronization,
rather than waiting for a specific time:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::sync::\{Arc, Mutex\};}
\KeywordTok{use} \NormalTok{std::thread;}
\KeywordTok{use} \NormalTok{std::sync::mpsc;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{data = Arc::new(Mutex::new(}\DecValTok{0}\NormalTok{));}

    \KeywordTok{let} \NormalTok{(tx, rx) = mpsc::channel();}

    \KeywordTok{for} \NormalTok{_ }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
        \KeywordTok{let} \NormalTok{(data, tx) = (data.clone(), tx.clone());}

        \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
            \KeywordTok{let} \KeywordTok{mut} \NormalTok{data = data.lock().unwrap();}
            \NormalTok{*data += }\DecValTok{1}\NormalTok{;}

            \NormalTok{tx.send(());}
        \NormalTok{\});}
    \NormalTok{\}}

    \KeywordTok{for} \NormalTok{_ }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
        \NormalTok{rx.recv();}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We use the \texttt{mpsc::channel()} method to construct a new channel.
We just \texttt{send} a simple \texttt{()} down the channel, and then
wait for ten of them to come back.

While this channel is just sending a generic signal, we can send any
data that is \texttt{Send} over the channel!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}
\KeywordTok{use} \NormalTok{std::sync::mpsc;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{(tx, rx) = mpsc::channel();}

    \KeywordTok{for} \NormalTok{_ }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
        \KeywordTok{let} \NormalTok{tx = tx.clone();}

        \NormalTok{thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
            \KeywordTok{let} \NormalTok{answer = }\DecValTok{42}\NormalTok{;}

            \NormalTok{tx.send(answer);}
        \NormalTok{\});}
    \NormalTok{\}}

   \NormalTok{rx.recv().ok().expect(}\StringTok{"Could not receive answer"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A \texttt{u32} is \texttt{Send} because we can make a copy. So we create
a thread, ask it to calculate the answer, and then it \texttt{send()}s
us the answer over the channel.

\subsubsection{Panics}\label{panics}

A \texttt{panic!} will crash the currently executing thread. You can use
Rust's threads as a simple isolation mechanism:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\KeywordTok{let} \NormalTok{handle = thread::spawn(}\KeywordTok{move} \NormalTok{|| \{}
    \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"oops!"}\NormalTok{);}
\NormalTok{\});}

\KeywordTok{let} \NormalTok{result = handle.join();}

\PreprocessorTok{assert!}\NormalTok{(result.is_err());}
\end{Highlighting}
\end{Shaded}

\texttt{Thread.join()} gives us a \texttt{Result} back, which allows us
to check if the thread has panicked or not.

\hyperdef{}{sec--error-handling}{\section{Error
Handling}\label{sec--error-handling}}

Like most programming languages, Rust encourages the programmer to
handle errors in a particular way. Generally speaking, error handling is
divided into two broad categories: exceptions and return values. Rust
opts for return values.

In this chapter, we intend to provide a comprehensive treatment of how
to deal with errors in Rust. More than that, we will attempt to
introduce error handling one piece at a time so that you'll come away
with a solid working knowledge of how everything fits together.

When done na√Øvely, error handling in Rust can be verbose and annoying.
This chapter will explore those stumbling blocks and demonstrate how to
use the standard library to make error handling concise and ergonomic.

\subsection{Table of Contents}\label{table-of-contents}

This chapter is very long, mostly because we start at the very beginning
with sum types and combinators, and try to motivate the way Rust does
error handling incrementally. As such, programmers with experience in
other expressive type systems may want to jump around.

\begin{itemize}
\tightlist
\item
  \hyperref[the-basics]{The Basics}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[unwrapping-explained]{Unwrapping explained}
  \item
    \hyperref[the-option-type]{The \texttt{Option} type}

    \begin{itemize}
    \tightlist
    \item
      \hyperref[composing-optiont-values]{Composing
      \texttt{Option\textless{}T\textgreater{}} values}
    \end{itemize}
  \item
    \hyperref[the-result-type]{The \texttt{Result} type}

    \begin{itemize}
    \tightlist
    \item
      \hyperref[parsing-integers]{Parsing integers}
    \item
      \hyperref[the-result-type-alias-idiom]{The \texttt{Result} type
      alias idiom}
    \end{itemize}
  \item
    \hyperref[a-brief-interlude-unwrapping-isnt-evil]{A brief interlude:
    unwrapping isn't evil}
  \end{itemize}
\item
  \hyperref[working-with-multiple-error-types]{Working with multiple
  error types}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[composing-option-and-result]{Composing \texttt{Option} and
    \texttt{Result}}
  \item
    \hyperref[the-limits-of-combinators]{The limits of combinators}
  \item
    \hyperref[early-returns]{Early returns}
  \item
    \hyperref[the-try-macro]{The \texttt{try!} macro}
  \item
    \hyperref[defining-your-own-error-type]{Defining your own error
    type}
  \end{itemize}
\item
  \hyperref[standard-library-traits-used-for-error-handling]{Standard
  library traits used for error handling}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[the-error-trait]{The \texttt{Error} trait}
  \item
    \hyperref[the-from-trait]{The \texttt{From} trait}
  \item
    \hyperref[the-real-try-macro]{The real \texttt{try!} macro}
  \item
    \hyperref[composing-custom-error-types]{Composing custom error
    types}
  \item
    \hyperref[advice-for-library-writers]{Advice for library writers}
  \end{itemize}
\item
  \hyperref[case-study-a-program-to-read-population-data]{Case study: A
  program to read population data}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[initial-setup]{Initial setup}
  \item
    \hyperref[argument-parsing]{Argument parsing}
  \item
    \hyperref[writing-the-logic]{Writing the logic}
  \item
    \hyperref[error-handling-with-boxerror]{Error handling with
    \texttt{Box\textless{}Error\textgreater{}}}
  \item
    \hyperref[reading-from-stdin]{Reading from stdin}
  \item
    \hyperref[error-handling-with-a-custom-type]{Error handling with a
    custom type}
  \item
    \hyperref[adding-functionality]{Adding functionality}
  \end{itemize}
\item
  \hyperref[the-short-story]{The short story}
\end{itemize}

\hyperdef{}{the-basics}{\subsection{The Basics}\label{the-basics}}

You can think of error handling as using \emph{case analysis} to
determine whether a computation was successful or not. As you will see,
the key to ergonomic error handling is reducing the amount of explicit
case analysis the programmer has to do while keeping code composable.

Keeping code composable is important, because without that requirement,
we could
\href{http://doc.rust-lang.org/std/macro.panic!.html}{\texttt{panic}}
whenever we come across something unexpected. (\texttt{panic} causes the
current task to unwind, and in most cases, the entire program aborts.)
Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Guess a number between 1 and 10.}
\CommentTok{// If it matches the number we had in mind, return true. Else, return false.}
\KeywordTok{fn} \NormalTok{guess(n: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
    \KeywordTok{if} \NormalTok{n < }\DecValTok{1} \NormalTok{|| n > }\DecValTok{10} \NormalTok{\{}
        \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"Invalid number: \{\}"}\NormalTok{, n);}
    \NormalTok{\}}
    \NormalTok{n == }\DecValTok{5}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \NormalTok{guess(}\DecValTok{11}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you try running this code, the program will crash with a message like
this:

\begin{verbatim}
thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
\end{verbatim}

Here's another example that is slightly less contrived. A program that
accepts an integer as an argument, doubles it and prints it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::env;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{argv = env::args();}
    \KeywordTok{let} \NormalTok{arg: }\DataTypeTok{String} \NormalTok{= argv.nth(}\DecValTok{1}\NormalTok{).unwrap(); }\CommentTok{// error 1}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= arg.parse().unwrap(); }\CommentTok{// error 2}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, }\DecValTok{2} \NormalTok{* n);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you give this program zero arguments (error 1) or if the first
argument isn't an integer (error 2), the program will panic just like in
the first example.

You can think of this style of error handling as similar to a bull
running through a china shop. The bull will get to where it wants to go,
but it will trample everything in the process.

\hyperdef{}{unwrapping-explained}{\subsubsection{Unwrapping
explained}\label{unwrapping-explained}}

In the previous example, we claimed that the program would simply panic
if it reached one of the two error conditions, yet, the program does not
include an explicit call to \texttt{panic} like the first example. This
is because the panic is embedded in the calls to \texttt{unwrap}.

To ``unwrap'' something in Rust is to say, ``Give me the result of the
computation, and if there was an error, just panic and stop the
program.'' It would be better if we just showed the code for unwrapping
because it is so simple, but to do that, we will first need to explore
the \texttt{Option} and \texttt{Result} types. Both of these types have
a method called \texttt{unwrap} defined on them.

\hyperdef{}{the-option-type}{\subsubsection{\texorpdfstring{The
\texttt{Option} type}{The Option type}}\label{the-option-type}}

The \texttt{Option} type is
\href{http://doc.rust-lang.org/book/patterns.html}{defined in the
standard library}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Option}\NormalTok{<T> \{}
    \ConstantTok{None}\NormalTok{,}
    \ConstantTok{Some}\NormalTok{(T),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{Option} type is a way to use Rust's type system to express
the \emph{possibility of absence}. Encoding the possibility of absence
into the type system is an important concept because it will cause the
compiler to force the programmer to handle that absence. Let's take a
look at an example that tries to find a character in a string:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Searches `haystack` for the Unicode character `needle`. If one is found, the}
\CommentTok{// byte offset of the character is returned. Otherwise, `None` is returned.}
\KeywordTok{fn} \NormalTok{find(haystack: &}\DataTypeTok{str}\NormalTok{, needle: }\DataTypeTok{char}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{usize}\NormalTok{> \{}
    \KeywordTok{for} \NormalTok{(offset, c) }\KeywordTok{in} \NormalTok{haystack.char_indices() \{}
        \KeywordTok{if} \NormalTok{c == needle \{}
            \KeywordTok{return} \ConstantTok{Some}\NormalTok{(offset);}
        \NormalTok{\}}
    \NormalTok{\}}
    \ConstantTok{None}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that when this function finds a matching character, it doen't
just return the \texttt{offset}. Instead, it returns
\texttt{Some(offset)}. \texttt{Some} is a variant or a \emph{value
constructor} for the \texttt{Option} type. You can think of it as a
function with the type
\texttt{fn\textless{}T\textgreater{}(value:\ T)\ -\textgreater{}\ Option\textless{}T\textgreater{}}.
Correspondingly, \texttt{None} is also a value constructor, except it
has no arguments. You can think of \texttt{None} as a function with the
type
\texttt{fn\textless{}T\textgreater{}()\ -\textgreater{}\ Option\textless{}T\textgreater{}}.

This might seem like much ado about nothing, but this is only half of
the story. The other half is \emph{using} the \texttt{find} function
we've written. Let's try to use it to find the extension in a file name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{file_name = }\StringTok{"foobar.rs"}\NormalTok{;}
    \KeywordTok{match} \NormalTok{find(file_name, }\CharTok{'.'}\NormalTok{) \{}
        \ConstantTok{None} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"No file extension found."}\NormalTok{),}
        \ConstantTok{Some}\NormalTok{(i) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"File extension: \{\}"}\NormalTok{, &file_name[i+}\DecValTok{1.}\NormalTok{.]),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code uses
\href{http://doc.rust-lang.org/book/patterns.html}{pattern matching} to
do \emph{case analysis} on the
\texttt{Option\textless{}usize\textgreater{}} returned by the
\texttt{find} function. In fact, case analysis is the only way to get at
the value stored inside an \texttt{Option\textless{}T\textgreater{}}.
This means that you, as the programmer, must handle the case when an
\texttt{Option\textless{}T\textgreater{}} is \texttt{None} instead of
\texttt{Some(t)}.

But wait, what about \texttt{unwrap} used in
\hyperref[code-unwrap-double]{\texttt{unwrap-double}}? There was no case
analysis there! Instead, the case analysis was put inside the
\texttt{unwrap} method for you. You could define it yourself if you
want:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Option}\NormalTok{<T> \{}
    \ConstantTok{None}\NormalTok{,}
    \ConstantTok{Some}\NormalTok{(T),}
\NormalTok{\}}

\KeywordTok{impl}\NormalTok{<T> }\DataTypeTok{Option}\NormalTok{<T> \{}
    \KeywordTok{fn} \NormalTok{unwrap(}\KeywordTok{self}\NormalTok{) -> T \{}
        \KeywordTok{match} \KeywordTok{self} \NormalTok{\{}
            \DataTypeTok{Option}\NormalTok{::}\ConstantTok{Some}\NormalTok{(val) => val,}
            \DataTypeTok{Option}\NormalTok{::}\ConstantTok{None} \NormalTok{=>}
              \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"called `Option::unwrap()` on a `None` value"}\NormalTok{),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{unwrap} method \emph{abstracts away the case analysis}. This
is precisely the thing that makes \texttt{unwrap} ergonomic to use.
Unfortunately, that \texttt{panic!} means that \texttt{unwrap} is not
composable: it is the bull in the china shop.

\hyperdef{}{composing-optiont-values}{\paragraph{\texorpdfstring{Composing
\texttt{Option\textless{}T\textgreater{}}
values}{Composing Option\textless{}T\textgreater{} values}}\label{composing-optiont-values}}

In
\hyperref[code-option-ex-string-find-2]{\texttt{option-ex-string-find}}
we saw how to use \texttt{find} to discover the extension in a file
name. Of course, not all file names have a \texttt{.} in them, so it's
possible that the file name has no extension. This \emph{possibility of
absence} is encoded into the types using
\texttt{Option\textless{}T\textgreater{}}. In other words, the compiler
will force us to address the possibility that an extension does not
exist. In our case, we just print out a message saying as such.

Getting the extension of a file name is a pretty common operation, so it
makes sense to put it into a function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Returns the extension of the given file name, where the extension is defined}
\CommentTok{// as all characters proceding the first `.`.}
\CommentTok{// If `file_name` has no `.`, then `None` is returned.}
\KeywordTok{fn} \NormalTok{extension_explicit(file_name: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&}\DataTypeTok{str}\NormalTok{> \{}
    \KeywordTok{match} \NormalTok{find(file_name, }\CharTok{'.'}\NormalTok{) \{}
        \ConstantTok{None} \NormalTok{=> }\ConstantTok{None}\NormalTok{,}
        \ConstantTok{Some}\NormalTok{(i) => }\ConstantTok{Some}\NormalTok{(&file_name[i+}\DecValTok{1.}\NormalTok{.]),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(Pro-tip: don't use this code. Use the
\href{http://doc.rust-lang.org/std/path/struct.Path.html\#method.extension}{\texttt{extension}}
method in the standard library instead.)

The code stays simple, but the important thing to notice is that the
type of \texttt{find} forces us to consider the possibility of absence.
This is a good thing because it means the compiler won't let us
accidentally forget about the case where a file name doesn't have an
extension. On the other hand, doing explicit case analysis like we've
done in \texttt{extension\_explicit} every time can get a bit tiresome.

In fact, the case analysis in \texttt{extension\_explicit} follows a
very common pattern: \emph{map} a function on to the value inside of an
\texttt{Option\textless{}T\textgreater{}}, unless the option is
\texttt{None}, in which case, just return \texttt{None}.

Rust has parametric polymorphism, so it is very easy to define a
combinator that abstracts this pattern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{map<F, T, A>(option: }\DataTypeTok{Option}\NormalTok{<T>, f: F) -> }\DataTypeTok{Option}\NormalTok{<A> }\KeywordTok{where} \NormalTok{F: }\BuiltInTok{FnOnce}\NormalTok{(T) -> A \{}
    \KeywordTok{match} \NormalTok{option \{}
        \ConstantTok{None} \NormalTok{=> }\ConstantTok{None}\NormalTok{,}
        \ConstantTok{Some}\NormalTok{(value) => }\ConstantTok{Some}\NormalTok{(f(value)),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Indeed, \texttt{map} is
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.map}{defined
as a method} on \texttt{Option\textless{}T\textgreater{}} in the
standard library.

Armed with our new combinator, we can rewrite our
\texttt{extension\_explicit} method to get rid of the case analysis:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Returns the extension of the given file name, where the extension is defined}
\CommentTok{// as all characters proceding the first `.`.}
\CommentTok{// If `file_name` has no `.`, then `None` is returned.}
\KeywordTok{fn} \NormalTok{extension(file_name: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&}\DataTypeTok{str}\NormalTok{> \{}
    \NormalTok{find(file_name, }\CharTok{'.'}\NormalTok{).map(|i| &file_name[i+}\DecValTok{1.}\NormalTok{.])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

One other pattern that we find is very common is assigning a default
value to the case when an \texttt{Option} value is \texttt{None}. For
example, maybe your program assumes that the extension of a file is
\texttt{rs} even if none is present. As you might imagine, the case
analysis for this is not specific to file extensions - it can work with
any \texttt{Option\textless{}T\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{unwrap_or<T>(option: }\DataTypeTok{Option}\NormalTok{<T>, default: T) -> T \{}
    \KeywordTok{match} \NormalTok{option \{}
        \ConstantTok{None} \NormalTok{=> default,}
        \ConstantTok{Some}\NormalTok{(value) => value,}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The trick here is that the default value must have the same type as the
value that might be inside the
\texttt{Option\textless{}T\textgreater{}}. Using it is dead simple in
our case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{#}
\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(extension(}\StringTok{"foobar.csv"}\NormalTok{).unwrap_or(}\StringTok{"rs"}\NormalTok{), }\StringTok{"csv"}\NormalTok{);}
    \PreprocessorTok{assert_eq!}\NormalTok{(extension(}\StringTok{"foobar"}\NormalTok{).unwrap_or(}\StringTok{"rs"}\NormalTok{), }\StringTok{"rs"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(Note that \texttt{unwrap\_or} is
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap_or}{defined
as a method} on \texttt{Option\textless{}T\textgreater{}} in the
standard library, so we use that here instead of the free-standing
function we defined above. Don't forget to check out the more general
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap_or_else}{\texttt{unwrap\_or\_else}}
method.)

There is one more combinator that we think is worth paying special
attention to: \texttt{and\_then}. It makes it easy to compose distinct
computations that admit the \emph{possibility of absence}. For example,
much of the code in this section is about finding an extension given a
file name. In order to do this, you first need the file name which is
typically extracted from a file \emph{path}. While most file paths have
a file name, not \emph{all} of them do. For example, \texttt{.},
\texttt{..} or \texttt{/}.

So, we are tasked with the challenge of finding an extension given a
file \emph{path}. Let's start with explicit case analysis:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{file_path_ext_explicit(file_path: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&}\DataTypeTok{str}\NormalTok{> \{}
    \KeywordTok{match} \NormalTok{file_name(file_path) \{}
        \ConstantTok{None} \NormalTok{=> }\ConstantTok{None}\NormalTok{,}
        \ConstantTok{Some}\NormalTok{(name) => }\KeywordTok{match} \NormalTok{extension(name) \{}
            \ConstantTok{None} \NormalTok{=> }\ConstantTok{None}\NormalTok{,}
            \ConstantTok{Some}\NormalTok{(ext) => }\ConstantTok{Some}\NormalTok{(ext),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{file_name(file_path: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&}\DataTypeTok{str}\NormalTok{> \{}
  \CommentTok{// implementation elided}
  \PreprocessorTok{unimplemented!}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You might think that we could just use the \texttt{map} combinator to
reduce the case analysis, but its type doesn't quite fit. Namely,
\texttt{map} takes a function that does something only with the inner
value. The result of that function is then \emph{always}
\hyperref[code-option-map]{rewrapped with \texttt{Some}}. Instead, we
need something like \texttt{map}, but which allows the caller to return
another \texttt{Option}. Its generic implementation is even simpler than
\texttt{map}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{and_then<F, T, A>(option: }\DataTypeTok{Option}\NormalTok{<T>, f: F) -> }\DataTypeTok{Option}\NormalTok{<A>}
        \KeywordTok{where} \NormalTok{F: }\BuiltInTok{FnOnce}\NormalTok{(T) -> }\DataTypeTok{Option}\NormalTok{<A> \{}
    \KeywordTok{match} \NormalTok{option \{}
        \ConstantTok{None} \NormalTok{=> }\ConstantTok{None}\NormalTok{,}
        \ConstantTok{Some}\NormalTok{(value) => f(value),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can rewrite our \texttt{file\_path\_ext} function without
explicit case analysis:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{file_path_ext(file_path: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&}\DataTypeTok{str}\NormalTok{> \{}
    \NormalTok{file_name(file_path).and_then(extension)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{Option} type has many other combinators
\href{http://doc.rust-lang.org/std/option/enum.Option.html}{defined in
the standard library}. It is a good idea to skim this list and
familiarize yourself with what's available---they can often reduce case
analysis for you. Familiarizing yourself with these combinators will pay
dividends because many of them are also defined (with similar semantics)
for \texttt{Result}, which we will talk about next.

Combinators make using types like \texttt{Option} ergonomic because they
reduce explicit case analysis. They are also composable because they
permit the caller to handle the possibility of absence in their own way.
Methods like \texttt{unwrap} remove choices because they will panic if
\texttt{Option\textless{}T\textgreater{}} is \texttt{None}.

\hyperdef{}{the-result-type}{\subsubsection{\texorpdfstring{The
\texttt{Result} type}{The Result type}}\label{the-result-type}}

The \texttt{Result} type is also
\href{http://doc.rust-lang.org/std/result/}{defined in the standard
library}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Result}\NormalTok{<T, E> \{}
    \ConstantTok{Ok}\NormalTok{(T),}
    \ConstantTok{Err}\NormalTok{(E),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{Result} type is a richer version of \texttt{Option}. Instead
of expressing the possibility of \emph{absence} like \texttt{Option}
does, \texttt{Result} expresses the possibility of \emph{error}.
Usually, the \emph{error} is used to explain why the result of some
computation failed. This is a strictly more general form of
\texttt{Option}. Consider the following type alias, which is
semantically equivalent to the real
\texttt{Option\textless{}T\textgreater{}} in every way:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \NormalTok{Option<T> = }\DataTypeTok{Result}\NormalTok{<T, ()>;}
\end{Highlighting}
\end{Shaded}

This fixes the second type parameter of \texttt{Result} to always be
\texttt{()} (pronounced ``unit'' or ``empty tuple''). Exactly one value
inhabits the \texttt{()} type: \texttt{()}. (Yup, the type and value
level terms have the same notation!)

The \texttt{Result} type is a way of representing one of two possible
outcomes in a computation. By convention, one outcome is meant to be
expected or ``\texttt{Ok}'' while the other outcome is meant to be
unexpected or ``\texttt{Err}''.

Just like \texttt{Option}, the \texttt{Result} type also has an
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap}{\texttt{unwrap}
method defined} in the standard library. Let's define it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl}\NormalTok{<T, E: ::std::fmt::}\BuiltInTok{Debug}\NormalTok{> }\DataTypeTok{Result}\NormalTok{<T, E> \{}
    \KeywordTok{fn} \NormalTok{unwrap(}\KeywordTok{self}\NormalTok{) -> T \{}
        \KeywordTok{match} \KeywordTok{self} \NormalTok{\{}
            \DataTypeTok{Result}\NormalTok{::}\ConstantTok{Ok}\NormalTok{(val) => val,}
            \DataTypeTok{Result}\NormalTok{::}\ConstantTok{Err}\NormalTok{(err) =>}
              \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"called `Result::unwrap()` on an `Err` value: \{:?\}"}\NormalTok{, err),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is effectively the same as our
\hyperref[code-option-def-unwrap]{definition for
\texttt{Option::unwrap}}, except it includes the error value in the
\texttt{panic!} message. This makes debugging easier, but it also
requires us to add a
\href{http://doc.rust-lang.org/std/fmt/trait.Debug.html}{\texttt{Debug}}
constraint on the \texttt{E} type parameter (which represents our error
type). Since the vast majority of types should satisfy the
\texttt{Debug} constraint, this tends to work out in practice.
(\texttt{Debug} on a type simply means that there's a reasonable way to
print a human readable description of values with that type.)

OK, let's move on to an example.

\hyperdef{}{parsing-integers}{\paragraph{Parsing
integers}\label{parsing-integers}}

The Rust standard library makes converting strings to integers dead
simple. It's so easy in fact, that it is very tempting to write
something like the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{double_number(number_str: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \DecValTok{2} \NormalTok{* number_str.parse::<}\DataTypeTok{i32}\NormalTok{>().unwrap()}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= double_number(}\StringTok{"10"}\NormalTok{);}
    \PreprocessorTok{assert_eq!}\NormalTok{(n, }\DecValTok{20}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

At this point, you should be skeptical of calling \texttt{unwrap}. For
example, if the string doesn't parse as a number, you'll get a panic:

\begin{verbatim}
thread '<main>' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntErro
‚Ü≥ r { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-l
‚Ü≥ inux/build/src/libcore/result.rs:729
\end{verbatim}

This is rather unsightly, and if this happened inside a library you're
using, you might be understandably annoyed. Instead, we should try to
handle the error in our function and let the caller decide what to do.
This means changing the return type of \texttt{double\_number}. But to
what? Well, that requires looking at the signature of the
\href{http://doc.rust-lang.org/std/primitive.str.html\#method.parse}{\texttt{parse}
method} in the standard library:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \DataTypeTok{str} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{parse<F: FromStr>(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{Result}\NormalTok{<F, F::}\ConstantTok{Err}\NormalTok{>;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Hmm. So we at least know that we need to use a \texttt{Result}.
Certainly, it's possible that this could have returned an
\texttt{Option}. After all, a string either parses as a number or it
doesn't, right? That's certainly a reasonable way to go, but the
implementation internally distinguishes \emph{why} the string didn't
parse as an integer. (Whether it's an empty string, an invalid digit,
too big or too small.) Therefore, using a \texttt{Result} makes sense
because we want to provide more information than simply ``absence.'' We
want to say \emph{why} the parsing failed. You should try to emulate
this line of reasoning when faced with a choice between \texttt{Option}
and \texttt{Result}. If you can provide detailed error information, then
you probably should. (We'll see more on this later.)

OK, but how do we write our return type? The \texttt{parse} method as
defined above is generic over all the different number types defined in
the standard library. We could (and probably should) also make our
function generic, but let's favor explicitness for the moment. We only
care about \texttt{i32}, so we need to
\href{http://doc.rust-lang.org/std/primitive.i32.html}{find its
implementation of \texttt{FromStr}} (do a \texttt{CTRL-F} in your
browser for ``FromStr'') and look at its
\href{http://doc.rust-lang.org/book/associated-types.html}{associated
type} \texttt{Err}. We did this so we can find the concrete error type.
In this case, it's
\href{http://doc.rust-lang.org/std/num/struct.ParseIntError.html}{\texttt{std::num::ParseIntError}}.
Finally, we can rewrite our function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::num::ParseIntError;}

\KeywordTok{fn} \NormalTok{double_number(number_str: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, ParseIntError> \{}
    \KeywordTok{match} \NormalTok{number_str.parse::<}\DataTypeTok{i32}\NormalTok{>() \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n),}
        \ConstantTok{Err}\NormalTok{(err) => }\ConstantTok{Err}\NormalTok{(err),}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{double_number(}\StringTok{"10"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{assert_eq!}\NormalTok{(n, }\DecValTok{20}\NormalTok{),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{:?\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is a little better, but now we've written a lot more code! The case
analysis has once again bitten us.

Combinators to the rescue! Just like \texttt{Option}, \texttt{Result}
has lots of combinators defined as methods. There is a large
intersection of common combinators between \texttt{Result} and
\texttt{Option}. In particular, \texttt{map} is part of that
intersection:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::num::ParseIntError;}

\KeywordTok{fn} \NormalTok{double_number(number_str: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, ParseIntError> \{}
    \NormalTok{number_str.parse::<}\DataTypeTok{i32}\NormalTok{>().map(|n| }\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{double_number(}\StringTok{"10"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{assert_eq!}\NormalTok{(n, }\DecValTok{20}\NormalTok{),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{:?\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The usual suspects are all there for \texttt{Result}, including
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap_or}{\texttt{unwrap\_or}}
and
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.and_then}{\texttt{and\_then}}.
Additionally, since \texttt{Result} has a second type parameter, there
are combinators that affect only the error type, such as
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.map_err}{\texttt{map\_err}}
(instead of \texttt{map}) and
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.or_else}{\texttt{or\_else}}
(instead of \texttt{and\_then}).

\hyperdef{}{the-result-type-alias-idiom}{\paragraph{\texorpdfstring{The
\texttt{Result} type alias
idiom}{The Result type alias idiom}}\label{the-result-type-alias-idiom}}

In the standard library, you may frequently see types like
\texttt{Result\textless{}i32\textgreater{}}. But wait,
\hyperref[code-result-def-1]{we defined \texttt{Result}} to have two
type parameters. How can we get away with only specifying one? The key
is to define a \texttt{Result} type alias that \emph{fixes} one of the
type parameters to a particular type. Usually the fixed type is the
error type. For example, our previous example parsing integers could be
rewritten like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::num::ParseIntError;}
\KeywordTok{use} \NormalTok{std::result;}

\KeywordTok{type} \NormalTok{Result<T> = result::}\DataTypeTok{Result}\NormalTok{<T, ParseIntError>;}

\KeywordTok{fn} \NormalTok{double_number(number_str: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{> \{}
    \PreprocessorTok{unimplemented!}\NormalTok{();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Why would we do this? Well, if we have a lot of functions that could
return \texttt{ParseIntError}, then it's much more convenient to define
an alias that always uses \texttt{ParseIntError} so that we don't have
to write it out all the time.

The most prominent place this idiom is used in the standard library is
with
\href{http://doc.rust-lang.org/std/io/type.Result.html}{\texttt{io::Result}}.
Typically, one writes \texttt{io::Result\textless{}T\textgreater{}},
which makes it clear that you're using the \texttt{io} module's type
alias instead of the plain definition from \texttt{std::result}. (This
idiom is also used for
\href{http://doc.rust-lang.org/std/fmt/type.Result.html}{\texttt{fmt::Result}}.)

\hyperdef{}{a-brief-interlude-unwrapping-isnt-evil}{\subsubsection{A
brief interlude: unwrapping isn't
evil}\label{a-brief-interlude-unwrapping-isnt-evil}}

If you've been following along, you might have noticed that I've taken a
pretty hard line against calling methods like \texttt{unwrap} that could
\texttt{panic} and abort your program. \emph{Generally speaking}, this
is good advice.

However, \texttt{unwrap} can still be used judiciously. What exactly
justifies use of \texttt{unwrap} is somewhat of a grey area and
reasonable people can disagree. I'll summarize some of my
\emph{opinions} on the matter.

\begin{itemize}
\tightlist
\item
  \textbf{In examples and quick `n' dirty code.} Sometimes you're
  writing examples or a quick program, and error handling simply isn't
  important. Beating the convenience of \texttt{unwrap} can be hard in
  such scenarios, so it is very appealing.
\item
  \textbf{When panicking indicates a bug in the program.} When the
  invariants of your code should prevent a certain case from happening
  (like, say, popping from an empty stack), then panicking can be
  permissible. This is because it exposes a bug in your program. This
  can be explicit, like from an \texttt{assert!} failing, or it could be
  because your index into an array was out of bounds.
\end{itemize}

This is probably not an exhaustive list. Moreover, when using an
\texttt{Option}, it is often better to use its
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.expect}{\texttt{expect}}
method. \texttt{expect} does exactly the same thing as \texttt{unwrap},
except it prints a message you give to \texttt{expect}. This makes the
resulting panic a bit nicer to deal with, since it will show your
message instead of ``called unwrap on a \texttt{None} value.''

My advice boils down to this: use good judgment. There's a reason why
the words ``never do X'' or ``Y is considered harmful'' don't appear in
my writing. There are trade offs to all things, and it is up to you as
the programmer to determine what is acceptable for your use cases. My
goal is only to help you evaluate trade offs as accurately as possible.

Now that we've covered the basics of error handling in Rust, and
explained unwrapping, let's start exploring more of the standard
library.

\hyperdef{}{working-with-multiple-error-types}{\subsection{Working with
multiple error types}\label{working-with-multiple-error-types}}

Thus far, we've looked at error handling where everything was either an
\texttt{Option\textless{}T\textgreater{}} or a
\texttt{Result\textless{}T,\ SomeError\textgreater{}}. But what happens
when you have both an \texttt{Option} and a \texttt{Result}? Or what if
you have a \texttt{Result\textless{}T,\ Error1\textgreater{}} and a
\texttt{Result\textless{}T,\ Error2\textgreater{}}? Handling
\emph{composition of distinct error types} is the next challenge in
front of us, and it will be the major theme throughout the rest of this
chapter.

\hyperdef{}{composing-option-and-result}{\subsubsection{\texorpdfstring{Composing
\texttt{Option} and
\texttt{Result}}{Composing Option and Result}}\label{composing-option-and-result}}

So far, I've talked about combinators defined for \texttt{Option} and
combinators defined for \texttt{Result}. We can use these combinators to
compose results of different computations without doing explicit case
analysis.

Of course, in real code, things aren't always as clean. Sometimes you
have a mix of \texttt{Option} and \texttt{Result} types. Must we resort
to explicit case analysis, or can we continue using combinators?

For now, let's revisit one of the first examples in this chapter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::env;}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{argv = env::args();}
    \KeywordTok{let} \NormalTok{arg: }\DataTypeTok{String} \NormalTok{= argv.nth(}\DecValTok{1}\NormalTok{).unwrap(); }\CommentTok{// error 1}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= arg.parse().unwrap(); }\CommentTok{// error 2}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, }\DecValTok{2} \NormalTok{* n);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Given our new found knowledge of \texttt{Option}, \texttt{Result} and
their various combinators, we should try to rewrite this so that errors
are handled properly and the program doesn't panic if there's an error.

The tricky aspect here is that \texttt{argv.nth(1)} produces an
\texttt{Option} while \texttt{arg.parse()} produces a \texttt{Result}.
These aren't directly composable. When faced with both an
\texttt{Option} and a \texttt{Result}, the solution is \emph{usually} to
convert the \texttt{Option} to a \texttt{Result}. In our case, the
absence of a command line parameter (from \texttt{env::args()}) means
the user didn't invoke the program correctly. We could just use a
\texttt{String} to describe the error. Let's try:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::env;}

\KeywordTok{fn} \NormalTok{double_arg(}\KeywordTok{mut} \NormalTok{argv: env::Args) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{String}\NormalTok{> \{}
    \NormalTok{argv.nth(}\DecValTok{1}\NormalTok{)}
        \NormalTok{.ok_or(}\StringTok{"Please give at least one argument"}\NormalTok{.to_owned())}
        \NormalTok{.and_then(|arg| arg.parse::<}\DataTypeTok{i32}\NormalTok{>().map_err(|err| err.to_string()))}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{double_arg(env::args()) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, n),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are a couple new things in this example. The first is the use of
the
\href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.ok_or}{\texttt{Option::ok\_or}}
combinator. This is one way to convert an \texttt{Option} into a
\texttt{Result}. The conversion requires you to specify what error to
use if \texttt{Option} is \texttt{None}. Like the other combinators
we've seen, its definition is very simple:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{ok_or<T, E>(option: }\DataTypeTok{Option}\NormalTok{<T>, err: E) -> }\DataTypeTok{Result}\NormalTok{<T, E> \{}
    \KeywordTok{match} \NormalTok{option \{}
        \ConstantTok{Some}\NormalTok{(val) => }\ConstantTok{Ok}\NormalTok{(val),}
        \ConstantTok{None} \NormalTok{=> }\ConstantTok{Err}\NormalTok{(err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The other new combinator used here is
\href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.map_err}{\texttt{Result::map\_err}}.
This is just like \texttt{Result::map}, except it maps a function on to
the \emph{error} portion of a \texttt{Result} value. If the
\texttt{Result} is an \texttt{Ok(...)} value, then it is returned
unmodified.

We use \texttt{map\_err} here because it is necessary for the error
types to remain the same (because of our use of \texttt{and\_then}).
Since we chose to convert the
\texttt{Option\textless{}String\textgreater{}} (from
\texttt{argv.nth(1)}) to a
\texttt{Result\textless{}String,\ String\textgreater{}}, we must also
convert the \texttt{ParseIntError} from \texttt{arg.parse()} to a
\texttt{String}.

\hyperdef{}{the-limits-of-combinators}{\subsubsection{The limits of
combinators}\label{the-limits-of-combinators}}

Doing IO and parsing input is a very common task, and it's one that I
personally have done a lot of in Rust. Therefore, we will use (and
continue to use) IO and various parsing routines to exemplify error
handling.

Let's start simple. We are tasked with opening a file, reading all of
its contents and converting its contents to a number. Then we multiply
it by \texttt{2} and print the output.

Although I've tried to convince you not to use \texttt{unwrap}, it can
be useful to first write your code using \texttt{unwrap}. It allows you
to focus on your problem instead of the error handling, and it exposes
the points where proper error handling need to occur. Let's start there
so we can get a handle on the code, and then refactor it to use better
error handling.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = File::open(file_path).unwrap(); }\CommentTok{// error 1}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \NormalTok{file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents).unwrap(); }\CommentTok{// error 2}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= contents.trim().parse().unwrap(); }\CommentTok{// error 3}
    \DecValTok{2} \NormalTok{* n}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{doubled = file_double(}\StringTok{"foobar"}\NormalTok{);}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, doubled);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(N.B. The \texttt{AsRef\textless{}Path\textgreater{}} is used because
those are the
\href{http://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{same
bounds used on \texttt{std::fs::File::open}}. This makes it ergnomic to
use any kind of string as a file path.)

There are three different errors that can occur here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A problem opening the file.
\item
  A problem reading data from the file.
\item
  A problem parsing the data as a number.
\end{enumerate}

The first two problems are described via the
\href{http://doc.rust-lang.org/std/io/struct.Error.html}{\texttt{std::io::Error}}
type. We know this because of the return types of
\href{http://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{\texttt{std::fs::File::open}}
and
\href{http://doc.rust-lang.org/std/io/trait.Read.html\#method.read_to_string}{\texttt{std::io::Read::read\_to\_string}}.
(Note that they both use the
\hyperref[the-result-type-alias-idiom]{\texttt{Result} type alias idiom}
described previously. If you click on the \texttt{Result} type, you'll
\href{http://doc.rust-lang.org/std/io/type.Result.html}{see the type
alias}, and consequently, the underlying \texttt{io::Error} type.) The
third problem is described by the
\href{http://doc.rust-lang.org/std/num/struct.ParseIntError.html}{\texttt{std::num::ParseIntError}}
type. The \texttt{io::Error} type in particular is \emph{pervasive}
throughout the standard library. You will see it again and again.

Let's start the process of refactoring the \texttt{file\_double}
function. To make this function composable with other components of the
program, it should \emph{not} panic if any of the above error conditions
are met. Effectively, this means that the function should \emph{return
an error} if any of its operations fail. Our problem is that the return
type of \texttt{file\_double} is \texttt{i32}, which does not give us
any useful way of reporting an error. Thus, we must start by changing
the return type from \texttt{i32} to something else.

The first thing we need to decide: should we use \texttt{Option} or
\texttt{Result}? We certainly could use \texttt{Option} very easily. If
any of the three errors occur, we could simply return \texttt{None}.
This will work \emph{and it is better than panicking}, but we can do a
lot better. Instead, we should pass some detail about the error that
occurred. Since we want to express the \emph{possibility of error}, we
should use \texttt{Result\textless{}i32,\ E\textgreater{}}. But what
should \texttt{E} be? Since two \emph{different} types of errors can
occur, we need to convert them to a common type. One such type is
\texttt{String}. Let's see how that impacts our code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{String}\NormalTok{> \{}
    \NormalTok{File::open(file_path)}
         \NormalTok{.map_err(|err| err.to_string())}
         \NormalTok{.and_then(|}\KeywordTok{mut} \NormalTok{file| \{}
              \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
              \NormalTok{file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents)}
                  \NormalTok{.map_err(|err| err.to_string())}
                  \NormalTok{.map(|_| contents)}
         \NormalTok{\})}
         \NormalTok{.and_then(|contents| \{}
              \NormalTok{contents.trim().parse::<}\DataTypeTok{i32}\NormalTok{>()}
                      \NormalTok{.map_err(|err| err.to_string())}
         \NormalTok{\})}
         \NormalTok{.map(|n| }\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{file_double(}\StringTok{"foobar"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, n),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code looks a bit hairy. It can take quite a bit of practice before
code like this becomes easy to write. The way we write it is by
\emph{following the types}. As soon as we changed the return type of
\texttt{file\_double} to
\texttt{Result\textless{}i32,\ String\textgreater{}}, we had to start
looking for the right combinators. In this case, we only used three
different combinators: \texttt{and\_then}, \texttt{map} and
\texttt{map\_err}.

\texttt{and\_then} is used to chain multiple computations where each
computation could return an error. After opening the file, there are two
more computations that could fail: reading from the file and parsing the
contents as a number. Correspondingly, there are two calls to
\texttt{and\_then}.

\texttt{map} is used to apply a function to the \texttt{Ok(...)} value
of a \texttt{Result}. For example, the very last call to \texttt{map}
multiplies the \texttt{Ok(...)} value (which is an \texttt{i32}) by
\texttt{2}. If an error had occurred before that point, this operation
would have been skipped because of how \texttt{map} is defined.

\texttt{map\_err} is the trick the makes all of this work.
\texttt{map\_err} is just like \texttt{map}, except it applies a
function to the \texttt{Err(...)} value of a \texttt{Result}. In this
case, we want to convert all of our errors to one type: \texttt{String}.
Since both \texttt{io::Error} and \texttt{num::ParseIntError} implement
\texttt{ToString}, we can call the \texttt{to\_string()} method to
convert them.

With all of that said, the code is still hairy. Mastering use of
combinators is important, but they have their limits. Let's try a
different approach: early returns.

\hyperdef{}{early-returns}{\subsubsection{Early
returns}\label{early-returns}}

I'd like to take the code from the previous section and rewrite it using
\emph{early returns}. Early returns let you exit the function early. We
can't return early in \texttt{file\_double} from inside another closure,
so we'll need to revert back to explicit case analysis.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{String}\NormalTok{> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\KeywordTok{match} \NormalTok{File::open(file_path) \{}
        \ConstantTok{Ok}\NormalTok{(file) => file,}
        \ConstantTok{Err}\NormalTok{(err) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(err.to_string()),}
    \NormalTok{\};}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \KeywordTok{if} \KeywordTok{let} \ConstantTok{Err}\NormalTok{(err) = file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents) \{}
        \KeywordTok{return} \ConstantTok{Err}\NormalTok{(err.to_string());}
    \NormalTok{\}}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= }\KeywordTok{match} \NormalTok{contents.trim().parse() \{}
        \ConstantTok{Ok}\NormalTok{(n) => n,}
        \ConstantTok{Err}\NormalTok{(err) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(err.to_string()),}
    \NormalTok{\};}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{file_double(}\StringTok{"foobar"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, n),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Reasonable people can disagree over whether this code is better that the
code that uses combinators, but if you aren't familiar with the
combinator approach, this code looks simpler to read to me. It uses
explicit case analysis with \texttt{match} and \texttt{if\ let}. If an
error occurs, it simply stops executing the function and returns the
error (by converting it to a string).

Isn't this a step backwards though? Previously, we said that the key to
ergonomic error handling is reducing explicit case analysis, yet we've
reverted back to explicit case analysis here. It turns out, there are
\emph{multiple} ways to reduce explicit case analysis. Combinators
aren't the only way.

\hyperdef{}{the-try-macro}{\subsubsection{\texorpdfstring{The
\texttt{try!} macro}{The try! macro}}\label{the-try-macro}}

A cornerstone of error handling in Rust is the \texttt{try!} macro. The
\texttt{try!} macro abstracts case analysis just like combinators, but
unlike combinators, it also abstracts \emph{control flow}. Namely, it
can abstract the \emph{early return} pattern seen above.

Here is a simplified definition of a \texttt{try!} macro:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{try \{}
    \NormalTok{($e:expr) => (}\KeywordTok{match} \NormalTok{$e \{}
        \ConstantTok{Ok}\NormalTok{(val) => val,}
        \ConstantTok{Err}\NormalTok{(err) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(err),}
    \NormalTok{\});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(The \href{http://doc.rust-lang.org/std/macro.try!.html}{real
definition} is a bit more sophisticated. We will address that later.)

Using the \texttt{try!} macro makes it very easy to simplify our last
example. Since it does the case analysis and the early return for us, we
get tighter code that is easier to read:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{String}\NormalTok{> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path).map_err(|e| e.to_string()));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents).map_err(|e| e.to_string()));}
    \KeywordTok{let} \NormalTok{n = }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse::<}\DataTypeTok{i32}\NormalTok{>().map_err(|e| e.to_string()));}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{file_double(}\StringTok{"foobar"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, n),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{map\_err} calls are still necessary given
\hyperref[code-try-def-simple]{our definition of \texttt{try!}}. This is
because the error types still need to be converted to \texttt{String}.
The good news is that we will soon learn how to remove those
\texttt{map\_err} calls! The bad news is that we will need to learn a
bit more about a couple important traits in the standard library before
we can remove the \texttt{map\_err} calls.

\hyperdef{}{defining-your-own-error-type}{\subsubsection{Defining your
own error type}\label{defining-your-own-error-type}}

Before we dive into some of the standard library error traits, I'd like
to wrap up this section by removing the use of \texttt{String} as our
error type in the previous examples.

Using \texttt{String} as we did in our previous examples is convenient
because it's easy to convert errors to strings, or even make up your own
errors as strings on the spot. However, using \texttt{String} for your
errors has some downsides.

The first downside is that the error messages tend to clutter your code.
It's possible to define the error messages elsewhere, but unless you're
unusually disciplined, it is very tempting to embed the error message
into your code. Indeed, we did exactly this in a
\hyperref[code-error-double-string]{previous example}.

The second and more important downside is that \texttt{String}s are
\emph{lossy}. That is, if all errors are converted to strings, then the
errors we pass to the caller become completely opaque. The only
reasonable thing the caller can do with a \texttt{String} error is show
it to the user. Certainly, inspecting the string to determine the type
of error is not robust. (Admittedly, this downside is far more important
inside of a library as opposed to, say, an application.)

For example, the \texttt{io::Error} type embeds an
\href{http://doc.rust-lang.org/std/io/enum.ErrorKind.html}{\texttt{io::ErrorKind}},
which is \emph{structured data} that represents what went wrong during
an IO operation. This is important because you might want to react
differently depending on the error. (e.g., A \texttt{BrokenPipe} error
might mean quitting your program gracefully while a \texttt{NotFound}
error might mean exiting with an error code and showing an error to the
user.) With \texttt{io::ErrorKind}, the caller can examine the type of
an error with case analysis, which is strictly superior to trying to
tease out the details of an error inside of a \texttt{String}.

Instead of using a \texttt{String} as an error type in our previous
example of reading an integer from a file, we can define our own error
type that represents errors with \emph{structured data}. We endeavor to
not drop information from underlying errors in case the caller wants to
inspect the details.

The ideal way to represent \emph{one of many possibilities} is to define
our own sum type using \texttt{enum}. In our case, an error is either an
\texttt{io::Error} or a \texttt{num::ParseIntError}, so a natural
definition arises:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::num;}

\CommentTok{// We derive `Debug` because all types should probably derive `Debug`.}
\CommentTok{// This gives us a reasonable human readable description of `CliError` values.}
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{enum} \NormalTok{CliError \{}
    \NormalTok{Io(io::Error),}
    \NormalTok{Parse(num::ParseIntError),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Tweaking our code is very easy. Instead of converting errors to strings,
we simply convert them to our \texttt{CliError} type using the
corresponding value constructor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, CliError> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path).map_err(CliError::Io));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents).map_err(CliError::Io));}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse().map_err(CliError::Parse));}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{match} \NormalTok{file_double(}\StringTok{"foobar"}\NormalTok{) \{}
        \ConstantTok{Ok}\NormalTok{(n) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, n),}
        \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Error: \{:?\}"}\NormalTok{, err),}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The only change here is switching
\texttt{map\_err(\textbar{}e\textbar{}\ e.to\_string())} (which converts
errors to strings) to \texttt{map\_err(CliError::Io)} or
\texttt{map\_err(CliError::Parse)}. The \emph{caller} gets to decide the
level of detail to report to the user. In effect, using a
\texttt{String} as an error type removes choices from the caller while
using a custom \texttt{enum} error type like \texttt{CliError} gives the
caller all of the conveniences as before in addition to \emph{structured
data} describing the error.

A rule of thumb is to define your own error type, but a \texttt{String}
error type will do in a pinch, particularly if you're writing an
application. If you're writing a library, defining your own error type
should be strongly preferred so that you don't remove choices from the
caller unnecessarily.

\hyperdef{}{standard-library-traits-used-for-error-handling}{\subsection{Standard
library traits used for error
handling}\label{standard-library-traits-used-for-error-handling}}

The standard library defines two integral traits for error handling:
\href{http://doc.rust-lang.org/std/error/trait.Error.html}{\texttt{std::error::Error}}
and
\href{http://doc.rust-lang.org/std/convert/trait.From.html}{\texttt{std::convert::From}}.
While \texttt{Error} is designed specifically for generically describing
errors, the \texttt{From} trait serves a more general role for
converting values between two distinct types.

\hyperdef{}{the-error-trait}{\subsubsection{\texorpdfstring{The
\texttt{Error} trait}{The Error trait}}\label{the-error-trait}}

The \texttt{Error} trait is
\href{http://doc.rust-lang.org/std/error/trait.Error.html}{defined in
the standard library}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt::\{}\BuiltInTok{Debug}\NormalTok{, }\BuiltInTok{Display}\NormalTok{\};}

\KeywordTok{trait} \NormalTok{Error: }\BuiltInTok{Debug} \NormalTok{+ }\BuiltInTok{Display} \NormalTok{\{}
  \CommentTok{/// A short description of the error.}
  \KeywordTok{fn} \NormalTok{description(&}\KeywordTok{self}\NormalTok{) -> &}\DataTypeTok{str}\NormalTok{;}

  \CommentTok{/// The lower level cause of this error, if any.}
  \KeywordTok{fn} \NormalTok{cause(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&Error> \{ }\ConstantTok{None} \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This trait is super generic because it is meant to be implemented for
\emph{all} types that represent errors. This will prove useful for
writing composable code as we'll see later. Otherwise, the trait allows
you to do at least the following things:

\begin{itemize}
\tightlist
\item
  Obtain a \texttt{Debug} representation of the error.
\item
  Obtain a user-facing \texttt{Display} representation of the error.
\item
  Obtain a short description of the error (via the \texttt{description}
  method).
\item
  Inspect the causal chain of an error, if one exists (via the
  \texttt{cause} method).
\end{itemize}

The first two are a result of \texttt{Error} requiring impls for both
\texttt{Debug} and \texttt{Display}. The latter two are from the two
methods defined on \texttt{Error}. The power of \texttt{Error} comes
from the fact that all error types impl \texttt{Error}, which means
errors can be existentially quantified as a
\href{http://doc.rust-lang.org/book/trait-objects.html}{trait object}.
This manifests as either \texttt{Box\textless{}Error\textgreater{}} or
\texttt{\&Error}. Indeed, the \texttt{cause} method returns an
\texttt{\&Error}, which is itself a trait object. We'll revisit the
\texttt{Error} trait's utility as a trait object later.

For now, it suffices to show an example implementing the \texttt{Error}
trait. Let's use the error type we defined in the
\hyperref[defining-your-own-error-type]{previous section}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::num;}

\CommentTok{// We derive `Debug` because all types should probably derive `Debug`.}
\CommentTok{// This gives us a reasonable human readable description of `CliError` values.}
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{enum} \NormalTok{CliError \{}
    \NormalTok{Io(io::Error),}
    \NormalTok{Parse(num::ParseIntError),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This particular error type represents the possibility of two types of
errors occurring: an error dealing with I/O or an error converting a
string to a number. The error could represent as many error types as you
want by adding new variants to the \texttt{enum} definition.

Implementing \texttt{Error} is pretty straight-forward. It's mostly
going to be a lot explicit case analysis.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::error;}
\KeywordTok{use} \NormalTok{std::fmt;}

\KeywordTok{impl} \NormalTok{fmt::}\BuiltInTok{Display} \KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{fmt(&}\KeywordTok{self}\NormalTok{, f: &}\KeywordTok{mut} \NormalTok{fmt::Formatter) -> fmt::}\DataTypeTok{Result} \NormalTok{\{}
        \KeywordTok{match} \NormalTok{*}\KeywordTok{self} \NormalTok{\{}
            \CommentTok{// Both underlying errors already impl `Display`, so we defer to}
            \CommentTok{// their implementations.}
            \NormalTok{CliError::Io(}\KeywordTok{ref} \NormalTok{err) => }\PreprocessorTok{write!}\NormalTok{(f, }\StringTok{"IO error: \{\}"}\NormalTok{, err),}
            \NormalTok{CliError::Parse(}\KeywordTok{ref} \NormalTok{err) => }\PreprocessorTok{write!}\NormalTok{(f, }\StringTok{"Parse error: \{\}"}\NormalTok{, err),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{error::Error }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{description(&}\KeywordTok{self}\NormalTok{) -> &}\DataTypeTok{str} \NormalTok{\{}
        \CommentTok{// Both underlying errors already impl `Error`, so we defer to their}
        \CommentTok{// implementations.}
        \KeywordTok{match} \NormalTok{*}\KeywordTok{self} \NormalTok{\{}
            \NormalTok{CliError::Io(}\KeywordTok{ref} \NormalTok{err) => err.description(),}
            \CommentTok{// Normally we can just write `err.description()`, but the error}
            \CommentTok{// type has a concrete method called `description`, which conflicts}
            \CommentTok{// with the trait method. For now, we must explicitly call}
            \CommentTok{// `description` through the `Error` trait.}
            \NormalTok{CliError::Parse(}\KeywordTok{ref} \NormalTok{err) => error::Error::description(err),}
        \NormalTok{\}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{cause(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{Option}\NormalTok{<&error::Error> \{}
        \KeywordTok{match} \NormalTok{*}\KeywordTok{self} \NormalTok{\{}
            \CommentTok{// N.B. Both of these implicitly cast `err` from their concrete}
            \CommentTok{// types (either `&io::Error` or `&num::ParseIntError`)}
            \CommentTok{// to a trait object `&Error`. This works because both error types}
            \CommentTok{// implement `Error`.}
            \NormalTok{CliError::Io(}\KeywordTok{ref} \NormalTok{err) => }\ConstantTok{Some}\NormalTok{(err),}
            \NormalTok{CliError::Parse(}\KeywordTok{ref} \NormalTok{err) => }\ConstantTok{Some}\NormalTok{(err),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We note that this is a very typical implementation of \texttt{Error}:
match on your different error types and satisfy the contracts defined
for \texttt{description} and \texttt{cause}.

\hyperdef{}{the-from-trait}{\subsubsection{\texorpdfstring{The
\texttt{From} trait}{The From trait}}\label{the-from-trait}}

The \texttt{std::convert::From} trait is
\href{http://doc.rust-lang.org/std/convert/trait.From.html}{defined in
the standard library}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{From<T> \{}
    \KeywordTok{fn} \NormalTok{from(T) -> }\KeywordTok{Self}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Deliciously simple, yes? \texttt{From} is very useful because it gives
us a generic way to talk about conversion \emph{from} a particular type
\texttt{T} to some other type (in this case, ``some other type'' is the
subject of the impl, or \texttt{Self}). The crux of \texttt{From} is the
\href{http://doc.rust-lang.org/std/convert/trait.From.html}{set of
implementations provided by the standard library}.

Here are a few simple examples demonstrating how \texttt{From} works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{string: }\DataTypeTok{String} \NormalTok{= From::from(}\StringTok{"foo"}\NormalTok{);}
\KeywordTok{let} \NormalTok{bytes: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{u8}\NormalTok{> = From::from(}\StringTok{"foo"}\NormalTok{);}
\KeywordTok{let} \NormalTok{cow: ::std::borrow::Cow<}\DataTypeTok{str}\NormalTok{> = From::from(}\StringTok{"foo"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

OK, so \texttt{From} is useful for converting between strings. But what
about errors? It turns out, there is one critical impl:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl}\NormalTok{<}\OtherTok{'a}\NormalTok{, E: Error + }\OtherTok{'a}\NormalTok{> From<E> }\KeywordTok{for} \DataTypeTok{Box}\NormalTok{<Error + }\OtherTok{'a}\NormalTok{>}
\end{Highlighting}
\end{Shaded}

This impl says that for \emph{any} type that impls \texttt{Error}, we
can convert it to a trait object
\texttt{Box\textless{}Error\textgreater{}}. This may not seem terribly
surprising, but it is useful in a generic context.

Remember the two errors we were dealing with previously? Specifically,
\texttt{io::Error} and \texttt{num::ParseIntError}. Since both impl
\texttt{Error}, they work with \texttt{From}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::error::Error;}
\KeywordTok{use} \NormalTok{std::fs;}
\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::num;}

\CommentTok{// We have to jump through some hoops to actually get error values.}
\KeywordTok{let} \NormalTok{io_err: io::Error = io::Error::last_os_error();}
\KeywordTok{let} \NormalTok{parse_err: num::ParseIntError = }\StringTok{"not a number"}\NormalTok{.parse::<}\DataTypeTok{i32}\NormalTok{>().unwrap_err();}

\CommentTok{// OK, here are the conversions.}
\KeywordTok{let} \NormalTok{err1: }\DataTypeTok{Box}\NormalTok{<Error> = From::from(io_err);}
\KeywordTok{let} \NormalTok{err2: }\DataTypeTok{Box}\NormalTok{<Error> = From::from(parse_err);}
\end{Highlighting}
\end{Shaded}

There is a really important pattern to recognize here. Both
\texttt{err1} and \texttt{err2} have the \emph{same type}. This is
because they are existentially quantified types, or trait objects. In
particularly, their underlying type is \emph{erased} from the compiler's
knowledge, so it truly sees \texttt{err1} and \texttt{err2} as exactly
the same. Additionally, we constructed \texttt{err1} and \texttt{err2}
using precisely the same function call: \texttt{From::from}. This is
because \texttt{From::from} is overloaded on both its argument and its
return type.

This pattern is important because it solves a problem we had earlier: it
gives us a way to reliably convert errors to the same type using the
same function.

Time to revisit an old friend; the \texttt{try!} macro.

\hyperdef{}{the-real-try-macro}{\subsubsection{\texorpdfstring{The real
\texttt{try!} macro}{The real try! macro}}\label{the-real-try-macro}}

Previously, we presented this definition of \texttt{try!}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{try \{}
    \NormalTok{($e:expr) => (}\KeywordTok{match} \NormalTok{$e \{}
        \ConstantTok{Ok}\NormalTok{(val) => val,}
        \ConstantTok{Err}\NormalTok{(err) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(err),}
    \NormalTok{\});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is not it's real definition. It's real definition is
\href{http://doc.rust-lang.org/std/macro.try!.html}{in the standard
library}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{try \{}
    \NormalTok{($e:expr) => (}\KeywordTok{match} \NormalTok{$e \{}
        \ConstantTok{Ok}\NormalTok{(val) => val,}
        \ConstantTok{Err}\NormalTok{(err) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(::std::convert::From::from(err)),}
    \NormalTok{\});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's one tiny but powerful change: the error value is passed through
\texttt{From::from}. This makes the \texttt{try!} macro a lot more
powerful because it gives you automatic type conversion for free.

Armed with our more powerful \texttt{try!} macro, let's take a look at
code we wrote previously to read a file and convert its contents to an
integer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{String}\NormalTok{> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path).map_err(|e| e.to_string()));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents).map_err(|e| e.to_string()));}
    \KeywordTok{let} \NormalTok{n = }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse::<}\DataTypeTok{i32}\NormalTok{>().map_err(|e| e.to_string()));}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Earlier, we promised that we could get rid of the \texttt{map\_err}
calls. Indeed, all we have to do is pick a type that \texttt{From} works
with. As we saw in the previous section, \texttt{From} has an impl that
let's it convert any error type into a
\texttt{Box\textless{}Error\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::error::Error;}
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{Box}\NormalTok{<Error>> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents));}
    \KeywordTok{let} \NormalTok{n = }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse::<}\DataTypeTok{i32}\NormalTok{>());}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We are getting very close to ideal error handling. Our code has very
little overhead as a result from error handling because the
\texttt{try!} macro encapsulates three things simultaneously:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Case analysis.
\item
  Control flow.
\item
  Error type conversion.
\end{enumerate}

When all three things are combined, we get code that is unencumbered by
combinators, calls to \texttt{unwrap} or case analysis.

There's one little nit left: the
\texttt{Box\textless{}Error\textgreater{}} type is \emph{opaque}. If we
return a \texttt{Box\textless{}Error\textgreater{}} to the caller, the
caller can't (easily) inspect underlying error type. The situation is
certainly better than \texttt{String} because the caller can call
methods like
\href{http://doc.rust-lang.org/std/error/trait.Error.html\#tymethod.description}{\texttt{description}}
and
\href{http://doc.rust-lang.org/std/error/trait.Error.html\#method.cause}{\texttt{cause}},
but the limitation remains: \texttt{Box\textless{}Error\textgreater{}}
is opaque. (N.B. This isn't entirely true because Rust does have runtime
reflection, which is useful in some scenarios that are
\href{https://crates.io/crates/error}{beyond the scope of this
chapter}.)

It's time to revisit our custom \texttt{CliError} type and tie
everything together.

\hyperdef{}{composing-custom-error-types}{\subsubsection{Composing
custom error types}\label{composing-custom-error-types}}

In the last section, we looked at the real \texttt{try!} macro and how
it does automatic type conversion for us by calling \texttt{From::from}
on the error value. In particular, we converted errors to
\texttt{Box\textless{}Error\textgreater{}}, which works, but the type is
opaque to callers.

To fix this, we use the same remedy that we're already familiar with: a
custom error type. Once again, here is the code that reads the contents
of a file and converts it to an integer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::\{}\KeywordTok{self}\NormalTok{, Read\};}
\KeywordTok{use} \NormalTok{std::num;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\CommentTok{// We derive `Debug` because all types should probably derive `Debug`.}
\CommentTok{// This gives us a reasonable human readable description of `CliError` values.}
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{enum} \NormalTok{CliError \{}
    \NormalTok{Io(io::Error),}
    \NormalTok{Parse(num::ParseIntError),}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{file_double_verbose<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, CliError> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path).map_err(CliError::Io));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents).map_err(CliError::Io));}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse().map_err(CliError::Parse));}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that we still have the calls to \texttt{map\_err}. Why? Well,
recall the definitions of \hyperref[code-try-def]{\texttt{try!}} and
\hyperref[code-from-def]{\texttt{From}}. The problem is that there is no
\texttt{From} impl that allows us to convert from error types like
\texttt{io::Error} and \texttt{num::ParseIntError} to our own custom
\texttt{CliError}. Of course, it is easy to fix this! Since we defined
\texttt{CliError}, we can impl \texttt{From} with it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::num;}

\KeywordTok{impl} \NormalTok{From<io::Error> }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{from(err: io::Error) -> CliError \{}
        \NormalTok{CliError::Io(err)}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{From<num::ParseIntError> }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{from(err: num::ParseIntError) -> CliError \{}
        \NormalTok{CliError::Parse(err)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All these impls are doing is teaching \texttt{From} how to create a
\texttt{CliError} from other error types. In our case, construction is
as simple as invoking the corresponding value constructor. Indeed, it is
\emph{typically} this easy.

We can finally rewrite \texttt{file\_double}:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{use} \NormalTok{std::fs::File;}
\KeywordTok{use} \NormalTok{std::io::Read;}
\KeywordTok{use} \NormalTok{std::path::Path;}

\KeywordTok{fn} \NormalTok{file_double<P: AsRef<Path>>(file_path: P) -> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{i32}\NormalTok{, CliError> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(File::open(file_path));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{contents = }\DataTypeTok{String}\NormalTok{::new();}
    \PreprocessorTok{try!}\NormalTok{(file.read_to_string(&}\KeywordTok{mut} \NormalTok{contents));}
    \KeywordTok{let} \NormalTok{n: }\DataTypeTok{i32} \NormalTok{= }\PreprocessorTok{try!}\NormalTok{(contents.trim().parse());}
    \ConstantTok{Ok}\NormalTok{(}\DecValTok{2} \NormalTok{* n)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The only thing we did here was remove the calls to \texttt{map\_err}.
They are no longer needed because the \texttt{try!} macro invokes
\texttt{From::from} on the error value. This works because we've
provided \texttt{From} impls for all the error types that could appear.

If we modified our \texttt{file\_double} function to perform some other
operation, say, convert a string to a float, then we'd need to add a new
variant to our error type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io;}
\KeywordTok{use} \NormalTok{std::num;}

\KeywordTok{enum} \NormalTok{CliError \{}
    \NormalTok{Io(io::Error),}
    \NormalTok{ParseInt(num::ParseIntError),}
    \NormalTok{ParseFloat(num::ParseFloatError),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And add a new \texttt{From} impl:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{use} \NormalTok{std::num;}

\KeywordTok{impl} \NormalTok{From<num::ParseFloatError> }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{from(err: num::ParseFloatError) -> CliError \{}
        \NormalTok{CliError::ParseFloat(err)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And that's it!

\hyperdef{}{advice-for-library-writers}{\subsubsection{Advice for
library writers}\label{advice-for-library-writers}}

If your library needs to report custom errors, then you should probably
define your own error type. It's up to you whether or not to expose its
representation (like
\href{http://doc.rust-lang.org/std/io/enum.ErrorKind.html}{\texttt{ErrorKind}})
or keep it hidden (like
\href{http://doc.rust-lang.org/std/num/struct.ParseIntError.html}{\texttt{ParseIntError}}).
Regardless of how you do it, it's usually good practice to at least
provide some information about the error beyond just its \texttt{String}
representation. But certainly, this will vary depending on use cases.

At a minimum, you should probably implement the
\href{http://doc.rust-lang.org/std/error/trait.Error.html}{\texttt{Error}}
trait. This will give users of your library some minimum flexibility for
\hyperref[the-real-try-macro]{composing errors}. Implementing the
\texttt{Error} trait also means that users are guaranteed the ability to
obtain a string representation of an error (because it requires impls
for both \texttt{fmt::Debug} and \texttt{fmt::Display}).

Beyond that, it can also be useful to provide implementations of
\texttt{From} on your error types. This allows you (the library author)
and your users to \hyperref[composing-custom-error-types]{compose more
detailed errors}. For example,
\href{http://burntsushi.net/rustdoc/csv/enum.Error.html}{\texttt{csv::Error}}
provides \texttt{From} impls for both \texttt{io::Error} and
\texttt{byteorder::Error}.

Finally, depending on your tastes, you may also want to define a
\hyperref[the-result-type-alias-idiom]{\texttt{Result} type alias},
particularly if your library defines a single error type. This is used
in the standard library for
\href{http://doc.rust-lang.org/std/io/type.Result.html}{\texttt{io::Result}}
and
\href{http://doc.rust-lang.org/std/fmt/type.Result.html}{\texttt{fmt::Result}}.

\hyperdef{}{case-study-a-program-to-read-population-data}{\subsection{Case
study: A program to read population
data}\label{case-study-a-program-to-read-population-data}}

This chapter was long, and depending on your background, it might be
rather dense. While there is plenty of example code to go along with the
prose, most of it was specifically designed to be pedagogical. So, we're
going to do something new: a case study.

For this, we're going to build up a command line program that lets you
query world population data. The objective is simple: you give it a
location and it will tell you the population. Despite the simplicity,
there is a lot that can go wrong!

The data we'll be using comes from the
\href{https://github.com/petewarden/dstkdata}{Data Science Toolkit}.
I've prepared some data from it for this exercise. You can either grab
the \href{http://burntsushi.net/stuff/worldcitiespop.csv.gz}{world
population data} (41MB gzip compressed, 145MB uncompressed) or just the
\href{http://burntsushi.net/stuff/uscitiespop.csv.gz}{US population
data} (2.2MB gzip compressed, 7.2MB uncompressed).

Up until now, we've kept the code limited to Rust's standard library.
For a real task like this though, we'll want to at least use something
to parse CSV data, parse the program arguments and decode that stuff
into Rust types automatically. For that, we'll use the
\href{https://crates.io/crates/csv}{\texttt{csv}}, and
\href{https://crates.io/crates/rustc-serialize}{\texttt{rustc-serialize}}
crates.

\hyperdef{}{initial-setup}{\subsubsection{Initial
setup}\label{initial-setup}}

We're not going to spend a lot of time on setting up a project with
Cargo because it is already covered well in
\href{http://doc.rust-lang.org/book/hello-cargo}{the Cargo chapter} and
\href{http://doc.crates.io/guide.html}{Cargo's documentation}.

To get started from scratch, run \texttt{cargo\ new\ -\/-bin\ city-pop}
and make sure your \texttt{Cargo.toml} looks something like this:

\begin{verbatim}
[package]
name = "city-pop"
version = "0.1.0"
authors = ["Andrew Gallant <jamslam@gmail.com>"]

[[bin]]
name = "city-pop"

[dependencies]
csv = "0.*"
rustc-serialize = "0.*"
getopts = "0.*"
\end{verbatim}

You should already be able to run:

\begin{verbatim}
cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
\end{verbatim}

\hyperdef{}{argument-parsing}{\subsubsection{Argument
parsing}\label{argument-parsing}}

Let's get argument parsing out of the way. we won't go into too much
detail on Getopts, but there is
\href{http://doc.rust-lang.org/getopts/getopts/index.html}{some good
documentation} describing it. The short story is that Getopts generates
an argument parser and a help message from a vector of options (The fact
that it is a vector is hidden behind a struct and a set of methods).
Once the parsing is done, we can decode the program arguments into a
Rust struct. From there, we can get information about the flags, for
instance, wether they were passed in, and what arguments they had.
Here's our program with the appropriate \texttt{extern\ crate}
statements, and the basic argument setup for Getopts:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{getopts;}
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{rustc_serialize;}

\KeywordTok{use} \NormalTok{getopts::Options;}
\KeywordTok{use} \NormalTok{std::env;}

\KeywordTok{fn} \NormalTok{print_usage(program: &}\DataTypeTok{str}\NormalTok{, opts: Options) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, opts.usage(&}\PreprocessorTok{format!}\NormalTok{(}\StringTok{"Usage: \{\} [options] <data-path> <city>"}\NormalTok{, progr}
\NormalTok{‚Ü≥ am)));}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{args: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{String}\NormalTok{> = env::args().collect();}
    \KeywordTok{let} \NormalTok{program = args[}\DecValTok{0}\NormalTok{].clone();}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{opts = Options::new();}
    \NormalTok{opts.optflag(}\StringTok{"h"}\NormalTok{, }\StringTok{"help"}\NormalTok{, }\StringTok{"Show this usage message."}\NormalTok{);}
    
    \KeywordTok{let} \NormalTok{matches = }\KeywordTok{match} \NormalTok{opts.parse(&args[}\DecValTok{1.}\NormalTok{.]) \{}
        \ConstantTok{Ok}\NormalTok{(m)  => \{ m \}}
    \ConstantTok{Err}\NormalTok{(e) => \{ }\PreprocessorTok{panic!}\NormalTok{(e.to_string()) \}}
    \NormalTok{\};}
    \KeywordTok{if} \NormalTok{matches.opt_present(}\StringTok{"h"}\NormalTok{) \{}
        \NormalTok{print_usage(&program, opts);}
    \KeywordTok{return}\NormalTok{;}
    \NormalTok{\}}
    \KeywordTok{let} \NormalTok{data_path = args[}\DecValTok{1}\NormalTok{].clone();}
    \KeywordTok{let} \NormalTok{city = args[}\DecValTok{2}\NormalTok{].clone();}
    
    \CommentTok{// Do stuff with information}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

First, we get a vector of the arguments passed into our program. We then
store the first one, knowing that it is our program's name. Once that's
done, we set up our argument flags, in this case a simplistic help
message flag. Once we have the argument flags set up, we use
\texttt{Options.parse} to parse the argument vector (starting from index
one, becouse index 0 is the program name). If this was successful, we
assign matches to the parsed object, if not, we panic. Once past that,
we test if the user passed in the help flag, and if so print the usage
message. The option help messages are constructed by Getopts, so all we
have to do to print the usage message is tell it what we want it to
print for the program name and template. If the user has not passed in
the help flag, we assign the proper variables to their corresponding
arguments.

\hyperdef{}{writing-the-logic}{\subsubsection{Writing the
logic}\label{writing-the-logic}}

We're all different in how we write code, but error handling is usually
the last thing we want to think about. This isn't very good practice for
good design, but it can be useful for rapidly prototyping. In our case,
because Rust forces us to be explicit about error handling, it will also
make it obvious what parts of our program can cause errors. Why? Because
Rust will make us call \texttt{unwrap}! This can give us a nice bird's
eye view of how we need to approach error handling.

In this case study, the logic is really simple. All we need to do is
parse the CSV data given to us and print out a field in matching rows.
Let's do it. (Make sure to add \texttt{extern\ crate\ csv;} to the top
of your file.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// This struct represents the data in each row of the CSV file.}
\CommentTok{// Type based decoding absolves us of a lot of the nitty gritty error}
\CommentTok{// handling, like parsing strings as integers or floats.}
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{,} \NormalTok{RustcDecodable}\AttributeTok{)]}
\KeywordTok{struct} \NormalTok{Row \{}
    \NormalTok{country: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{city: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{accent_city: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{region: }\DataTypeTok{String}\NormalTok{,}

    \CommentTok{// Not every row has data for the population, latitude or longitude!}
    \CommentTok{// So we express them as `Option` types, which admits the possibility of}
    \CommentTok{// absence. The CSV parser will fill in the correct value for us.}
    \NormalTok{population: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{u64}\NormalTok{>,}
    \NormalTok{latitude: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{f64}\NormalTok{>,}
    \NormalTok{longitude: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{f64}\NormalTok{>,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{print_usage(program: &}\DataTypeTok{str}\NormalTok{, opts: Options) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, opts.usage(&}\PreprocessorTok{format!}\NormalTok{(}\StringTok{"Usage: \{\} [options] <data-path> <city>"}\NormalTok{, progr}
\NormalTok{‚Ü≥ am)));}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{args: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{String}\NormalTok{> = env::args().collect();}
    \KeywordTok{let} \NormalTok{program = args[}\DecValTok{0}\NormalTok{].clone();}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{opts = Options::new();}
    \NormalTok{opts.optflag(}\StringTok{"h"}\NormalTok{, }\StringTok{"help"}\NormalTok{, }\StringTok{"Show this usage message."}\NormalTok{);}
    
    \KeywordTok{let} \NormalTok{matches = }\KeywordTok{match} \NormalTok{opts.parse(&args[}\DecValTok{1.}\NormalTok{.]) \{}
        \ConstantTok{Ok}\NormalTok{(m)  => \{ m \}}
        \ConstantTok{Err}\NormalTok{(e) => \{ }\PreprocessorTok{panic!}\NormalTok{(e.to_string()) \}}
    \NormalTok{\};}
    
    \KeywordTok{if} \NormalTok{matches.opt_present(}\StringTok{"h"}\NormalTok{) \{}
        \NormalTok{print_usage(&program, opts);}
        \KeywordTok{return}\NormalTok{;}
    \NormalTok{\}}
        
    \KeywordTok{let} \NormalTok{data_file = args[}\DecValTok{1}\NormalTok{].clone();}
    \KeywordTok{let} \NormalTok{data_path = Path::new(&data_file);}
    \KeywordTok{let} \NormalTok{city = args[}\DecValTok{2}\NormalTok{].clone();}
    
    \KeywordTok{let} \NormalTok{file = fs::File::open(data_path).unwrap();}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{rdr = csv::Reader::from_reader(file);}
    
    \KeywordTok{for} \NormalTok{row }\KeywordTok{in} \NormalTok{rdr.decode::<Row>() \{}
        \KeywordTok{let} \NormalTok{row = row.unwrap();}
    
        \KeywordTok{if} \NormalTok{row.city == city \{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}, \{\}: \{:?\}"}\NormalTok{,}
                \NormalTok{row.city, row.country,}
                \NormalTok{row.population.expect(}\StringTok{"population count"}\NormalTok{));}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's outline the errors. We can start with the obvious: the three
places that \texttt{unwrap} is called:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{http://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{\texttt{fs::File::open}}
  can return an
  \href{http://doc.rust-lang.org/std/io/struct.Error.html}{\texttt{io::Error}}.
\item
  \href{http://burntsushi.net/rustdoc/csv/struct.Reader.html\#method.decode}{\texttt{csv::Reader::decode}}
  decodes one record at a time, and
  \href{http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html}{decoding
  a record} (look at the \texttt{Item} associated type on the
  \texttt{Iterator} impl) can produce a
  \href{http://burntsushi.net/rustdoc/csv/enum.Error.html}{\texttt{csv::Error}}.
\item
  If \texttt{row.population} is \texttt{None}, then calling
  \texttt{expect} will panic.
\end{enumerate}

Are there any others? What if we can't find a matching city? Tools like
\texttt{grep} will return an error code, so we probably should too. So
we have logic errors specific to our problem, IO errors and CSV parsing
errors. We're going to explore two different ways to approach handling
these errors.

I'd like to start with \texttt{Box\textless{}Error\textgreater{}}.
Later, we'll see how defining our own error type can be useful.

\hyperdef{}{error-handling-with-boxerror}{\subsubsection{\texorpdfstring{Error
handling with
\texttt{Box\textless{}Error\textgreater{}}}{Error handling with Box\textless{}Error\textgreater{}}}\label{error-handling-with-boxerror}}

\texttt{Box\textless{}Error\textgreater{}} is nice because it \emph{just
works}. You don't need to define your own error types and you don't need
any \texttt{From} implementations. The downside is that since
\texttt{Box\textless{}Error\textgreater{}} is a trait object, it
\emph{erases the type}, which means the compiler can no longer reason
about its underlying type.

\hyperref[the-limits-of-combinators]{Previously} we started refactoring
our code by changing the type of our function from \texttt{T} to
\texttt{Result\textless{}T,\ OurErrorType\textgreater{}}. In this case,
\texttt{OurErrorType} is just
\texttt{Box\textless{}Error\textgreater{}}. But what's \texttt{T}? And
can we add a return type to \texttt{main}?

The answer to the second question is no, we can't. That means we'll need
to write a new function. But what is \texttt{T}? The simplest thing we
can do is to return a list of matching \texttt{Row} values as a
\texttt{Vec\textless{}Row\textgreater{}}. (Better code would return an
iterator, but that is left as an exercise to the reader.)

Let's refactor our code into its own function, but keep the calls to
\texttt{unwrap}. Note that we opt to handle the possibility of a missing
population count by simply ignoring that row.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Row \{}
    \CommentTok{// unchanged}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{PopulationCount \{}
    \NormalTok{city: }\DataTypeTok{String}\NormalTok{,}
    \NormalTok{country: }\DataTypeTok{String}\NormalTok{,}
    \CommentTok{// This is no longer an `Option` because values of this type are only}
    \CommentTok{// constructed if they have a population count.}
    \NormalTok{count: }\DataTypeTok{u64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{print_usage(program: &}\DataTypeTok{str}\NormalTok{, opts: Options) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, opts.usage(&}\PreprocessorTok{format!}\NormalTok{(}\StringTok{"Usage: \{\} [options] <data-path> <city>"}\NormalTok{, progr}
\NormalTok{‚Ü≥ am)));}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{search<P: AsRef<Path>>(file_path: P, city: &}\DataTypeTok{str}\NormalTok{) -> }\DataTypeTok{Vec}\NormalTok{<PopulationCount> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{found = }\PreprocessorTok{vec!}\NormalTok{[];}
    \KeywordTok{let} \NormalTok{file = fs::File::open(file_path).unwrap();}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{rdr = csv::Reader::from_reader(file);}
    \KeywordTok{for} \NormalTok{row }\KeywordTok{in} \NormalTok{rdr.decode::<Row>() \{}
        \KeywordTok{let} \NormalTok{row = row.unwrap();}
        \KeywordTok{match} \NormalTok{row.population \{}
            \ConstantTok{None} \NormalTok{=> \{ \} }\CommentTok{// skip it}
            \ConstantTok{Some}\NormalTok{(count) => }\KeywordTok{if} \NormalTok{row.city == city \{}
                \NormalTok{found.push(PopulationCount \{}
                    \NormalTok{city: row.city,}
                    \NormalTok{country: row.country,}
                    \NormalTok{count: count,}
                \NormalTok{\});}
            \NormalTok{\},}
        \NormalTok{\}}
    \NormalTok{\}}
    \NormalTok{found}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{args: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{String}\NormalTok{> = env::args().collect();}
    \KeywordTok{let} \NormalTok{program = args[}\DecValTok{0}\NormalTok{].clone();}

    \KeywordTok{let} \KeywordTok{mut} \NormalTok{opts = Options::new();}
    \NormalTok{opts.optflag(}\StringTok{"h"}\NormalTok{, }\StringTok{"help"}\NormalTok{, }\StringTok{"Show this usage message."}\NormalTok{);}

    \KeywordTok{let} \NormalTok{matches = }\KeywordTok{match} \NormalTok{opts.parse(&args[}\DecValTok{1.}\NormalTok{.]) \{}
        \ConstantTok{Ok}\NormalTok{(m)  => \{ m \}}
        \ConstantTok{Err}\NormalTok{(e) => \{ }\PreprocessorTok{panic!}\NormalTok{(e.to_string()) \}}
    \NormalTok{\};}
    \KeywordTok{if} \NormalTok{matches.opt_present(}\StringTok{"h"}\NormalTok{) \{}
        \NormalTok{print_usage(&program, opts);}
        \KeywordTok{return}\NormalTok{;}
    \NormalTok{\}}
        
    \KeywordTok{let} \NormalTok{data_file = args[}\DecValTok{1}\NormalTok{].clone();}
    \KeywordTok{let} \NormalTok{data_path = Path::new(&data_file);}
    \KeywordTok{let} \NormalTok{city = args[}\DecValTok{2}\NormalTok{].clone();}
    \KeywordTok{for} \NormalTok{pop }\KeywordTok{in} \NormalTok{search(&data_path, &city) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}, \{\}: \{:?\}"}\NormalTok{, pop.city, pop.country, pop.count);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

While we got rid of one use of \texttt{expect} (which is a nicer variant
of \texttt{unwrap}), we still should handle the absence of any search
results.

To convert this to proper error handling, we need to do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Change the return type of \texttt{search} to be
  \texttt{Result\textless{}Vec\textless{}PopulationCount\textgreater{},\ \ \ \ Box\textless{}Error\textgreater{}\textgreater{}}.
\item
  Use the \hyperref[code-try-def]{\texttt{try!} macro} so that errors
  are returned to the caller instead of panicking the program.
\item
  Handle the error in \texttt{main}.
\end{enumerate}

Let's try it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{search<P: AsRef<Path>>}
         \NormalTok{(file_path: P, city: &}\DataTypeTok{str}\NormalTok{)}
         \NormalTok{-> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{Vec}\NormalTok{<PopulationCount>, }\DataTypeTok{Box}\NormalTok{<Error+}\BuiltInTok{Send}\NormalTok{+}\BuiltInTok{Sync}\NormalTok{>> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{found = }\PreprocessorTok{vec!}\NormalTok{[];}
    \KeywordTok{let} \NormalTok{file = }\PreprocessorTok{try!}\NormalTok{(fs::File::open(file_path));}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{rdr = csv::Reader::from_reader(file);}
    \KeywordTok{for} \NormalTok{row }\KeywordTok{in} \NormalTok{rdr.decode::<Row>() \{}
        \KeywordTok{let} \NormalTok{row = }\PreprocessorTok{try!}\NormalTok{(row);}
        \KeywordTok{match} \NormalTok{row.population \{}
            \ConstantTok{None} \NormalTok{=> \{ \} }\CommentTok{// skip it}
            \ConstantTok{Some}\NormalTok{(count) => }\KeywordTok{if} \NormalTok{row.city == city \{}
                \NormalTok{found.push(PopulationCount \{}
                    \NormalTok{city: row.city,}
                    \NormalTok{country: row.country,}
                    \NormalTok{count: count,}
                \NormalTok{\});}
            \NormalTok{\},}
        \NormalTok{\}}
    \NormalTok{\}}
    \KeywordTok{if} \NormalTok{found.is_empty() \{}
        \ConstantTok{Err}\NormalTok{(From::from(}\StringTok{"No matching cities with a population were found."}\NormalTok{))}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
        \ConstantTok{Ok}\NormalTok{(found)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Instead of \texttt{x.unwrap()}, we now have \texttt{try!(x)}. Since our
function returns a \texttt{Result\textless{}T,\ E\textgreater{}}, the
\texttt{try!} macro will return early from the function if an error
occurs.

There is one big gotcha in this code: we used
\texttt{Box\textless{}Error\ +\ Send\ +\ Sync\textgreater{}} instead of
\texttt{Box\textless{}Error\textgreater{}}. We did this so we could
convert a plain string to an error type. We need these extra bounds so
that we can use the
\href{http://doc.rust-lang.org/std/convert/trait.From.html}{corresponding
\texttt{From} impls}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// We are making use of this impl in the code above, since we call `From::from`}
\CommentTok{// on a `&'static str`.}
\KeywordTok{impl}\NormalTok{<}\OtherTok{'a}\NormalTok{, }\OtherTok{'b}\NormalTok{> From<&}\OtherTok{'b} \DataTypeTok{str}\NormalTok{> }\KeywordTok{for} \DataTypeTok{Box}\NormalTok{<Error + }\BuiltInTok{Send} \NormalTok{+ }\BuiltInTok{Sync} \NormalTok{+ }\OtherTok{'a}\NormalTok{>}

\CommentTok{// But this is also useful when you need to allocate a new string for an}
\CommentTok{// error message, usually with `format!`.}
\KeywordTok{impl} \NormalTok{From<}\DataTypeTok{String}\NormalTok{> }\KeywordTok{for} \DataTypeTok{Box}\NormalTok{<Error + }\BuiltInTok{Send} \NormalTok{+ }\BuiltInTok{Sync}\NormalTok{>}
\end{Highlighting}
\end{Shaded}

Now that we've seen how to do proper error handling with
\texttt{Box\textless{}Error\textgreater{}}, let's try a different
approach with our own custom error type. But first, let's take a quick
break from error handling and add support for reading from
\texttt{stdin}.

\hyperdef{}{reading-from-stdin}{\subsubsection{Reading from
stdin}\label{reading-from-stdin}}

In our program, we accept a single file for input and do one pass over
the data. This means we probably should be able to accept input on
stdin. But maybe we like the current format too---so let's have both!

Adding support for stdin is actually quite easy. There are only two
things we have to do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Tweak the program arguments so that a single parameter---the
  city---can be accepted while the population data is read from stdin.
\item
  Modify the program so that an option \texttt{-f} can take the file, if
  it is not passed into stdin.
\item
  Modify the \texttt{search} function to take an \emph{optional} file
  path. When \texttt{None}, it should know to read from stdin.
\end{enumerate}

First, here's the new usage:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print_usage(program: &}\DataTypeTok{str}\NormalTok{, opts: Options) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, opts.usage(&}\PreprocessorTok{format!}\NormalTok{(}\StringTok{"Usage: \{\} [options] <city>"}\NormalTok{, program)));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The next part is going to be only a little harder:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{opts = Options::new();}
\NormalTok{opts.optopt(}\StringTok{"f"}\NormalTok{, }\StringTok{"file"}\NormalTok{, }\StringTok{"Choose an input file, instead of using STDIN."}\NormalTok{, }\StringTok{"NAME"}\NormalTok{);}
\NormalTok{opts.optflag(}\StringTok{"h"}\NormalTok{, }\StringTok{"help"}\NormalTok{, }\StringTok{"Show this usage message."}\NormalTok{);}
\NormalTok{...}
\KeywordTok{let} \NormalTok{file = matches.opt_str(}\StringTok{"f"}\NormalTok{);}
\KeywordTok{let} \NormalTok{data_file = file.as_ref().map(Path::new);}
    
\KeywordTok{let} \NormalTok{city = }\KeywordTok{if} \NormalTok{!matches.free.is_empty() \{}
    \NormalTok{matches.free[}\DecValTok{0}\NormalTok{].clone()}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \NormalTok{print_usage(&program, opts);}
    \KeywordTok{return}\NormalTok{;}
\NormalTok{\};}

\KeywordTok{for} \NormalTok{pop }\KeywordTok{in} \NormalTok{search(&data_file, &city) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}, \{\}: \{:?\}"}\NormalTok{, pop.city, pop.country, pop.count);}
\NormalTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

In this peice of code, we take \texttt{file} (which has the type
\texttt{Option\textless{}String\textgreater{}}), and convert it to a
type that \texttt{search} can use, in this case,
\texttt{\&Option\textless{}AsRef\textless{}Path\textgreater{}\textgreater{}}.
Do do this, we take a reference of file, and map \texttt{Path::new} onto
it. In this case, \texttt{as\_ref()} converts the
\texttt{Option\textless{}String\textgreater{}} into an
\texttt{Option\textless{}\&str\textgreater{}}, and from there, we can
execute \texttt{Path::new} to the content of the optional, and return
the optional of the new value. Once we have that, it is a simple matter
of getting the \texttt{city} argument and executing \texttt{search}.

Modifying \texttt{search} is slightly trickier. The \texttt{csv} crate
can build a parser out of
\href{http://burntsushi.net/rustdoc/csv/struct.Reader.html\#method.from_reader}{any
type that implements \texttt{io::Read}}. But how can we use the same
code over both types? There's actually a couple ways we could go about
this. One way is to write \texttt{search} such that it is generic on
some type parameter \texttt{R} that satisfies \texttt{io::Read}. Another
way is to just use trait objects:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{search<P: AsRef<Path>>}
         \NormalTok{(file_path: &}\DataTypeTok{Option}\NormalTok{<P>, city: &}\DataTypeTok{str}\NormalTok{)}
         \NormalTok{-> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{Vec}\NormalTok{<PopulationCount>, }\DataTypeTok{Box}\NormalTok{<Error+}\BuiltInTok{Send}\NormalTok{+}\BuiltInTok{Sync}\NormalTok{>> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{found = }\PreprocessorTok{vec!}\NormalTok{[];}
    \KeywordTok{let} \NormalTok{input: }\DataTypeTok{Box}\NormalTok{<io::Read> = }\KeywordTok{match} \NormalTok{*file_path \{}
        \ConstantTok{None} \NormalTok{=> }\DataTypeTok{Box}\NormalTok{::new(io::stdin()),}
        \ConstantTok{Some}\NormalTok{(}\KeywordTok{ref} \NormalTok{file_path) => }\DataTypeTok{Box}\NormalTok{::new(}\PreprocessorTok{try!}\NormalTok{(fs::File::open(file_path))),}
    \NormalTok{\};}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{rdr = csv::Reader::from_reader(input);}
    \CommentTok{// The rest remains unchanged!}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{error-handling-with-a-custom-type}{\subsubsection{Error
handling with a custom type}\label{error-handling-with-a-custom-type}}

Previously, we learned how to
\hyperref[composing-custom-error-types]{compose errors using a custom
error type}. We did this by defining our error type as an \texttt{enum}
and implementing \texttt{Error} and \texttt{From}.

Since we have three distinct errors (IO, CSV parsing and not found),
let's define an \texttt{enum} with three variants:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{enum} \NormalTok{CliError \{}
    \NormalTok{Io(io::Error),}
    \NormalTok{Csv(csv::Error),}
    \NormalTok{NotFound,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And now for impls on \texttt{Display} and \texttt{Error}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{fmt::}\BuiltInTok{Display} \KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{fmt(&}\KeywordTok{self}\NormalTok{, f: &}\KeywordTok{mut} \NormalTok{fmt::Formatter) -> fmt::}\DataTypeTok{Result} \NormalTok{\{}
        \KeywordTok{match} \NormalTok{*}\KeywordTok{self} \NormalTok{\{}
            \NormalTok{CliError::Io(}\KeywordTok{ref} \NormalTok{err) => err.fmt(f),}
            \NormalTok{CliError::Csv(}\KeywordTok{ref} \NormalTok{err) => err.fmt(f),}
            \NormalTok{CliError::NotFound => }\PreprocessorTok{write!}\NormalTok{(f, }\StringTok{"No matching cities with a }\SpecialCharTok{\textbackslash{}}
\StringTok{                                             population were found."}\NormalTok{),}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Error }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{description(&}\KeywordTok{self}\NormalTok{) -> &}\DataTypeTok{str} \NormalTok{\{}
        \KeywordTok{match} \NormalTok{*}\KeywordTok{self} \NormalTok{\{}
            \NormalTok{CliError::Io(}\KeywordTok{ref} \NormalTok{err) => err.description(),}
            \NormalTok{CliError::Csv(}\KeywordTok{ref} \NormalTok{err) => err.description(),}
            \NormalTok{CliError::NotFound => }\StringTok{"not found"}\NormalTok{,}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Before we can use our \texttt{CliError} type in our \texttt{search}
function, we need to provide a couple \texttt{From} impls. How do we
know which impls to provide? Well, we'll need to convert from both
\texttt{io::Error} and \texttt{csv::Error} to \texttt{CliError}. Those
are the only external errors, so we'll only need two \texttt{From} impls
for now:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{From<io::Error> }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{from(err: io::Error) -> CliError \{}
        \NormalTok{CliError::Io(err)}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{From<csv::Error> }\KeywordTok{for} \NormalTok{CliError \{}
    \KeywordTok{fn} \NormalTok{from(err: csv::Error) -> CliError \{}
        \NormalTok{CliError::Csv(err)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{From} impls are important because of how
\hyperref[code-try-def]{\texttt{try!} is defined}. In particular, if an
error occurs, \texttt{From::from} is called on the error, which in this
case, will convert it to our own error type \texttt{CliError}.

With the \texttt{From} impls done, we only need to make two small tweaks
to our \texttt{search} function: the return type and the ``not found''
error. Here it is in full:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{search<P: AsRef<Path>>}
         \NormalTok{(file_path: &}\DataTypeTok{Option}\NormalTok{<P>, city: &}\DataTypeTok{str}\NormalTok{)}
         \NormalTok{-> }\DataTypeTok{Result}\NormalTok{<}\DataTypeTok{Vec}\NormalTok{<PopulationCount>, CliError> \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{found = }\PreprocessorTok{vec!}\NormalTok{[];}
    \KeywordTok{let} \NormalTok{input: }\DataTypeTok{Box}\NormalTok{<io::Read> = }\KeywordTok{match} \NormalTok{*file_path \{}
        \ConstantTok{None} \NormalTok{=> }\DataTypeTok{Box}\NormalTok{::new(io::stdin()),}
        \ConstantTok{Some}\NormalTok{(}\KeywordTok{ref} \NormalTok{file_path) => }\DataTypeTok{Box}\NormalTok{::new(}\PreprocessorTok{try!}\NormalTok{(fs::File::open(file_path))),}
    \NormalTok{\};}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{rdr = csv::Reader::from_reader(input);}
    \KeywordTok{for} \NormalTok{row }\KeywordTok{in} \NormalTok{rdr.decode::<Row>() \{}
        \KeywordTok{let} \NormalTok{row = }\PreprocessorTok{try!}\NormalTok{(row);}
        \KeywordTok{match} \NormalTok{row.population \{}
            \ConstantTok{None} \NormalTok{=> \{ \} }\CommentTok{// skip it}
            \ConstantTok{Some}\NormalTok{(count) => }\KeywordTok{if} \NormalTok{row.city == city \{}
                \NormalTok{found.push(PopulationCount \{}
                    \NormalTok{city: row.city,}
                    \NormalTok{country: row.country,}
                    \NormalTok{count: count,}
                \NormalTok{\});}
            \NormalTok{\},}
        \NormalTok{\}}
    \NormalTok{\}}
    \KeywordTok{if} \NormalTok{found.is_empty() \{}
        \ConstantTok{Err}\NormalTok{(CliError::NotFound)}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
        \ConstantTok{Ok}\NormalTok{(found)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

No other changes are necessary.

\hyperdef{}{adding-functionality}{\subsubsection{Adding
functionality}\label{adding-functionality}}

Writing generic code is great, because generalizing stuff is cool, and
it can then be useful later. But sometimes, the juice isn't worth the
squeeze. Look at what we just did in the previous step:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Defined a new error type.
\item
  Added impls for \texttt{Error}, \texttt{Display} and two for
  \texttt{From}.
\end{enumerate}

The big downside here is that our program didn't improve a whole lot.
There is quite a bit of overhead to representing errors with
\texttt{enum}s, especially in short programs like this.

\emph{One} useful aspect of using a custom error type like we've done
here is that the \texttt{main} function can now choose to handle errors
differently. Previously, with
\texttt{Box\textless{}Error\textgreater{}}, it didn't have much of a
choice: just print the message. We're still doing that here, but what if
we wanted to, say, add a \texttt{-\/-quiet} flag? The \texttt{-\/-quiet}
flag should silence any verbose output.

Right now, if the program doesn't find a match, it will output a message
saying so. This can be a little clumsy, especially if you intend for the
program to be used in shell scripts.

So let's start by adding the flags. Like before, we need to tweak the
usage string and add a flag to the Option variable. Once were done that,
Getopts does the rest:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{opts = Options::new();}
\NormalTok{opts.optopt(}\StringTok{"f"}\NormalTok{, }\StringTok{"file"}\NormalTok{, }\StringTok{"Choose an input file, instead of using STDIN."}\NormalTok{, }\StringTok{"NAME"}\NormalTok{);}
\NormalTok{opts.optflag(}\StringTok{"h"}\NormalTok{, }\StringTok{"help"}\NormalTok{, }\StringTok{"Show this usage message."}\NormalTok{);}
\NormalTok{opts.optflag(}\StringTok{"q"}\NormalTok{, }\StringTok{"quit"}\NormalTok{, }\StringTok{"Silences errors and warnings."}\NormalTok{);}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Now we just need to implement our ``quiet'' functionality. This requires
us to tweak the case analysis in \texttt{main}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{search(&args.arg_data_path, &args.arg_city) \{}
    \ConstantTok{Err}\NormalTok{(CliError::NotFound) }\KeywordTok{if} \NormalTok{args.flag_quiet => process::exit(}\DecValTok{1}\NormalTok{),}
    \ConstantTok{Err}\NormalTok{(err) => }\PreprocessorTok{fatal!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, err),}
    \ConstantTok{Ok}\NormalTok{(pops) => }\KeywordTok{for} \NormalTok{pop }\KeywordTok{in} \NormalTok{pops \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}, \{\}: \{:?\}"}\NormalTok{, pop.city, pop.country, pop.count);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Certainly, we don't want to be quiet if there was an IO error or if the
data failed to parse. Therefore, we use case analysis to check if the
error type is \texttt{NotFound} \emph{and} if \texttt{-\/-quiet} has
been enabled. If the search failed, we still quit with an exit code
(following \texttt{grep}'s convention).

If we had stuck with \texttt{Box\textless{}Error\textgreater{}}, then it
would be pretty tricky to implement the \texttt{-\/-quiet}
functionality.

This pretty much sums up our case study. From here, you should be ready
to go out into the world and write your own programs and libraries with
proper error handling.

\hyperdef{}{the-short-story}{\subsection{The Short
Story}\label{the-short-story}}

Since this chapter is long, it is useful to have a quick summary for
error handling in Rust. These are some good ``rules of thumb.'' They are
emphatically \emph{not} commandments. There are probably good reasons to
break every one of these heuristics!

\begin{itemize}
\tightlist
\item
  If you're writing short example code that would be overburdened by
  error handling, it's probably just fine to use \texttt{unwrap}
  (whether that's
  \href{http://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap}{\texttt{Result::unwrap}},
  \href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap}{\texttt{Option::unwrap}}
  or preferably
  \href{http://doc.rust-lang.org/std/option/enum.Option.html\#method.expect}{\texttt{Option::expect}}).
  Consumers of your code should know to use proper error handling. (If
  they don't, send them here!)
\item
  If you're writing a quick `n' dirty program, don't feel ashamed if you
  use \texttt{unwrap}. Be warned: if it winds up in someone else's
  hands, don't be surprised if they are agitated by poor error messages!
\item
  If you're writing a quick `n' dirty program and feel ashamed about
  panicking anyway, then using either a \texttt{String} or a
  \texttt{Box\textless{}Error\ +\ Send\ +\ Sync\textgreater{}} for your
  error type (the
  \texttt{Box\textless{}Error\ +\ Send\ +\ Sync\textgreater{}} type is
  because of the
  \href{http://doc.rust-lang.org/std/convert/trait.From.html}{available
  \texttt{From} impls}).
\item
  Otherwise, in a program, define your own error types with appropriate
  \href{http://doc.rust-lang.org/std/convert/trait.From.html}{\texttt{From}}
  and
  \href{http://doc.rust-lang.org/std/error/trait.Error.html}{\texttt{Error}}
  impls to make the
  \href{http://doc.rust-lang.org/std/macro.try!.html}{\texttt{try!}}
  macro more ergnomic.
\item
  If you're writing a library and your code can produce errors, define
  your own error type and implement the
  \href{http://doc.rust-lang.org/std/error/trait.Error.html}{\texttt{std::error::Error}}
  trait. Where appropriate, implement
  \href{http://doc.rust-lang.org/std/convert/trait.From.html}{\texttt{From}}
  to make both your library code and the caller's code easier to write.
  (Because of Rust's coherence rules, callers will not be able to impl
  \texttt{From} on your error type, so your library should do it.)
\item
  Learn the combinators defined on
  \href{http://doc.rust-lang.org/std/option/enum.Option.html}{\texttt{Option}}
  and
  \href{http://doc.rust-lang.org/std/result/enum.Result.html}{\texttt{Result}}.
  Using them exclusively can be a bit tiring at times, but I've
  personally found a healthy mix of \texttt{try!} and combinators to be
  quite appealing. \texttt{and\_then}, \texttt{map} and
  \texttt{unwrap\_or} are my favorites.
\end{itemize}

\section{Choosing your Guarantees}\label{sec--choosing-your-guarantees}

One important feature of Rust is that it lets us control the costs and
guarantees of a program.

There are various ``wrapper type'' abstractions in the Rust standard
library which embody a multitude of tradeoffs between cost, ergonomics,
and guarantees. Many let one choose between run time and compile time
enforcement. This section will explain a few selected abstractions in
detail.

Before proceeding, it is highly recommended that one reads about
\hyperref[sec--ownership]{ownership} and
\hyperref[sec--references-and-borrowing]{borrowing} in Rust.

\subsection{Basic pointer types}\label{basic-pointer-types}

\subsubsection{\texorpdfstring{\texttt{Box\textless{}T\textgreater{}}}{Box\textless{}T\textgreater{}}}\label{boxt}

\href{http://doc.rust-lang.org/std/boxed/struct.Box.html}{\texttt{Box\textless{}T\textgreater{}}}
is an ``owned'' pointer, or a ``box''. While it can hand out references
to the contained data, it is the only owner of the data. In particular,
consider the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DataTypeTok{Box}\NormalTok{::new(}\DecValTok{1}\NormalTok{);}
\KeywordTok{let} \NormalTok{y = x;}
\CommentTok{// x no longer accessible here}
\end{Highlighting}
\end{Shaded}

Here, the box was \emph{moved} into \texttt{y}. As \texttt{x} no longer
owns it, the compiler will no longer allow the programmer to use
\texttt{x} after this. A box can similarly be moved \emph{out} of a
function by returning it.

When a box (that hasn't been moved) goes out of scope, destructors are
run. These destructors take care of deallocating the inner data.

This is a zero-cost abstraction for dynamic allocation. If you want to
allocate some memory on the heap and safely pass around a pointer to
that memory, this is ideal. Note that you will only be allowed to share
references to this by the regular borrowing rules, checked at compile
time.

\subsubsection{\texorpdfstring{\texttt{\&T} and
\texttt{\&mut\ T}}{\&T and \&mut T}}\label{t-and-mut-t}

These are immutable and mutable references respectively. They follow the
``read-write lock'' pattern, such that one may either have only one
mutable reference to some data, or any number of immutable ones, but not
both. This guarantee is enforced at compile time, and has no visible
cost at runtime. In most cases these two pointer types suffice for
sharing cheap references between sections of code.

These pointers cannot be copied in such a way that they outlive the
lifetime associated with them.

\subsubsection{\texorpdfstring{\texttt{*const\ T} and
\texttt{*mut\ T}}{*const T and *mut T}}\label{const-t-and-mut-t}

These are C-like raw pointers with no lifetime or ownership attached to
them. They just point to some location in memory with no other
restrictions. The only guarantee that these provide is that they cannot
be dereferenced except in code marked \texttt{unsafe}.

These are useful when building safe, low cost abstractions like
\texttt{Vec\textless{}T\textgreater{}}, but should be avoided in safe
code.

\subsubsection{\texorpdfstring{\texttt{Rc\textless{}T\textgreater{}}}{Rc\textless{}T\textgreater{}}}\label{rct}

This is the first wrapper we will cover that has a runtime cost.

\href{http://doc.rust-lang.org/std/rc/struct.Rc.html}{\texttt{Rc\textless{}T\textgreater{}}}
is a reference counted pointer. In other words, this lets us have
multiple ``owning'' pointers to the same data, and the data will be
dropped (destructors will be run) when all pointers are out of scope.

Internally, it contains a shared ``reference count'' (also called
``refcount''), which is incremented each time the \texttt{Rc} is cloned,
and decremented each time one of the \texttt{Rc}s goes out of scope. The
main responsibility of \texttt{Rc\textless{}T\textgreater{}} is to
ensure that destructors are called for shared data.

The internal data here is immutable, and if a cycle of references is
created, the data will be leaked. If we want data that doesn't leak when
there are cycles, we need a garbage collector.

\subparagraph{Guarantees}\label{guarantees}

The main guarantee provided here is that the data will not be destroyed
until all references to it are out of scope.

This should be used when we wish to dynamically allocate and share some
data (read-only) between various portions of your program, where it is
not certain which portion will finish using the pointer last. It's a
viable alternative to \texttt{\&T} when \texttt{\&T} is either
impossible to statically check for correctness, or creates extremely
unergonomic code where the programmer does not wish to spend the
development cost of working with.

This pointer is \emph{not} thread safe, and Rust will not let it be sent
or shared with other threads. This lets one avoid the cost of atomics in
situations where they are unnecessary.

There is a sister smart pointer to this one,
\texttt{Weak\textless{}T\textgreater{}}. This is a non-owning, but also
non-borrowed, smart pointer. It is also similar to \texttt{\&T}, but it
is not restricted in lifetime---a
\texttt{Weak\textless{}T\textgreater{}} can be held on to forever.
However, it is possible that an attempt to access the inner data may
fail and return \texttt{None}, since this can outlive the owned
\texttt{Rc}s. This is useful for cyclic data structures and other
things.

\subparagraph{Cost}\label{cost}

As far as memory goes, \texttt{Rc\textless{}T\textgreater{}} is a single
allocation, though it will allocate two extra words (i.e.~two
\texttt{usize} values) as compared to a regular
\texttt{Box\textless{}T\textgreater{}} (for ``strong'' and ``weak''
refcounts).

\texttt{Rc\textless{}T\textgreater{}} has the computational cost of
incrementing/decrementing the refcount whenever it is cloned or goes out
of scope respectively. Note that a clone will not do a deep copy, rather
it will simply increment the inner reference count and return a copy of
the \texttt{Rc\textless{}T\textgreater{}}.

\subsection{Cell types}\label{cell-types}

\texttt{Cell}s provide interior mutability. In other words, they contain
data which can be manipulated even if the type cannot be obtained in a
mutable form (for example, when it is behind an \texttt{\&}-ptr or
\texttt{Rc\textless{}T\textgreater{}}).

\href{http://doc.rust-lang.org/std/cell/}{The documentation for the
\texttt{cell} module has a pretty good explanation for these}.

These types are \emph{generally} found in struct fields, but they may be
found elsewhere too.

\subsubsection{\texorpdfstring{\texttt{Cell\textless{}T\textgreater{}}}{Cell\textless{}T\textgreater{}}}\label{cellt}

\href{http://doc.rust-lang.org/std/cell/struct.Cell.html}{\texttt{Cell\textless{}T\textgreater{}}}
is a type that provides zero-cost interior mutability, but only for
\texttt{Copy} types. Since the compiler knows that all the data owned by
the contained value is on the stack, there's no worry of leaking any
data behind references (or worse!) by simply replacing the data.

It is still possible to violate your own invariants using this wrapper,
so be careful when using it. If a field is wrapped in \texttt{Cell},
it's a nice indicator that the chunk of data is mutable and may not stay
the same between the time you first read it and when you intend to use
it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::cell::Cell;}

\KeywordTok{let} \NormalTok{x = Cell::new(}\DecValTok{1}\NormalTok{);}
\KeywordTok{let} \NormalTok{y = &x;}
\KeywordTok{let} \NormalTok{z = &x;}
\NormalTok{x.set(}\DecValTok{2}\NormalTok{);}
\NormalTok{y.set(}\DecValTok{3}\NormalTok{);}
\NormalTok{z.set(}\DecValTok{4}\NormalTok{);}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x.get());}
\end{Highlighting}
\end{Shaded}

Note that here we were able to mutate the same value from various
immutable references.

This has the same runtime cost as the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{1}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;}
\KeywordTok{let} \NormalTok{z = &}\KeywordTok{mut} \NormalTok{x;}
\NormalTok{x = }\DecValTok{2}\NormalTok{;}
\NormalTok{*y = }\DecValTok{3}\NormalTok{;}
\NormalTok{*z = }\DecValTok{4}\NormalTok{;}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

but it has the added benefit of actually compiling successfully.

\subparagraph{Guarantees}\label{guarantees-1}

This relaxes the ``no aliasing with mutability'' restriction in places
where it's unnecessary. However, this also relaxes the guarantees that
the restriction provides; so if your invariants depend on data stored
within \texttt{Cell}, you should be careful.

This is useful for mutating primitives and other \texttt{Copy} types
when there is no easy way of doing it in line with the static rules of
\texttt{\&} and \texttt{\&mut}.

\texttt{Cell} does not let you obtain interior references to the data,
which makes it safe to freely mutate.

\subparagraph{Cost}\label{cost-1}

There is no runtime cost to using
\texttt{Cell\textless{}T\textgreater{}}, however if you are using it to
wrap larger (\texttt{Copy}) structs, it might be worthwhile to instead
wrap individual fields in \texttt{Cell\textless{}T\textgreater{}} since
each write is otherwise a full copy of the struct.

\subsubsection{\texorpdfstring{\texttt{RefCell\textless{}T\textgreater{}}}{RefCell\textless{}T\textgreater{}}}\label{refcellt}

\href{http://doc.rust-lang.org/std/cell/struct.RefCell.html}{\texttt{RefCell\textless{}T\textgreater{}}}
also provides interior mutability, but isn't restricted to \texttt{Copy}
types.

Instead, it has a runtime cost.
\texttt{RefCell\textless{}T\textgreater{}} enforces the read-write lock
pattern at runtime (it's like a single-threaded mutex), unlike
\texttt{\&T}/\texttt{\&mut\ T} which do so at compile time. This is done
by the \texttt{borrow()} and \texttt{borrow\_mut()} functions, which
modify an internal reference count and return smart pointers which can
be dereferenced immutably and mutably respectively. The refcount is
restored when the smart pointers go out of scope. With this system, we
can dynamically ensure that there are never any other borrows active
when a mutable borrow is active. If the programmer attempts to make such
a borrow, the thread will panic.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::cell::RefCell;}

\KeywordTok{let} \NormalTok{x = RefCell::new(}\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]);}
\NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, *x.borrow())}
\NormalTok{\}}

\NormalTok{\{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{my_ref = x.borrow_mut();}
    \NormalTok{my_ref.push(}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Similar to \texttt{Cell}, this is mainly useful for situations where
it's hard or impossible to satisfy the borrow checker. Generally we know
that such mutations won't happen in a nested form, but it's good to
check.

For large, complicated programs, it becomes useful to put some things in
\texttt{RefCell}s to make things simpler. For example, a lot of the maps
in \href{http://doc.rust-lang.org/rustc/middle/ty/struct.ctxt.html}{the
\texttt{ctxt} struct} in the rust compiler internals are inside this
wrapper. These are only modified once (during creation, which is not
right after initialization) or a couple of times in well-separated
places. However, since this struct is pervasively used everywhere,
juggling mutable and immutable pointers would be hard (perhaps
impossible) and probably form a soup of \texttt{\&}-ptrs which would be
hard to extend. On the other hand, the \texttt{RefCell} provides a cheap
(not zero-cost) way of safely accessing these. In the future, if someone
adds some code that attempts to modify the cell when it's already
borrowed, it will cause a (usually deterministic) panic which can be
traced back to the offending borrow.

Similarly, in Servo's DOM there is a lot of mutation, most of which is
local to a DOM type, but some of which crisscrosses the DOM and modifies
various things. Using \texttt{RefCell} and \texttt{Cell} to guard all
mutation lets us avoid worrying about mutability everywhere, and it
simultaneously highlights the places where mutation is \emph{actually}
happening.

Note that \texttt{RefCell} should be avoided if a mostly simple solution
is possible with \texttt{\&} pointers.

\subparagraph{Guarantees}\label{guarantees-2}

\texttt{RefCell} relaxes the \emph{static} restrictions preventing
aliased mutation, and replaces them with \emph{dynamic} ones. As such
the guarantees have not changed.

\subparagraph{Cost}\label{cost-2}

\texttt{RefCell} does not allocate, but it contains an additional
``borrow state'' indicator (one word in size) along with the data.

At runtime each borrow causes a modification/check of the refcount.

\subsection{Synchronous types}\label{synchronous-types}

Many of the types above cannot be used in a threadsafe manner.
Particularly, \texttt{Rc\textless{}T\textgreater{}} and
\texttt{RefCell\textless{}T\textgreater{}}, which both use non-atomic
reference counts (\emph{atomic} reference counts are those which can be
incremented from multiple threads without causing a data race), cannot
be used this way. This makes them cheaper to use, but we need thread
safe versions of these too. They exist, in the form of
\texttt{Arc\textless{}T\textgreater{}} and
\texttt{Mutex\textless{}T\textgreater{}}/\texttt{RwLock\textless{}T\textgreater{}}

Note that the non-threadsafe types \emph{cannot} be sent between
threads, and this is checked at compile time.

There are many useful wrappers for concurrent programming in the
\href{http://doc.rust-lang.org/std/sync/index.html}{sync} module, but
only the major ones will be covered below.

\subsubsection{\texorpdfstring{\texttt{Arc\textless{}T\textgreater{}}}{Arc\textless{}T\textgreater{}}}\label{arct}

\href{http://doc.rust-lang.org/std/sync/struct.Arc.html}{\texttt{Arc\textless{}T\textgreater{}}}
is just a version of \texttt{Rc\textless{}T\textgreater{}} that uses an
atomic reference count (hence, ``Arc''). This can be sent freely between
threads.

C++'s \texttt{shared\_ptr} is similar to \texttt{Arc}, however in the
case of C++ the inner data is always mutable. For semantics similar to
that from C++, we should use
\texttt{Arc\textless{}Mutex\textless{}T\textgreater{}\textgreater{}},
\texttt{Arc\textless{}RwLock\textless{}T\textgreater{}\textgreater{}},
or
\texttt{Arc\textless{}UnsafeCell\textless{}T\textgreater{}\textgreater{}}\footnote{\texttt{Arc\textless{}UnsafeCell\textless{}T\textgreater{}\textgreater{}}
  actually won't compile since
  \texttt{UnsafeCell\textless{}T\textgreater{}} isn't \texttt{Send} or
  \texttt{Sync}, but we can wrap it in a type and implement
  \texttt{Send}/\texttt{Sync} for it manually to get
  \texttt{Arc\textless{}Wrapper\textless{}T\textgreater{}\textgreater{}}
  where \texttt{Wrapper} is
  \texttt{struct\ Wrapper\textless{}T\textgreater{}(UnsafeCell\textless{}T\textgreater{})}.}
(\texttt{UnsafeCell\textless{}T\textgreater{}} is a cell type that can
be used to hold any data and has no runtime cost, but accessing it
requires \texttt{unsafe} blocks). The last one should only be used if we
are certain that the usage won't cause any memory unsafety. Remember
that writing to a struct is not an atomic operation, and many functions
like \texttt{vec.push()} can reallocate internally and cause unsafe
behavior, so even monotonicity may not be enough to justify
\texttt{UnsafeCell}.

\subparagraph{Guarantees}\label{guarantees-3}

Like \texttt{Rc}, this provides the (thread safe) guarantee that the
destructor for the internal data will be run when the last \texttt{Arc}
goes out of scope (barring any cycles).

\subparagraph{Cost}\label{cost-3}

This has the added cost of using atomics for changing the refcount
(which will happen whenever it is cloned or goes out of scope). When
sharing data from an \texttt{Arc} in a single thread, it is preferable
to share \texttt{\&} pointers whenever possible.

\subsubsection{\texorpdfstring{\texttt{Mutex\textless{}T\textgreater{}}
and
\texttt{RwLock\textless{}T\textgreater{}}}{Mutex\textless{}T\textgreater{} and RwLock\textless{}T\textgreater{}}}\label{mutext-and-rwlockt}

\href{http://doc.rust-lang.org/std/sync/struct.Mutex.html}{\texttt{Mutex\textless{}T\textgreater{}}}
and
\href{http://doc.rust-lang.org/std/sync/struct.RwLock.html}{\texttt{RwLock\textless{}T\textgreater{}}}
provide mutual-exclusion via RAII guards (guards are objects which
maintain some state, like a lock, until their destructor is called). For
both of these, the mutex is opaque until we call \texttt{lock()} on it,
at which point the thread will block until a lock can be acquired, and
then a guard will be returned. This guard can be used to access the
inner data (mutably), and the lock will be released when the guard goes
out of scope.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
    \KeywordTok{let} \NormalTok{guard = mutex.lock();}
    \CommentTok{// guard dereferences mutably to the inner type}
    \NormalTok{*guard += }\DecValTok{1}\NormalTok{;}
\NormalTok{\} }\CommentTok{// lock released when destructor runs}
\end{Highlighting}
\end{Shaded}

\texttt{RwLock} has the added benefit of being efficient for multiple
reads. It is always safe to have multiple readers to shared data as long
as there are no writers; and \texttt{RwLock} lets readers acquire a
``read lock''. Such locks can be acquired concurrently and are kept
track of via a reference count. Writers must obtain a ``write lock''
which can only be obtained when all readers have gone out of scope.

\subparagraph{Guarantees}\label{guarantees-4}

Both of these provide safe shared mutability across threads, however
they are prone to deadlocks. Some level of additional protocol safety
can be obtained via the type system.

\subparagraph{Costs}\label{costs}

These use internal atomic-like types to maintain the locks, which are
pretty costly (they can block all memory reads across processors till
they're done). Waiting on these locks can also be slow when there's a
lot of concurrent access happening.

\subsection{Composition}\label{composition}

A common gripe when reading Rust code is with types like
\texttt{Rc\textless{}RefCell\textless{}Vec\textless{}T\textgreater{}\textgreater{}\textgreater{}}
(or even more more complicated compositions of such types). It's not
always clear what the composition does, or why the author chose one like
this (and when one should be using such a composition in one's own code)

Usually, it's a case of composing together the guarantees that you need,
without paying for stuff that is unnecessary.

For example,
\texttt{Rc\textless{}RefCell\textless{}T\textgreater{}\textgreater{}} is
one such composition. \texttt{Rc\textless{}T\textgreater{}} itself can't
be dereferenced mutably; because \texttt{Rc\textless{}T\textgreater{}}
provides sharing and shared mutability can lead to unsafe behavior, so
we put \texttt{RefCell\textless{}T\textgreater{}} inside to get
dynamically verified shared mutability. Now we have shared mutable data,
but it's shared in a way that there can only be one mutator (and no
readers) or multiple readers.

Now, we can take this a step further, and have
\texttt{Rc\textless{}RefCell\textless{}Vec\textless{}T\textgreater{}\textgreater{}\textgreater{}}
or
\texttt{Rc\textless{}Vec\textless{}RefCell\textless{}T\textgreater{}\textgreater{}\textgreater{}}.
These are both shareable, mutable vectors, but they're not the same.

With the former, the \texttt{RefCell\textless{}T\textgreater{}} is
wrapping the \texttt{Vec\textless{}T\textgreater{}}, so the
\texttt{Vec\textless{}T\textgreater{}} in its entirety is mutable. At
the same time, there can only be one mutable borrow of the whole
\texttt{Vec} at a given time. This means that your code cannot
simultaneously work on different elements of the vector from different
\texttt{Rc} handles. However, we are able to push and pop from the
\texttt{Vec\textless{}T\textgreater{}} at will. This is similar to an
\texttt{\&mut\ Vec\textless{}T\textgreater{}} with the borrow checking
done at runtime.

With the latter, the borrowing is of individual elements, but the
overall vector is immutable. Thus, we can independently borrow separate
elements, but we cannot push or pop from the vector. This is similar to
an \texttt{\&mut\ {[}T{]}}\footnote{\texttt{\&{[}T{]}} and
  \texttt{\&mut\ {[}T{]}} are \emph{slices}; they consist of a pointer
  and a length and can refer to a portion of a vector or array.
  \texttt{\&mut\ {[}T{]}} can have its elements mutated, however its
  length cannot be touched.}, but, again, the borrow checking is at
runtime.

In concurrent programs, we have a similar situation with
\texttt{Arc\textless{}Mutex\textless{}T\textgreater{}\textgreater{}},
which provides shared mutability and ownership.

When reading code that uses these, go in step by step and look at the
guarantees/costs provided.

When choosing a composed type, we must do the reverse; figure out which
guarantees we want, and at which point of the composition we need them.
For example, if there is a choice between
\texttt{Vec\textless{}RefCell\textless{}T\textgreater{}\textgreater{}}
and
\texttt{RefCell\textless{}Vec\textless{}T\textgreater{}\textgreater{}},
we should figure out the tradeoffs as done above and pick one.

\hyperdef{}{sec--ffi}{\section{FFI}\label{sec--ffi}}

\subsection{Introduction}\label{introduction-1}

This guide will use the \href{https://github.com/google/snappy}{snappy}
compression/decompression library as an introduction to writing bindings
for foreign code. Rust is currently unable to call directly into a C++
library, but snappy includes a C interface (documented in
\href{https://github.com/google/snappy/blob/master/snappy-c.h}{\texttt{snappy-c.h}}).

The following is a minimal example of calling a foreign function which
will compile if snappy is installed:

\begin{verbatim}
# #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -> size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
\end{verbatim}

The \texttt{extern} block is a list of function signatures in a foreign
library, in this case with the platform's C ABI. The
\texttt{\#{[}link(...){]}} attribute is used to instruct the linker to
link against the snappy library so the symbols are resolved.

Foreign functions are assumed to be unsafe so calls to them need to be
wrapped with \texttt{unsafe\ \{\}} as a promise to the compiler that
everything contained within truly is safe. C libraries often expose
interfaces that aren't thread-safe, and almost any function that takes a
pointer argument isn't valid for all possible inputs since the pointer
could be dangling, and raw pointers fall outside of Rust's safe memory
model.

When declaring the argument types to a foreign function, the Rust
compiler can not check if the declaration is correct, so specifying it
correctly is part of keeping the binding correct at runtime.

The \texttt{extern} block can be extended to cover the entire snappy
API:

\begin{verbatim}
# #![feature(libc)]
extern crate libc;
use libc::{c_int, size_t};

#[link(name = "snappy")]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -> c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -> c_int;
    fn snappy_max_compressed_length(source_length: size_t) -> size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -> c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -> c_int;
}
# fn main() {}
\end{verbatim}

\subsection{Creating a safe interface}\label{creating-a-safe-interface}

The raw C API needs to be wrapped to provide memory safety and make use
of higher-level concepts like vectors. A library can choose to expose
only the safe, high-level interface and hide the unsafe internal
details.

Wrapping the functions which expect buffers involves using the
\texttt{slice::raw} module to manipulate Rust vectors as pointers to
memory. Rust's vectors are guaranteed to be a contiguous block of
memory. The length is number of elements currently contained, and the
capacity is the total size in elements of the allocated memory. The
length is less than or equal to the capacity.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{validate_compressed_buffer(src: &[}\DataTypeTok{u8}\NormalTok{]) -> }\DataTypeTok{bool} \NormalTok{\{}
    \KeywordTok{unsafe} \NormalTok{\{}
        \NormalTok{snappy_validate_compressed_buffer(src.as_ptr(), src.len() }\KeywordTok{as} \DataTypeTok{size_t}\NormalTok{) == }\DecValTok{0}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{validate\_compressed\_buffer} wrapper above makes use of an
\texttt{unsafe} block, but it makes the guarantee that calling it is
safe for all inputs by leaving off \texttt{unsafe} from the function
signature.

The \texttt{snappy\_compress} and \texttt{snappy\_uncompress} functions
are more complex, since a buffer has to be allocated to hold the output
too.

The \texttt{snappy\_max\_compressed\_length} function can be used to
allocate a vector with the maximum required capacity to hold the
compressed output. The vector can then be passed to the
\texttt{snappy\_compress} function as an output parameter. An output
parameter is also passed to retrieve the true length after compression
for setting the length.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{compress(src: &[}\DataTypeTok{u8}\NormalTok{]) -> }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{u8}\NormalTok{> \{}
    \KeywordTok{unsafe} \NormalTok{\{}
        \KeywordTok{let} \NormalTok{srclen = src.len() }\KeywordTok{as} \DataTypeTok{size_t}\NormalTok{;}
        \KeywordTok{let} \NormalTok{psrc = src.as_ptr();}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{dstlen = snappy_max_compressed_length(srclen);}
        \KeywordTok{let} \KeywordTok{mut} \NormalTok{dst = }\DataTypeTok{Vec}\NormalTok{::with_capacity(dstlen }\KeywordTok{as} \DataTypeTok{usize}\NormalTok{);}
        \KeywordTok{let} \NormalTok{pdst = dst.as_mut_ptr();}

        \NormalTok{snappy_compress(psrc, srclen, pdst, &}\KeywordTok{mut} \NormalTok{dstlen);}
        \NormalTok{dst.set_len(dstlen }\KeywordTok{as} \DataTypeTok{usize}\NormalTok{);}
        \NormalTok{dst}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Decompression is similar, because snappy stores the uncompressed size as
part of the compression format and \texttt{snappy\_uncompressed\_length}
will retrieve the exact buffer size required.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{uncompress(src: &[}\DataTypeTok{u8}\NormalTok{]) -> }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{u8}\NormalTok{>> \{}
    \KeywordTok{unsafe} \NormalTok{\{}
        \KeywordTok{let} \NormalTok{srclen = src.len() }\KeywordTok{as} \DataTypeTok{size_t}\NormalTok{;}
        \KeywordTok{let} \NormalTok{psrc = src.as_ptr();}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{dstlen: }\DataTypeTok{size_t} \NormalTok{= }\DecValTok{0}\NormalTok{;}
        \NormalTok{snappy_uncompressed_length(psrc, srclen, &}\KeywordTok{mut} \NormalTok{dstlen);}

        \KeywordTok{let} \KeywordTok{mut} \NormalTok{dst = }\DataTypeTok{Vec}\NormalTok{::with_capacity(dstlen }\KeywordTok{as} \DataTypeTok{usize}\NormalTok{);}
        \KeywordTok{let} \NormalTok{pdst = dst.as_mut_ptr();}

        \KeywordTok{if} \NormalTok{snappy_uncompress(psrc, srclen, pdst, &}\KeywordTok{mut} \NormalTok{dstlen) == }\DecValTok{0} \NormalTok{\{}
            \NormalTok{dst.set_len(dstlen }\KeywordTok{as} \DataTypeTok{usize}\NormalTok{);}
            \ConstantTok{Some}\NormalTok{(dst)}
        \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
            \ConstantTok{None} \CommentTok{// SNAPPY_INVALID_INPUT}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For reference, the examples used here are also available as a
\href{https://github.com/thestinger/rust-snappy}{library on GitHub}.

\subsection{Destructors}\label{destructors}

Foreign libraries often hand off ownership of resources to the calling
code. When this occurs, we must use Rust's destructors to provide safety
and guarantee the release of these resources (especially in the case of
panic).

For more about destructors, see the
\href{http://doc.rust-lang.org/std/ops/trait.Drop.html}{Drop trait}.

\subsection{Callbacks from C code to Rust
functions}\label{callbacks-from-c-code-to-rust-functions}

Some external libraries require the usage of callbacks to report back
their current state or intermediate data to the caller. It is possible
to pass functions defined in Rust to an external library. The
requirement for this is that the callback function is marked as
\texttt{extern} with the correct calling convention to make it callable
from C code.

The callback function can then be sent through a registration call to
the C library and afterwards be invoked from there.

A basic example is:

Rust code:

\begin{verbatim}
extern fn callback(a: i32) {
    println!("I'm called from C with value {0}", a);
}

#[link(name = "extlib")]
extern {
   fn register_callback(cb: extern fn(i32)) -> i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Triggers the callback
    }
}
\end{verbatim}

C code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{void} \NormalTok{(*rust_callback)(}\DataTypeTok{int32_t}\NormalTok{);}
\NormalTok{rust_callback cb;}

\DataTypeTok{int32_t} \NormalTok{register_callback(rust_callback callback) \{}
    \NormalTok{cb = callback;}
    \KeywordTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void} \NormalTok{trigger_callback() \{}
  \NormalTok{cb(}\DecValTok{7}\NormalTok{); }\CommentTok{// Will call callback(7) in Rust}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this example Rust's \texttt{main()} will call
\texttt{trigger\_callback()} in C, which would, in turn, call back to
\texttt{callback()} in Rust.

\subsubsection{Targeting callbacks to Rust
objects}\label{targeting-callbacks-to-rust-objects}

The former example showed how a global function can be called from C
code. However it is often desired that the callback is targeted to a
special Rust object. This could be the object that represents the
wrapper for the respective C object.

This can be achieved by passing an raw pointer to the object down to the
C library. The C library can then include the pointer to the Rust object
in the notification. This will allow the callback to unsafely access the
referenced Rust object.

Rust code:

\begin{verbatim}
#[repr(C)]
struct RustObject {
    a: i32,
    // other members
}

extern "C" fn callback(target: *mut RustObject, a: i32) {
    println!("I'm called from C with value {0}", a);
    unsafe {
        // Update the value in RustObject with the value received from the callback
        (*target).a = a;
    }
}

#[link(name = "extlib")]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -> i32;
   fn trigger_callback();
}

fn main() {
    // Create the object that will be referenced in the callback
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&mut *rust_object, callback);
        trigger_callback();
    }
}
\end{verbatim}

C code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{void} \NormalTok{(*rust_callback)(}\DataTypeTok{void}\NormalTok{*, }\DataTypeTok{int32_t}\NormalTok{);}
\DataTypeTok{void}\NormalTok{* cb_target;}
\NormalTok{rust_callback cb;}

\DataTypeTok{int32_t} \NormalTok{register_callback(}\DataTypeTok{void}\NormalTok{* callback_target, rust_callback callback) \{}
    \NormalTok{cb_target = callback_target;}
    \NormalTok{cb = callback;}
    \KeywordTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void} \NormalTok{trigger_callback() \{}
  \NormalTok{cb(cb_target, }\DecValTok{7}\NormalTok{); }\CommentTok{// Will call callback(&rustObject, 7) in Rust}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Asynchronous callbacks}\label{asynchronous-callbacks}

In the previously given examples the callbacks are invoked as a direct
reaction to a function call to the external C library. The control over
the current thread is switched from Rust to C to Rust for the execution
of the callback, but in the end the callback is executed on the same
thread that called the function which triggered the callback.

Things get more complicated when the external library spawns its own
threads and invokes callbacks from there. In these cases access to Rust
data structures inside the callbacks is especially unsafe and proper
synchronization mechanisms must be used. Besides classical
synchronization mechanisms like mutexes, one possibility in Rust is to
use channels (in \texttt{std::sync::mpsc}) to forward data from the C
thread that invoked the callback into a Rust thread.

If an asynchronous callback targets a special object in the Rust address
space it is also absolutely necessary that no more callbacks are
performed by the C library after the respective Rust object gets
destroyed. This can be achieved by unregistering the callback in the
object's destructor and designing the library in a way that guarantees
that no callback will be performed after deregistration.

\subsection{Linking}\label{linking}

The \texttt{link} attribute on \texttt{extern} blocks provides the basic
building block for instructing rustc how it will link to native
libraries. There are two accepted forms of the link attribute today:

\begin{itemize}
\tightlist
\item
  \texttt{\#{[}link(name\ =\ "foo"){]}}
\item
  \texttt{\#{[}link(name\ =\ "foo",\ kind\ =\ "bar"){]}}
\end{itemize}

In both of these cases, \texttt{foo} is the name of the native library
that we're linking to, and in the second case \texttt{bar} is the type
of native library that the compiler is linking to. There are currently
three known types of native libraries:

\begin{itemize}
\tightlist
\item
  Dynamic - \texttt{\#{[}link(name\ =\ "readline"){]}}
\item
  Static -
  \texttt{\#{[}link(name\ =\ "my\_build\_dependency",\ kind\ =\ "static"){]}}
\item
  Frameworks -
  \texttt{\#{[}link(name\ =\ "CoreFoundation",\ kind\ =\ "framework"){]}}
\end{itemize}

Note that frameworks are only available on OSX targets.

The different \texttt{kind} values are meant to differentiate how the
native library participates in linkage. From a linkage perspective, the
Rust compiler creates two flavors of artifacts: partial (rlib/staticlib)
and final (dylib/binary). Native dynamic library and framework
dependencies are propagated to the final artifact boundary, while static
library dependencies are not propagated at all, because the static
libraries are integrated directly into the subsequent artifact.

A few examples of how this model can be used are:

\begin{itemize}
\tightlist
\item
  A native build dependency. Sometimes some C/C++ glue is needed when
  writing some Rust code, but distribution of the C/C++ code in a
  library format is just a burden. In this case, the code will be
  archived into \texttt{libfoo.a} and then the Rust crate would declare
  a dependency via
  \texttt{\#{[}link(name\ =\ "foo",\ kind\ =\ \ \ "static"){]}}.
\end{itemize}

Regardless of the flavor of output for the crate, the native static
library will be included in the output, meaning that distribution of the
native static library is not necessary.

\begin{itemize}
\tightlist
\item
  A normal dynamic dependency. Common system libraries (like
  \texttt{readline}) are available on a large number of systems, and
  often a static copy of these libraries cannot be found. When this
  dependency is included in a Rust crate, partial targets (like rlibs)
  will not link to the library, but when the rlib is included in a final
  target (like a binary), the native library will be linked in.
\end{itemize}

On OSX, frameworks behave with the same semantics as a dynamic library.

\subsection{Unsafe blocks}\label{unsafe-blocks}

Some operations, like dereferencing raw pointers or calling functions
that have been marked unsafe are only allowed inside unsafe blocks.
Unsafe blocks isolate unsafety and are a promise to the compiler that
the unsafety does not leak out of the block.

Unsafe functions, on the other hand, advertise it to the world. An
unsafe function is written like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unsafe} \KeywordTok{fn} \NormalTok{kaboom(ptr: *}\KeywordTok{const} \DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{ *ptr \}}
\end{Highlighting}
\end{Shaded}

This function can only be called from an \texttt{unsafe} block or
another \texttt{unsafe} function.

\subsection{Accessing foreign globals}\label{accessing-foreign-globals}

Foreign APIs often export a global variable which could do something
like track global state. In order to access these variables, you declare
them in \texttt{extern} blocks with the \texttt{static} keyword:

\begin{verbatim}
# #![feature(libc)]
extern crate libc;

#[link(name = "readline")]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!("You have readline version {} installed.",
             rl_readline_version as i32);
}
\end{verbatim}

Alternatively, you may need to alter global state provided by a foreign
interface. To do this, statics can be declared with \texttt{mut} so we
can mutate them.

\begin{verbatim}
# #![feature(libc)]
extern crate libc;

use std::ffi::CString;
use std::ptr;

#[link(name = "readline")]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new("[my-awesome-shell] $").unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!("{:?}", rl_prompt);

        rl_prompt = ptr::null();
    }
}
\end{verbatim}

Note that all interaction with a \texttt{static\ mut} is unsafe, both
reading and writing. Dealing with global mutable state requires a great
deal of care.

\hyperdef{}{foreign-calling-conventions}{\subsection{Foreign calling
conventions}\label{foreign-calling-conventions}}

Most foreign code exposes a C ABI, and Rust uses the platform's C
calling convention by default when calling foreign functions. Some
foreign functions, most notably the Windows API, use other calling
conventions. Rust provides a way to tell the compiler which convention
to use:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{libc;}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{all}\AttributeTok{(}\NormalTok{target_os }\AttributeTok{=} \StringTok{"win32"}\AttributeTok{,} \NormalTok{target_arch }\AttributeTok{=} \StringTok{"x86"}\AttributeTok{))]}
\AttributeTok{#[}\NormalTok{link}\AttributeTok{(}\NormalTok{name }\AttributeTok{=} \StringTok{"kernel32"}\AttributeTok{)]}
\AttributeTok{#[}\NormalTok{allow}\AttributeTok{(}\NormalTok{non_snake_case}\AttributeTok{)]}
\KeywordTok{extern} \StringTok{"stdcall"} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{SetEnvironmentVariableA(n: *}\KeywordTok{const} \DataTypeTok{u8}\NormalTok{, v: *}\KeywordTok{const} \DataTypeTok{u8}\NormalTok{) -> libc::}\DataTypeTok{c_int}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This applies to the entire \texttt{extern} block. The list of supported
ABI constraints are:

\begin{itemize}
\tightlist
\item
  \texttt{stdcall}
\item
  \texttt{aapcs}
\item
  \texttt{cdecl}
\item
  \texttt{fastcall}
\item
  \texttt{Rust}
\item
  \texttt{rust-intrinsic}
\item
  \texttt{system}
\item
  \texttt{C}
\item
  \texttt{win64}
\end{itemize}

Most of the abis in this list are self-explanatory, but the
\texttt{system} abi may seem a little odd. This constraint selects
whatever the appropriate ABI is for interoperating with the target's
libraries. For example, on win32 with a x86 architecture, this means
that the abi used would be \texttt{stdcall}. On x86\_64, however,
windows uses the \texttt{C} calling convention, so \texttt{C} would be
used. This means that in our previous example, we could have used
\texttt{extern\ "system"\ \{\ ...\ \}} to define a block for all windows
systems, not just x86 ones.

\subsection{Interoperability with foreign
code}\label{interoperability-with-foreign-code}

Rust guarantees that the layout of a \texttt{struct} is compatible with
the platform's representation in C only if the \texttt{\#{[}repr(C){]}}
attribute is applied to it. \texttt{\#{[}repr(C,\ packed){]}} can be
used to lay out struct members without padding. \texttt{\#{[}repr(C){]}}
can also be applied to an enum.

Rust's owned boxes (\texttt{Box\textless{}T\textgreater{}}) use
non-nullable pointers as handles which point to the contained object.
However, they should not be manually created because they are managed by
internal allocators. References can safely be assumed to be non-nullable
pointers directly to the type. However, breaking the borrow checking or
mutability rules is not guaranteed to be safe, so prefer using raw
pointers (\texttt{*}) if that's needed because the compiler can't make
as many assumptions about them.

Vectors and strings share the same basic memory layout, and utilities
are available in the \texttt{vec} and \texttt{str} modules for working
with C APIs. However, strings are not terminated with
\texttt{\textbackslash{}0}. If you need a NUL-terminated string for
interoperability with C, you should use the \texttt{CString} type in the
\texttt{std::ffi} module.

The \href{https://crates.io/crates/libc}{\texttt{libc} crate on
crates.io} includes type aliases and function definitions for the C
standard library in the \texttt{libc} module, and Rust links against
\texttt{libc} and \texttt{libm} by default.

\subsection{\texorpdfstring{The ``nullable pointer
optimization''}{The nullable pointer optimization}}\label{the-nullable-pointer-optimization}

Certain types are defined to not be \texttt{null}. This includes
references (\texttt{\&T}, \texttt{\&mut\ T}), boxes
(\texttt{Box\textless{}T\textgreater{}}), and function pointers
(\texttt{extern\ "abi"\ fn()}). When interfacing with C, pointers that
might be null are often used. As a special case, a generic \texttt{enum}
that contains exactly two variants, one of which contains no data and
the other containing a single field, is eligible for the ``nullable
pointer optimization''. When such an enum is instantiated with one of
the non-nullable types, it is represented as a single pointer, and the
non-data variant is represented as the null pointer. So
\texttt{Option\textless{}extern\ "C"\ fn(c\_int)\ -\textgreater{}\ c\_int\textgreater{}}
is how one represents a nullable function pointer using the C ABI.

\subsection{Calling Rust code from C}\label{calling-rust-code-from-c}

You may wish to compile Rust code in a way so that it can be called from
C. This is fairly easy, but requires a few things:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{no_mangle}\AttributeTok{]}
\KeywordTok{pub} \KeywordTok{extern} \KeywordTok{fn} \NormalTok{hello_rust() -> *}\KeywordTok{const} \DataTypeTok{u8} \NormalTok{\{}
    \StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}}\ErrorTok{0}\StringTok{"}\NormalTok{.as_ptr()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{extern} makes this function adhere to the C calling
convention, as discussed above in
``\hyperref[foreign-calling-conventions]{Foreign Calling Conventions}''.
The \texttt{no\_mangle} attribute turns off Rust's name mangling, so
that it is easier to link to.

\subsection{FFI and panics}\label{ffi-and-panics}

It's important to be mindful of \texttt{panic!}s when working with FFI.
A \texttt{panic!} across an FFI boundary is undefined behavior. If
you're writing code that may panic, you should run it in another thread,
so that the panic doesn't bubble up to C:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::thread;}

\AttributeTok{#[}\NormalTok{no_mangle}\AttributeTok{]}
\KeywordTok{pub} \KeywordTok{extern} \KeywordTok{fn} \NormalTok{oh_no() -> }\DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{h = thread::spawn(|| \{}
        \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"Oops!"}\NormalTok{);}
    \NormalTok{\});}

    \KeywordTok{match} \NormalTok{h.join() \{}
        \ConstantTok{Ok}\NormalTok{(_) => }\DecValTok{1}\NormalTok{,}
        \ConstantTok{Err}\NormalTok{(_) => }\DecValTok{0}\NormalTok{,}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Representing opaque
structs}\label{representing-opaque-structs}

Sometimes, a C library wants to provide a pointer to something, but not
let you know the internal details of the thing it wants. The simplest
way is to use a \texttt{void\ *} argument:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \NormalTok{foo(}\DataTypeTok{void} \NormalTok{*arg);}
\DataTypeTok{void} \NormalTok{bar(}\DataTypeTok{void} \NormalTok{*arg);}
\end{Highlighting}
\end{Shaded}

We can represent this in Rust with the \texttt{c\_void} type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{libc;}

\KeywordTok{extern} \StringTok{"C"} \NormalTok{\{}
    \KeywordTok{pub} \KeywordTok{fn} \NormalTok{foo(arg: *}\KeywordTok{mut} \NormalTok{libc::}\DataTypeTok{c_void}\NormalTok{);}
    \KeywordTok{pub} \KeywordTok{fn} \NormalTok{bar(arg: *}\KeywordTok{mut} \NormalTok{libc::}\DataTypeTok{c_void}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is a perfectly valid way of handling the situation. However, we can
do a bit better. To solve this, some C libraries will instead create a
\texttt{struct}, where the details and memory layout of the struct are
private. This gives some amount of type safety. These structures are
called `opaque'. Here's an example, in C:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo; }\CommentTok{/* Foo is a structure, but its contents are not part of the public interfa}
\CommentTok{‚Ü≥ ce */}
\KeywordTok{struct} \NormalTok{Bar;}
\DataTypeTok{void} \NormalTok{foo(}\KeywordTok{struct} \NormalTok{Foo *arg);}
\DataTypeTok{void} \NormalTok{bar(}\KeywordTok{struct} \NormalTok{Bar *arg);}
\end{Highlighting}
\end{Shaded}

To do this in Rust, let's create our own opaque types with
\texttt{enum}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{enum} \NormalTok{Foo \{\}}
\KeywordTok{pub} \KeywordTok{enum} \NormalTok{Bar \{\}}

\KeywordTok{extern} \StringTok{"C"} \NormalTok{\{}
    \KeywordTok{pub} \KeywordTok{fn} \NormalTok{foo(arg: *}\KeywordTok{mut} \NormalTok{Foo);}
    \KeywordTok{pub} \KeywordTok{fn} \NormalTok{bar(arg: *}\KeywordTok{mut} \NormalTok{Bar);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By using an \texttt{enum} with no variants, we create an opaque type
that we can't instantiate, as it has no variants. But because our
\texttt{Foo} and \texttt{Bar} types are different, we'll get type safety
between the two of them, so we cannot accidentally pass a pointer to
\texttt{Foo} to \texttt{bar()}.

\section{Borrow and AsRef}\label{sec--borrow-and-asref}

The
\href{http://doc.rust-lang.org/std/borrow/trait.Borrow.html}{\texttt{Borrow}}
and
\href{http://doc.rust-lang.org/std/convert/trait.AsRef.html}{\texttt{AsRef}}
traits are very similar, but different. Here's a quick refresher on what
these two traits mean.

\subsection{Borrow}\label{borrow}

The \texttt{Borrow} trait is used when you're writing a datastructure,
and you want to use either an owned or borrowed type as synonymous for
some purpose.

For example,
\href{http://doc.rust-lang.org/std/collections/struct.HashMap.html}{\texttt{HashMap}}
has a
\href{http://doc.rust-lang.org/std/collections/struct.HashMap.html\#method.get}{\texttt{get}
method} which uses \texttt{Borrow}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{get<Q: ?}\BuiltInTok{Sized}\NormalTok{>(&}\KeywordTok{self}\NormalTok{, k: &Q) -> }\DataTypeTok{Option}\NormalTok{<&V>}
    \KeywordTok{where} \NormalTok{K: Borrow<Q>,}
          \NormalTok{Q: }\BuiltInTok{Hash} \NormalTok{+ }\BuiltInTok{Eq}
\end{Highlighting}
\end{Shaded}

This signature is pretty complicated. The \texttt{K} parameter is what
we're interested in here. It refers to a parameter of the
\texttt{HashMap} itself:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{HashMap<K, V, S = RandomState> \{}
\end{Highlighting}
\end{Shaded}

The \texttt{K} parameter is the type of \emph{key} the \texttt{HashMap}
uses. So, looking at the signature of \texttt{get()} again, we can use
\texttt{get()} when the key implements
\texttt{Borrow\textless{}Q\textgreater{}}. That way, we can make a
\texttt{HashMap} which uses \texttt{String} keys, but use
\texttt{\&str}s when we're searching:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::collections::HashMap;}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{map = HashMap::new();}
\NormalTok{map.insert(}\StringTok{"Foo"}\NormalTok{.to_string(), }\DecValTok{42}\NormalTok{);}

\PreprocessorTok{assert_eq!}\NormalTok{(map.get(}\StringTok{"Foo"}\NormalTok{), }\ConstantTok{Some}\NormalTok{(&}\DecValTok{42}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

This is because the standard library has
\texttt{impl\ Borrow\textless{}str\textgreater{}\ for\ String}.

For most types, when you want to take an owned or borrowed type, a
\texttt{\&T} is enough. But one area where \texttt{Borrow} is effective
is when there's more than one kind of borrowed value. This is especially
true of references and slices: you can have both an \texttt{\&T} or a
\texttt{\&mut\ T}. If we wanted to accept both of these types,
\texttt{Borrow} is up for it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::borrow::Borrow;}
\KeywordTok{use} \NormalTok{std::fmt::}\BuiltInTok{Display}\NormalTok{;}

\KeywordTok{fn} \NormalTok{foo<T: Borrow<}\DataTypeTok{i32}\NormalTok{> + }\BuiltInTok{Display}\NormalTok{>(a: T) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"a is borrowed: \{\}"}\NormalTok{, a);}
\NormalTok{\}}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{i = }\DecValTok{5}\NormalTok{;}

\NormalTok{foo(&i);}
\NormalTok{foo(&}\KeywordTok{mut} \NormalTok{i);}
\end{Highlighting}
\end{Shaded}

This will print out \texttt{a\ is\ borrowed:\ 5} twice.

\subsection{AsRef}\label{asref}

The \texttt{AsRef} trait is a conversion trait. It's used for converting
some value to a reference in generic code. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{s = }\StringTok{"Hello"}\NormalTok{.to_string();}

\KeywordTok{fn} \NormalTok{foo<T: AsRef<}\DataTypeTok{str}\NormalTok{>>(s: T) \{}
    \KeywordTok{let} \NormalTok{slice = s.as_ref();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Which should I use?}\label{which-should-i-use}

We can see how they're kind of the same: they both deal with owned and
borrowed versions of some type. However, they're a bit different.

Choose \texttt{Borrow} when you want to abstract over different kinds of
borrowing, or when you're building a datastructure that treats owned and
borrowed values in equivalent ways, such as hashing and comparison.

Choose \texttt{AsRef} when you want to convert something to a reference
directly, and you're writing generic code.

\section{Release Channels}\label{sec--release-channels}

The Rust project uses a concept called `release channels' to manage
releases. It's important to understand this process to choose which
version of Rust your project should use.

\subsection{Overview}\label{overview}

There are three channels for Rust releases:

\begin{itemize}
\tightlist
\item
  Nightly
\item
  Beta
\item
  Stable
\end{itemize}

New nightly releases are created once a day. Every six weeks, the latest
nightly release is promoted to `Beta'. At that point, it will only
receive patches to fix serious errors. Six weeks later, the beta is
promoted to `Stable', and becomes the next release of \texttt{1.x}.

This process happens in parallel. So every six weeks, on the same day,
nightly goes to beta, beta goes to stable. When \texttt{1.x} is
released, at the same time, \texttt{1.(x\ +\ 1)-beta} is released, and
the nightly becomes the first version of \texttt{1.(x\ +\ 2)-nightly}.

\subsection{Choosing a version}\label{choosing-a-version}

Generally speaking, unless you have a specific reason, you should be
using the stable release channel. These releases are intended for a
general audience.

However, depending on your interest in Rust, you may choose to use
nightly instead. The basic tradeoff is this: in the nightly channel, you
can use unstable, new Rust features. However, unstable features are
subject to change, and so any new nightly release may break your code.
If you use the stable release, you cannot use experimental features, but
the next release of Rust will not cause significant issues through
breaking changes.

\subsection{Helping the ecosystem through
CI}\label{helping-the-ecosystem-through-ci}

What about beta? We encourage all Rust users who use the stable release
channel to also test against the beta channel in their continuous
integration systems. This will help alert the team in case there's an
accidental regression.

Additionally, testing against nightly can catch regressions even sooner,
and so if you don't mind a third build, we'd appreciate testing against
all channels.

As an example, many Rust programmers use
\href{https://travis-ci.org/}{Travis} to test their crates, which is
free for open source projects. Travis
\href{http://docs.travis-ci.com/user/languages/rust/}{supports Rust
directly}, and you can use a \texttt{.travis.yml} file like this to test
on all channels:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{language:} \NormalTok{rust}
\FunctionTok{rust:}
  \KeywordTok{-} \NormalTok{nightly}
  \KeywordTok{-} \NormalTok{beta}
  \KeywordTok{-} \NormalTok{stable}

\FunctionTok{matrix:}
  \FunctionTok{allow_failures:}
    \KeywordTok{-} \FunctionTok{rust:} \NormalTok{nightly}
\end{Highlighting}
\end{Shaded}

With this configuration, Travis will test all three channels, but if
something breaks on nightly, it won't fail your build. A similar
configuration is recommended for any CI system, check the documentation
of the one you're using for more details.

\hyperdef{}{sec--syntax-and-semantics}{\chapter{Syntax and
Semantics}\label{sec--syntax-and-semantics}}

This section breaks Rust down into small chunks, one for each concept.

If you'd like to learn Rust from the bottom up, reading this in order is
a great way to do that.

These sections also form a reference for each concept, so if you're
reading another tutorial and find something confusing, you can find it
explained somewhere in here.

\hyperdef{}{sec--variable-bindings}{\section{Variable
Bindings}\label{sec--variable-bindings}}

Virtually every non-`Hello World' Rust program uses \emph{variable
bindings}. They look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Putting \texttt{fn\ main()\ \{} in each example is a bit tedious, so
we'll leave that out in the future. If you're following along, make sure
to edit your \texttt{main()} function, rather than leaving it off.
Otherwise, you'll get an error.

In many languages, this is called a \emph{variable}, but Rust's variable
bindings have a few tricks up their sleeves. For example the left-hand
side of a \texttt{let} expression is a
`\hyperref[sec--patterns]{pattern}', not just a variable name. This
means we can do things like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{(x, y) = (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

After this expression is evaluated, \texttt{x} will be one, and
\texttt{y} will be two. Patterns are really powerful, and have
\hyperref[sec--patterns]{their own section} in the book. We don't need
those features for now, so we'll just keep this in the back of our minds
as we go forward.

Rust is a statically typed language, which means that we specify our
types up front, and they're checked at compile time. So why does our
first example compile? Well, Rust has this thing called `type
inference'. If it can figure out what the type of something is, Rust
doesn't require you to actually type it out.

We can add the type if we want to, though. Types come after a colon
(\texttt{:}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

If I asked you to read this out loud to the rest of the class, you'd say
``\texttt{x} is a binding with the type \texttt{i32} and the value
\texttt{five}.''

In this case we chose to represent \texttt{x} as a 32-bit signed
integer. Rust has many different primitive integer types. They begin
with \texttt{i} for signed integers and \texttt{u} for unsigned
integers. The possible integer sizes are 8, 16, 32, and 64 bits.

In future examples, we may annotate the type in a comment. The examples
will look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{; }\CommentTok{// x: i32}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the similarities between this annotation and the syntax you use
with \texttt{let}. Including these kinds of comments is not idiomatic
Rust, but we'll occasionally include them to help you understand what
the types that Rust infers are.

By default, bindings are \emph{immutable}. This code will not compile:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\NormalTok{x = }\DecValTok{10}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

It will give you this error:

\begin{verbatim}
error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
\end{verbatim}

If you want a binding to be mutable, you can use \texttt{mut}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{; }\CommentTok{// mut x: i32}
\NormalTok{x = }\DecValTok{10}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

There is no single reason that bindings are immutable by default, but we
can think about it through one of Rust's primary focuses: safety. If you
forget to say \texttt{mut}, the compiler will catch it, and let you know
that you have mutated something you may not have intended to mutate. If
bindings were mutable by default, the compiler would not be able to tell
you this. If you \emph{did} intend mutation, then the solution is quite
easy: add \texttt{mut}.

There are other good reasons to avoid mutable state when possible, but
they're out of the scope of this guide. In general, you can often avoid
explicit mutation, and so it is preferable in Rust. That said,
sometimes, mutation is what you need, so it's not verboten.

Let's get back to bindings. Rust variable bindings have one more aspect
that differs from other languages: bindings are required to be
initialized with a value before you're allowed to use them.

Let's try it out. Change your \texttt{src/main.rs} file to look like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello world!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You can use \texttt{cargo\ build} on the command line to build it.
You'll get a warning, but it will still print ``Hello, world!'':

\begin{verbatim}
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
\end{verbatim}

Rust warns us that we never use the variable binding, but since we never
use it, no harm, no foul. Things change if we try to actually use this
\texttt{x}, however. Let's do that. Change your program to look like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The value of x is: \{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And try to build it. You'll get an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{hello_world v0.0.1 (file:///home/you/projects/hello_world)}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{4}\NormalTok{:39: 4:40 error: use of possibly uninitialized variable: }\KeywordTok{`x`}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{4}     \NormalTok{println!(}\StringTok{"The value of x is: \{\}"}\NormalTok{, x);}
                                                    \NormalTok{^}
\KeywordTok{note}\NormalTok{: in expansion of format_args!}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:2:23: 2:77 note: expansion site}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:1:1: 3:2 note: in expansion of println!}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{4}\NormalTok{:5: 4:42 note: expansion site}
\KeywordTok{error}\NormalTok{: aborting due to previous error}
\KeywordTok{Could} \NormalTok{not compile }\KeywordTok{`hello_world`}\NormalTok{.}
\end{Highlighting}
\end{Shaded}

Rust will not let us use a value that has not been initialized. Next,
let's talk about this stuff we've added to \texttt{println!}.

If you include two curly braces (\texttt{\{\}}, some call them
moustaches\ldots{}) in your string to print, Rust will interpret this as
a request to interpolate some sort of value. \emph{String interpolation}
is a computer science term that means ``stick in the middle of a
string.'' We add a comma, and then \texttt{x}, to indicate that we want
\texttt{x} to be the value we're interpolating. The comma is used to
separate arguments we pass to functions and macros, if you're passing
more than one.

When you just use the curly braces, Rust will attempt to display the
value in a meaningful way by checking out its type. If you want to
specify the format in a more detailed manner, there are a
\href{http://doc.rust-lang.org/std/fmt/index.html}{wide number of
options available}. For now, we'll just stick to the default: integers
aren't very complicated to print.

\hyperdef{}{sec--functions}{\section{Functions}\label{sec--functions}}

Every Rust program has at least one function, the \texttt{main}
function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is the simplest possible function declaration. As we mentioned
before, \texttt{fn} says `this is a function', followed by the name,
some parentheses because this function takes no arguments, and then some
curly braces to indicate the body. Here's a function named \texttt{foo}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo() \{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

So, what about taking arguments? Here's a function that prints a number:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print_number(x: }\DataTypeTok{i32}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is: \{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here's a complete program that uses \texttt{print\_number}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \NormalTok{print_number(}\DecValTok{5}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{print_number(x: }\DataTypeTok{i32}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is: \{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As you can see, function arguments work very similar to \texttt{let}
declarations: you add a type to the argument name, after a colon.

Here's a complete program that adds two numbers together and prints
them:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \NormalTok{print_sum(}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{print_sum(x: }\DataTypeTok{i32}\NormalTok{, y: }\DataTypeTok{i32}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"sum is: \{\}"}\NormalTok{, x + y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You separate arguments with a comma, both when you call the function, as
well as when you declare it.

Unlike \texttt{let}, you \emph{must} declare the types of function
arguments. This does not work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print_sum(x, y) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"sum is: \{\}"}\NormalTok{, x + y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You get this error:

\begin{verbatim}
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
\end{verbatim}

This is a deliberate design decision. While full-program inference is
possible, languages which have it, like Haskell, often suggest that
documenting your types explicitly is a best-practice. We agree that
forcing functions to declare types while allowing for inference inside
of function bodies is a wonderful sweet spot between full inference and
no inference.

What about returning a value? Here's a function that adds one to an
integer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{add_one(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{x + }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Rust functions return exactly one value, and you declare the type after
an `arrow', which is a dash (\texttt{-}) followed by a greater-than sign
(\texttt{\textgreater{}}). The last line of a function determines what
it returns. You'll note the lack of a semicolon here. If we added it in:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{add_one(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{x + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We would get an error:

\begin{verbatim}
error: not all control paths return a value
fn add_one(x: i32) -> i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
\end{verbatim}

This reveals two interesting things about Rust: it is an
expression-based language, and semicolons are different from semicolons
in other `curly brace and semicolon'-based languages. These two things
are related.

\subsubsection{Expressions
vs.~Statements}\label{expressions-vs.statements}

Rust is primarily an expression-based language. There are only two kinds
of statements, and everything else is an expression.

So what's the difference? Expressions return a value, and statements do
not. That's why we end up with `not all control paths return a value'
here: the statement \texttt{x\ +\ 1;} doesn't return a value. There are
two kinds of statements in Rust: `declaration statements' and
`expression statements'. Everything else is an expression. Let's talk
about declaration statements first.

In some languages, variable bindings can be written as expressions, not
just statements. Like Ruby:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x = y = }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

In Rust, however, using \texttt{let} to introduce a binding is
\emph{not} an expression. The following will produce a compile-time
error:

\begin{verbatim}
let x = (let y = 5); // expected identifier, found keyword `let`
\end{verbatim}

The compiler is telling us here that it was expecting to see the
beginning of an expression, and a \texttt{let} can only begin a
statement, not an expression.

Note that assigning to an already-bound variable (e.g. \texttt{y\ =\ 5})
is still an expression, although its value is not particularly useful.
Unlike other languages where an assignment evaluates to the assigned
value (e.g. \texttt{5} in the previous example), in Rust the value of an
assignment is an empty tuple \texttt{()} because the assigned value can
have \hyperref[sec--ownership]{just one owner}, and any other returned
value would be too surprising:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{y = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{x = (y = }\DecValTok{6}\NormalTok{);  }\CommentTok{// x has the value `()`, not `6`}
\end{Highlighting}
\end{Shaded}

The second kind of statement in Rust is the \emph{expression statement}.
Its purpose is to turn any expression into a statement. In practical
terms, Rust's grammar expects statements to follow other statements.
This means that you use semicolons to separate expressions from each
other. This means that Rust looks a lot like most other languages that
require you to use semicolons at the end of every line, and you will see
semicolons at the end of almost every line of Rust code you see.

What is this exception that makes us say ``almost''? You saw it already,
in this code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{add_one(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{x + }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our function claims to return an \texttt{i32}, but with a semicolon, it
would return \texttt{()} instead. Rust realizes this probably isn't what
we want, and suggests removing the semicolon in the error we saw before.

\subsubsection{Early returns}\label{early-returns-1}

But what about early returns? Rust does have a keyword for that,
\texttt{return}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{return} \NormalTok{x;}

    \CommentTok{// we never run this code!}
    \NormalTok{x + }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Using a \texttt{return} as the last line of a function works, but is
considered poor style:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{return} \NormalTok{x + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The previous definition without \texttt{return} may look a bit strange
if you haven't worked in an expression-based language before, but it
becomes intuitive over time.

\subsubsection{Diverging functions}\label{diverging-functions}

Rust has some special syntax for `diverging functions', which are
functions that do not return:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{diverges() -> ! \{}
    \PreprocessorTok{panic!}\NormalTok{(}\StringTok{"This function never returns!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{panic!} is a macro, similar to \texttt{println!()} that we've
already seen. Unlike \texttt{println!()}, \texttt{panic!()} causes the
current thread of execution to crash with the given message. Because
this function will cause a crash, it will never return, and so it has
the type `\texttt{!}', which is read `diverges'.

If you add a main function that calls \texttt{diverges()} and run it,
you'll get some output that looks like this:

\begin{verbatim}
thread ‚Äò<main>‚Äô panicked at ‚ÄòThis function never returns!‚Äô, hello.rs:2
\end{verbatim}

If you want more information, you can get a backtrace by setting the
\texttt{RUST\_BACKTRACE} environment variable:

\begin{verbatim}
$ RUST_BACKTRACE=1 ./diverges
thread '<main>' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
\end{verbatim}

\texttt{RUST\_BACKTRACE} also works with Cargo's \texttt{run} command:

\begin{verbatim}
$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '<main>' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
\end{verbatim}

A diverging function can be used as any type:

\begin{verbatim}
# fn diverges() -> ! {
#    panic!("This function never returns!");
# }
let x: i32 = diverges();
let x: String = diverges();
\end{verbatim}

\subsubsection{Function pointers}\label{function-pointers}

We can also create variable bindings which point to functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{f: }\KeywordTok{fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{f} is a variable binding which points to a function that takes
an \texttt{i32} as an argument and returns an \texttt{i32}. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{plus_one(i: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{i + }\DecValTok{1}
\NormalTok{\}}

\CommentTok{// without type inference}
\KeywordTok{let} \NormalTok{f: }\KeywordTok{fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{= plus_one;}

\CommentTok{// with type inference}
\KeywordTok{let} \NormalTok{f = plus_one;}
\end{Highlighting}
\end{Shaded}

We can then use \texttt{f} to call the function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{six = f(}\DecValTok{5}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\section{Primitive Types}\label{sec--primitive-types}

The Rust language has a number of types that are considered `primitive'.
This means that they're built-in to the language. Rust is structured in
such a way that the standard library also provides a number of useful
types built on top of these ones, as well, but these are the most
primitive.

\subsection{Booleans}\label{booleans}

Rust has a built in boolean type, named \texttt{bool}. It has two
values, \texttt{true} and \texttt{false}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\ConstantTok{true}\NormalTok{;}

\KeywordTok{let} \NormalTok{y: }\DataTypeTok{bool} \NormalTok{= }\ConstantTok{false}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

A common use of booleans is in \hyperref[sec--if]{\texttt{if}
conditionals}.

You can find more documentation for \texttt{bool}s
\href{http://doc.rust-lang.org/std/primitive.bool.html}{in the standard
library documentation}.

\subsection{\texorpdfstring{\texttt{char}}{char}}\label{char}

The \texttt{char} type represents a single Unicode scalar value. You can
create \texttt{char}s with a single tick: (\texttt{\textquotesingle{}})

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\CharTok{'x'}\NormalTok{;}
\KeywordTok{let} \NormalTok{two_hearts = }\CharTok{'üíï'}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Unlike some other languages, this means that Rust's \texttt{char} is not
a single byte, but four.

You can find more documentation for \texttt{char}s
\href{http://doc.rust-lang.org/std/primitive.char.html}{in the standard
library documentation}.

\hyperdef{}{numeric-types}{\subsection{Numeric
types}\label{numeric-types}}

Rust has a variety of numeric types in a few categories: signed and
unsigned, fixed and variable, floating-point and integer.

These types consist of two parts: the category, and the size. For
example, \texttt{u16} is an unsigned type with sixteen bits of size.
More bits lets you have bigger numbers.

If a number literal has nothing to cause its type to be inferred, it
defaults:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{42}\NormalTok{; }\CommentTok{// x has type i32}

\KeywordTok{let} \NormalTok{y = }\DecValTok{1.0}\NormalTok{; }\CommentTok{// y has type f64}
\end{Highlighting}
\end{Shaded}

Here's a list of the different numeric types, with links to their
documentation in the standard library:

\begin{itemize}
\tightlist
\item
  \href{http://doc.rust-lang.org/std/primitive.i8.html}{i8}
\item
  \href{http://doc.rust-lang.org/std/primitive.i16.html}{i16}
\item
  \href{http://doc.rust-lang.org/std/primitive.i32.html}{i32}
\item
  \href{http://doc.rust-lang.org/std/primitive.i64.html}{i64}
\item
  \href{http://doc.rust-lang.org/std/primitive.u8.html}{u8}
\item
  \href{http://doc.rust-lang.org/std/primitive.u16.html}{u16}
\item
  \href{http://doc.rust-lang.org/std/primitive.u32.html}{u32}
\item
  \href{http://doc.rust-lang.org/std/primitive.u64.html}{u64}
\item
  \href{http://doc.rust-lang.org/std/primitive.isize.html}{isize}
\item
  \href{http://doc.rust-lang.org/std/primitive.usize.html}{usize}
\item
  \href{http://doc.rust-lang.org/std/primitive.f32.html}{f32}
\item
  \href{http://doc.rust-lang.org/std/primitive.f64.html}{f64}
\end{itemize}

Let's go over them by category:

\subsubsection{Signed and Unsigned}\label{signed-and-unsigned}

Integer types come in two varieties: signed and unsigned. To understand
the difference, let's consider a number with four bits of size. A
signed, four-bit number would let you store numbers from \texttt{-8} to
\texttt{+7}. Signed numbers use ``two's complement representation''. An
unsigned four bit number, since it does not need to store negatives, can
store values from \texttt{0} to \texttt{+15}.

Unsigned types use a \texttt{u} for their category, and signed types use
\texttt{i}. The \texttt{i} is for `integer'. So \texttt{u8} is an
eight-bit unsigned number, and \texttt{i8} is an eight-bit signed
number.

\subsubsection{Fixed size types}\label{fixed-size-types}

Fixed size types have a specific number of bits in their representation.
Valid bit sizes are \texttt{8}, \texttt{16}, \texttt{32}, and
\texttt{64}. So, \texttt{u32} is an unsigned, 32-bit integer, and
\texttt{i64} is a signed, 64-bit integer.

\subsubsection{Variable sized types}\label{variable-sized-types}

Rust also provides types whose size depends on the size of a pointer of
the underlying machine. These types have `size' as the category, and
come in signed and unsigned varieties. This makes for two types:
\texttt{isize} and \texttt{usize}.

\subsubsection{Floating-point types}\label{floating-point-types}

Rust also has two floating point types: \texttt{f32} and \texttt{f64}.
These correspond to IEEE-754 single and double precision numbers.

\subsection{Arrays}\label{arrays}

Like many programming languages, Rust has list types to represent a
sequence of things. The most basic is the \emph{array}, a fixed-size
list of elements of the same type. By default, arrays are immutable.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a = [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]; }\CommentTok{// a: [i32; 3]}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{m = [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]; }\CommentTok{// m: [i32; 3]}
\end{Highlighting}
\end{Shaded}

Arrays have type \texttt{{[}T;\ N{]}}. We'll talk about this \texttt{T}
notation \hyperref[sec--generics]{in the generics section}. The
\texttt{N} is a compile-time constant, for the length of the array.

There's a shorthand for initializing each element of an array to the
same value. In this example, each element of \texttt{a} will be
initialized to \texttt{0}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a = [}\DecValTok{0}\NormalTok{; }\DecValTok{20}\NormalTok{]; }\CommentTok{// a: [i32; 20]}
\end{Highlighting}
\end{Shaded}

You can get the number of elements in an array \texttt{a} with
\texttt{a.len()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a = [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"a has \{\} elements"}\NormalTok{, a.len());}
\end{Highlighting}
\end{Shaded}

You can access a particular element of an array with \emph{subscript
notation}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{names = [}\StringTok{"Graydon"}\NormalTok{, }\StringTok{"Brian"}\NormalTok{, }\StringTok{"Niko"}\NormalTok{]; }\CommentTok{// names: [&str; 3]}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"The second name is: \{\}"}\NormalTok{, names[}\DecValTok{1}\NormalTok{]);}
\end{Highlighting}
\end{Shaded}

Subscripts start at zero, like in most programming languages, so the
first name is \texttt{names{[}0{]}} and the second name is
\texttt{names{[}1{]}}. The above example prints
\texttt{The\ second\ name\ is:\ Brian}. If you try to use a subscript
that is not in the array, you will get an error: array access is
bounds-checked at run-time. Such errant access is the source of many
bugs in other systems programming languages.

You can find more documentation for \texttt{array}s
\href{http://doc.rust-lang.org/std/primitive.array.html}{in the standard
library documentation}.

\subsection{Slices}\label{slices}

A `slice' is a reference to (or ``view'' into) another data structure.
They are useful for allowing safe, efficient access to a portion of an
array without copying. For example, you might want to reference just one
line of a file read into memory. By nature, a slice is not created
directly, but from an existing variable. Slices have a length, can be
mutable or not, and in many ways behave like arrays:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a = [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{];}
\KeywordTok{let} \NormalTok{middle = &a[}\DecValTok{1.}\NormalTok{.}\DecValTok{4}\NormalTok{]; }\CommentTok{// A slice of a: just the elements 1, 2, and 3}
\KeywordTok{let} \NormalTok{complete = &a[..]; }\CommentTok{// A slice containing all of the elements in a}
\end{Highlighting}
\end{Shaded}

Slices have type \texttt{\&{[}T{]}}. We'll talk about that \texttt{T}
when we cover \hyperref[sec--generics]{generics}.

You can find more documentation for slices
\href{http://doc.rust-lang.org/std/primitive.slice.html}{in the standard
library documentation}.

\subsection{\texorpdfstring{\texttt{str}}{str}}\label{str}

Rust's \texttt{str} type is the most primitive string type. As an
\hyperref[sec--unsized-types]{unsized type}, it's not very useful by
itself, but becomes useful when placed behind a reference, like
\hyperref[sec--strings]{\texttt{\&str}}. As such, we'll just leave it at
that.

You can find more documentation for \texttt{str}
\href{http://doc.rust-lang.org/std/primitive.str.html}{in the standard
library documentation}.

\hyperdef{}{tuples}{\subsection{Tuples}\label{tuples}}

A tuple is an ordered list of fixed size. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = (}\DecValTok{1}\NormalTok{, }\StringTok{"hello"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

The parentheses and commas form this two-length tuple. Here's the same
code, but with the type annotated:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: (}\DataTypeTok{i32}\NormalTok{, &}\DataTypeTok{str}\NormalTok{) = (}\DecValTok{1}\NormalTok{, }\StringTok{"hello"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

As you can see, the type of a tuple looks just like the tuple, but with
each position having a type name rather than the value. Careful readers
will also note that tuples are heterogeneous: we have an \texttt{i32}
and a \texttt{\&str} in this tuple. In systems programming languages,
strings are a bit more complex than in other languages. For now, just
read \texttt{\&str} as a \emph{string slice}, and we'll learn more soon.

You can assign one tuple into another, if they have the same contained
types and \hyperref[arity]{arity}. Tuples have the same arity when they
have the same length.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{); }\CommentTok{// x: (i32, i32)}
\KeywordTok{let} \NormalTok{y = (}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{); }\CommentTok{// y: (i32, i32)}

\NormalTok{x = y;}
\end{Highlighting}
\end{Shaded}

You can access the fields in a tuple through a \emph{destructuring let}.
Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{(x, y, z) = (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is \{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

Remember \hyperref[sec--variable-bindings]{before} when I said the
left-hand side of a \texttt{let} statement was more powerful than just
assigning a binding? Here we are. We can put a pattern on the left-hand
side of the \texttt{let}, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, \texttt{let}
``destructures'' or ``breaks up'' the tuple, and assigns the bits to
three bindings.

This pattern is very powerful, and we'll see it repeated more later.

You can disambiguate a single-element tuple from a value in parentheses
with a comma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{0}\NormalTok{,); }\CommentTok{// single-element tuple}
\NormalTok{(}\DecValTok{0}\NormalTok{); }\CommentTok{// zero in parentheses}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tuple Indexing}\label{tuple-indexing}

You can also access fields of a tuple with indexing syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{tuple = (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}

\KeywordTok{let} \NormalTok{x = tuple.}\DecValTok{0}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = tuple.}\DecValTok{1}\NormalTok{;}
\KeywordTok{let} \NormalTok{z = tuple.}\DecValTok{2}\NormalTok{;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is \{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

Like array indexing, it starts at zero, but unlike array indexing, it
uses a \texttt{.}, rather than \texttt{{[}{]}}s.

You can find more documentation for tuples
\href{http://doc.rust-lang.org/std/primitive.tuple.html}{in the standard
library documentation}.

\subsection{Functions}\label{functions}

Functions also have a type! They look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{ x \}}

\KeywordTok{let} \NormalTok{x: }\KeywordTok{fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{= foo;}
\end{Highlighting}
\end{Shaded}

In this case, \texttt{x} is a `function pointer' to a function that
takes an \texttt{i32} and returns an \texttt{i32}.

\hyperdef{}{sec--comments}{\section{Comments}\label{sec--comments}}

Now that we have some functions, it's a good idea to learn about
comments. Comments are notes that you leave to other programmers to help
explain things about your code. The compiler mostly ignores them.

Rust has two kinds of comments that you should care about: \emph{line
comments} and \emph{doc comments}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Line comments are anything after ‚Äò//‚Äô and extend to the end of the line.}

\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{; }\CommentTok{// this is also a line comment.}

\CommentTok{// If you have a long explanation for something, you can put line comments next}
\CommentTok{// to each other. Put a space between the // and your comment so that it‚Äôs}
\CommentTok{// more readable.}
\end{Highlighting}
\end{Shaded}

The other kind of comment is a doc comment. Doc comments use
\texttt{///} instead of \texttt{//}, and support Markdown notation
inside:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/// Adds one to the number given.}
\CommentTok{///}
\CommentTok{/// # Examples}
\CommentTok{///}
\CommentTok{/// ```}
\CommentTok{/// let five = 5;}
\CommentTok{///}
\CommentTok{/// assert_eq!(6, add_one(5));}
\CommentTok{/// # fn add_one(x: i32) -> i32 \{}
\CommentTok{/// #     x + 1}
\CommentTok{/// # \}}
\CommentTok{/// ```}
\KeywordTok{fn} \NormalTok{add_one(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{x + }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There is another style of doc comment, \texttt{//!}, to comment
containing items (e.g.~crates, modules or functions), instead of the
items following it. Commonly used inside crates root (lib.rs) or modules
root (mod.rs):

\begin{verbatim}
//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
\end{verbatim}

When writing doc comments, providing some examples of usage is very,
very helpful. You'll notice we've used a new macro here:
\texttt{assert\_eq!}. This compares two values, and \texttt{panic!}s if
they're not equal to each other. It's very helpful in documentation.
There's another macro, \texttt{assert!}, which \texttt{panic!}s if the
value passed to it is \texttt{false}.

You can use the \hyperref[sec--documentation]{\texttt{rustdoc}} tool to
generate HTML documentation from these doc comments, and also to run the
code examples as tests!

\hyperdef{}{sec--if}{\section{if}\label{sec--if}}

Rust's take on \texttt{if} is not particularly complex, but it's much
more like the \texttt{if} you'll find in a dynamically typed language
than in a more traditional systems language. So let's talk about it, to
make sure you grasp the nuances.

\texttt{if} is a specific form of a more general concept, the `branch'.
The name comes from a branch in a tree: a decision point, where
depending on a choice, multiple paths can be taken.

In the case of \texttt{if}, there is one choice that leads down two
paths:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == }\DecValTok{5} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is five!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we changed the value of \texttt{x} to something else, this line would
not print. More specifically, if the expression after the \texttt{if}
evaluates to \texttt{true}, then the block is executed. If it's
\texttt{false}, then it is not.

If you want something to happen in the \texttt{false} case, use an
\texttt{else}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == }\DecValTok{5} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is five!"}\NormalTok{);}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is not five :("}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If there is more than one case, use an \texttt{else\ if}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == }\DecValTok{5} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is five!"}\NormalTok{);}
\NormalTok{\} }\KeywordTok{else} \KeywordTok{if} \NormalTok{x == }\DecValTok{6} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is six!"}\NormalTok{);}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is not five or six :("}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is all pretty standard. However, you can also do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{y = }\KeywordTok{if} \NormalTok{x == }\DecValTok{5} \NormalTok{\{}
    \DecValTok{10}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \DecValTok{15}
\NormalTok{\}; }\CommentTok{// y: i32}
\end{Highlighting}
\end{Shaded}

Which we can (and probably should) write like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{y = }\KeywordTok{if} \NormalTok{x == }\DecValTok{5} \NormalTok{\{ }\DecValTok{10} \NormalTok{\} }\KeywordTok{else} \NormalTok{\{ }\DecValTok{15} \NormalTok{\}; }\CommentTok{// y: i32}
\end{Highlighting}
\end{Shaded}

This works because \texttt{if} is an expression. The value of the
expression is the value of the last expression in whichever branch was
chosen. An \texttt{if} without an \texttt{else} always results in
\texttt{()} as the value.

\section{Loops}\label{sec--loops}

Rust currently provides three approaches to performing some kind of
iterative activity. They are: \texttt{loop}, \texttt{while} and
\texttt{for}. Each approach has its own set of uses.

\subsubsection{loop}\label{loop}

The infinite \texttt{loop} is the simplest form of loop available in
Rust. Using the keyword \texttt{loop}, Rust provides a way to loop
indefinitely until some terminating statement is reached. Rust's
infinite \texttt{loop}s look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{loop} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Loop forever!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{while}\label{while}

Rust also has a \texttt{while} loop. It looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{; }\CommentTok{// mut x: i32}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{done = }\ConstantTok{false}\NormalTok{; }\CommentTok{// mut done: bool}

\KeywordTok{while} \NormalTok{!done \{}
    \NormalTok{x += x - }\DecValTok{3}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}

    \KeywordTok{if} \NormalTok{x % }\DecValTok{5} \NormalTok{== }\DecValTok{0} \NormalTok{\{}
        \NormalTok{done = }\ConstantTok{true}\NormalTok{;}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{while} loops are the correct choice when you're not sure how
many times you need to loop.

If you need an infinite loop, you may be tempted to write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{while} \ConstantTok{true} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

However, \texttt{loop} is far better suited to handle this case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{loop} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

Rust's control-flow analysis treats this construct differently than a
\texttt{while\ true}, since we know that it will always loop. In
general, the more information we can give to the compiler, the better it
can do with safety and code generation, so you should always prefer
\texttt{loop} when you plan to loop infinitely.

\subsubsection{for}\label{for}

The \texttt{for} loop is used to loop a particular number of times.
Rust's \texttt{for} loops work a bit differently than in other systems
languages, however. Rust's \texttt{for} loop doesn't look like this
``C-style'' \texttt{for} loop:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{(x = }\DecValTok{0}\NormalTok{; x < }\DecValTok{10}\NormalTok{; x++) \{}
    \NormalTok{printf( }\StringTok{"%d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, x );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Instead, it looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{x }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x); }\CommentTok{// x: i32}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In slightly more abstract terms,

\begin{verbatim}
for var in expression {
    code
}
\end{verbatim}

The expression is an \hyperref[sec--iterators]{iterator}. The iterator
gives back a series of elements. Each element is one iteration of the
loop. That value is then bound to the name \texttt{var}, which is valid
for the loop body. Once the body is over, the next value is fetched from
the iterator, and we loop another time. When there are no more values,
the \texttt{for} loop is over.

In our example, \texttt{0..10} is an expression that takes a start and
an end position, and gives an iterator over those values. The upper
bound is exclusive, though, so our loop will print \texttt{0} through
\texttt{9}, not \texttt{10}.

Rust does not have the ``C-style'' \texttt{for} loop on purpose.
Manually controlling each element of the loop is complicated and error
prone, even for experienced C developers.

\paragraph{Enumerate}\label{enumerate}

When you need to keep track of how many times you already looped, you
can use the \texttt{.enumerate()} function.

\subparagraph{On ranges:}\label{on-ranges}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{(i,j) }\KeywordTok{in} \NormalTok{(}\DecValTok{5.}\NormalTok{.}\DecValTok{10}\NormalTok{).enumerate() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"i = \{\} and j = \{\}"}\NormalTok{, i, j);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Outputs:

\begin{verbatim}
i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
\end{verbatim}

Don't forget to add the parentheses around the range.

\subparagraph{On iterators:}\label{on-iterators}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{(linenumber, line) }\KeywordTok{in} \NormalTok{lines.enumerate() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}: \{\}"}\NormalTok{, linenumber, line);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Outputs:

\begin{verbatim}
0: Content of line one
1: Content of line two
2: Content of line three
3: Content of line four
\end{verbatim}

\subsubsection{Ending iteration early}\label{ending-iteration-early}

Let's take a look at that \texttt{while} loop we had earlier:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{done = }\ConstantTok{false}\NormalTok{;}

\KeywordTok{while} \NormalTok{!done \{}
    \NormalTok{x += x - }\DecValTok{3}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}

    \KeywordTok{if} \NormalTok{x % }\DecValTok{5} \NormalTok{== }\DecValTok{0} \NormalTok{\{}
        \NormalTok{done = }\ConstantTok{true}\NormalTok{;}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We had to keep a dedicated \texttt{mut} boolean variable binding,
\texttt{done}, to know when we should exit out of the loop. Rust has two
keywords to help us with modifying iteration: \texttt{break} and
\texttt{continue}.

In this case, we can write the loop in a better way with \texttt{break}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{loop} \NormalTok{\{}
    \NormalTok{x += x - }\DecValTok{3}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}

    \KeywordTok{if} \NormalTok{x % }\DecValTok{5} \NormalTok{== }\DecValTok{0} \NormalTok{\{ }\KeywordTok{break}\NormalTok{; \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We now loop forever with \texttt{loop} and use \texttt{break} to break
out early. Issuing an explicit \texttt{return} statement will also serve
to terminate the loop early.

\texttt{continue} is similar, but instead of ending the loop, goes to
the next iteration. This will only print the odd numbers:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \NormalTok{x }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
    \KeywordTok{if} \NormalTok{x % }\DecValTok{2} \NormalTok{== }\DecValTok{0} \NormalTok{\{ }\KeywordTok{continue}\NormalTok{; \}}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Loop labels}\label{loop-labels}

You may also encounter situations where you have nested loops and need
to specify which one your \texttt{break} or \texttt{continue} statement
is for. Like most other languages, by default a \texttt{break} or
\texttt{continue} will apply to innermost loop. In a situation where you
would like to a \texttt{break} or \texttt{continue} for one of the outer
loops, you can use labels to specify which loop the \texttt{break} or
\texttt{continue} statement applies to. This will only print when both
\texttt{x} and \texttt{y} are odd:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{'outer}\NormalTok{: }\KeywordTok{for} \NormalTok{x }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
    \OtherTok{'inner}\NormalTok{: }\KeywordTok{for} \NormalTok{y }\KeywordTok{in} \DecValTok{0.}\NormalTok{.}\DecValTok{10} \NormalTok{\{}
        \KeywordTok{if} \NormalTok{x % }\DecValTok{2} \NormalTok{== }\DecValTok{0} \NormalTok{\{ }\KeywordTok{continue} \OtherTok{'outer}\NormalTok{; \} }\CommentTok{// continues the loop over x}
        \KeywordTok{if} \NormalTok{y % }\DecValTok{2} \NormalTok{== }\DecValTok{0} \NormalTok{\{ }\KeywordTok{continue} \OtherTok{'inner}\NormalTok{; \} }\CommentTok{// continues the loop over y}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x: \{\}, y: \{\}"}\NormalTok{, x, y);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--ownership}{\section{Ownership}\label{sec--ownership}}

This guide is one of three presenting Rust's ownership system. This is
one of Rust's most unique and compelling features, with which Rust
developers should become quite acquainted. Ownership is how Rust
achieves its largest goal, memory safety. There are a few distinct
concepts, each with its own chapter:

\begin{itemize}
\tightlist
\item
  ownership, which you're reading now
\item
  \hyperref[sec--references-and-borrowing]{borrowing}, and their
  associated feature `references'
\item
  \hyperref[sec--lifetimes]{lifetimes}, an advanced concept of borrowing
\end{itemize}

These three chapters are related, and in order. You'll need all three to
fully understand the ownership system.

\subsection{Meta}\label{meta}

Before we get to the details, two important notes about the ownership
system.

Rust has a focus on safety and speed. It accomplishes these goals
through many `zero-cost abstractions', which means that in Rust,
abstractions cost as little as possible in order to make them work. The
ownership system is a prime example of a zero-cost abstraction. All of
the analysis we'll talk about in this guide is \emph{done at compile
time}. You do not pay any run-time cost for any of these features.

However, this system does have a certain cost: learning curve. Many new
users to Rust experience something we like to call `fighting with the
borrow checker', where the Rust compiler refuses to compile a program
that the author thinks is valid. This often happens because the
programmer's mental model of how ownership should work doesn't match the
actual rules that Rust implements. You probably will experience similar
things at first. There is good news, however: more experienced Rust
developers report that once they work with the rules of the ownership
system for a period of time, they fight the borrow checker less and
less.

With that in mind, let's learn about ownership.

\subsection{Ownership}\label{ownership}

\hyperref[sec--variable-bindings]{Variable bindings} have a property in
Rust: they `have ownership' of what they're bound to. This means that
when a binding goes out of scope, Rust will free the bound resources.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo() \{}
    \KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When \texttt{v} comes into scope, a new
\href{http://doc.rust-lang.org/std/vec/struct.Vec.html}{\texttt{Vec\textless{}T\textgreater{}}}
is created. In this case, the vector also allocates space on
\hyperref[sec--the-stack-and-the-heap]{the heap}, for the three
elements. When \texttt{v} goes out of scope at the end of
\texttt{foo()}, Rust will clean up everything related to the vector,
even the heap-allocated memory. This happens deterministically, at the
end of the scope.

\hyperdef{}{move-semantics}{\subsection{Move
semantics}\label{move-semantics}}

There's some more subtlety here, though: Rust ensures that there is
\emph{exactly one} binding to any given resource. For example, if we
have a vector, we can assign it to another binding:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{v2 = v;}
\end{Highlighting}
\end{Shaded}

But, if we try to use \texttt{v} afterwards, we get an error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{v2 = v;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"v[0] is: \{\}"}\NormalTok{, v[}\DecValTok{0}\NormalTok{]);}
\end{Highlighting}
\end{Shaded}

It looks like this:

\begin{verbatim}
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
\end{verbatim}

A similar thing happens if we define a function which takes ownership,
and try to use something after we've passed it as an argument:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{take(v: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) \{}
    \CommentTok{// what happens here isn‚Äôt important.}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\NormalTok{take(v);}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"v[0] is: \{\}"}\NormalTok{, v[}\DecValTok{0}\NormalTok{]);}
\end{Highlighting}
\end{Shaded}

Same error: `use of moved value'. When we transfer ownership to
something else, we say that we've `moved' the thing we refer to. You
don't need some sort of special annotation here, it's the default thing
that Rust does.

\subsubsection{The details}\label{the-details}

The reason that we cannot use a binding after we've moved it is subtle,
but important. When we write code like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{v2 = v;}
\end{Highlighting}
\end{Shaded}

The first line allocates memory for the vector object, \texttt{v}, and
for the data it contains. The vector object is stored on the
\hyperref[sec--the-stack-and-the-heap]{stack} and contains a pointer to
the content (\texttt{{[}1,\ 2,\ 3{]}}) stored on the
\hyperref[sec--the-stack-and-the-heap]{heap}. When we move \texttt{v} to
\texttt{v2}, it creates a copy of that pointer, for \texttt{v2}. Which
means that there would be two pointers to the content of the vector on
the heap. It would violate Rust's safety guarantees by introducing a
data race. Therefore, Rust forbids using \texttt{v} after we've done the
move.

It's also important to note that optimizations may remove the actual
copy of the bytes on the stack, depending on circumstances. So it may
not be as inefficient as it initially seems.

\subsubsection{\texorpdfstring{\texttt{Copy}
types}{Copy types}}\label{copy-types}

We've established that when ownership is transferred to another binding,
you cannot use the original binding. However, there's a
\hyperref[sec--traits]{trait} that changes this behavior, and it's
called \texttt{Copy}. We haven't discussed traits yet, but for now, you
can think of them as an annotation to a particular type that adds extra
behavior. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\DecValTok{1}\NormalTok{;}

\KeywordTok{let} \NormalTok{v2 = v;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"v is: \{\}"}\NormalTok{, v);}
\end{Highlighting}
\end{Shaded}

In this case, \texttt{v} is an \texttt{i32}, which implements the
\texttt{Copy} trait. This means that, just like a move, when we assign
\texttt{v} to \texttt{v2}, a copy of the data is made. But, unlike a
move, we can still use \texttt{v} afterward. This is because an
\texttt{i32} has no pointers to data somewhere else, copying it is a
full copy.

All primitive types implement the \texttt{Copy} trait and their
ownership is therefore not moved like one would assume, following the
¬¥ownership rules¬¥. To give an example, the two following snippets of
code only compile because the \texttt{i32} and \texttt{bool} types
implement the \texttt{Copy} trait.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{a = }\DecValTok{5}\NormalTok{;}

    \KeywordTok{let} \NormalTok{_y = double(a);}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, a);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{double(x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{x * }\DecValTok{2}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{a = }\ConstantTok{true}\NormalTok{;}

    \KeywordTok{let} \NormalTok{_y = change_truth(a);}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, a);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{change_truth(x: }\DataTypeTok{bool}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
    \NormalTok{!x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we would have used types that do not implement the \texttt{Copy}
trait, we would have gotten a compile error because we tried to use a
moved value.

\begin{verbatim}
error: use of moved value: `a`
println!("{}", a);
               ^
\end{verbatim}

We will discuss how to make your own types \texttt{Copy} in the
\hyperref[sec--traits]{traits} section.

\subsection{More than ownership}\label{more-than-ownership}

Of course, if we had to hand ownership back with every function we
wrote:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(v: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) -> }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{> \{}
    \CommentTok{// do stuff with v}

    \CommentTok{// hand back ownership}
    \NormalTok{v}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This would get very tedious. It gets worse the more things we want to
take ownership of:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(v1: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, v2: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) -> (}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, }\DataTypeTok{i32}\NormalTok{) \{}
    \CommentTok{// do stuff with v1 and v2}

    \CommentTok{// hand back ownership, and the result of our function}
    \NormalTok{(v1, v2, }\DecValTok{42}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{v1 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
\KeywordTok{let} \NormalTok{v2 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{(v1, v2, answer) = foo(v1, v2);}
\end{Highlighting}
\end{Shaded}

Ugh! The return type, return line, and calling the function gets way
more complicated.

Luckily, Rust offers a feature, borrowing, which helps us solve this
problem. It's the topic of the next section!

\hyperdef{}{sec--references-and-borrowing}{\section{References and
Borrowing}\label{sec--references-and-borrowing}}

This guide is one of three presenting Rust's ownership system. This is
one of Rust's most unique and compelling features, with which Rust
developers should become quite acquainted. Ownership is how Rust
achieves its largest goal, memory safety. There are a few distinct
concepts, each with its own chapter:

\begin{itemize}
\tightlist
\item
  \hyperref[sec--ownership]{ownership}, the key concept
\item
  borrowing, which you're reading now
\item
  \hyperref[sec--lifetimes]{lifetimes}, an advanced concept of borrowing
\end{itemize}

These three chapters are related, and in order. You'll need all three to
fully understand the ownership system.

\subsection{Meta}\label{meta-1}

Before we get to the details, two important notes about the ownership
system.

Rust has a focus on safety and speed. It accomplishes these goals
through many `zero-cost abstractions', which means that in Rust,
abstractions cost as little as possible in order to make them work. The
ownership system is a prime example of a zero cost abstraction. All of
the analysis we'll talk about in this guide is \emph{done at compile
time}. You do not pay any run-time cost for any of these features.

However, this system does have a certain cost: learning curve. Many new
users to Rust experience something we like to call `fighting with the
borrow checker', where the Rust compiler refuses to compile a program
that the author thinks is valid. This often happens because the
programmer's mental model of how ownership should work doesn't match the
actual rules that Rust implements. You probably will experience similar
things at first. There is good news, however: more experienced Rust
developers report that once they work with the rules of the ownership
system for a period of time, they fight the borrow checker less and
less.

With that in mind, let's learn about borrowing.

\hyperdef{}{borrowing}{\subsection{Borrowing}\label{borrowing}}

At the end of the \hyperref[sec--ownership]{ownership} section, we had a
nasty function that looked like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(v1: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, v2: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) -> (}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, }\DataTypeTok{i32}\NormalTok{) \{}
    \CommentTok{// do stuff with v1 and v2}

    \CommentTok{// hand back ownership, and the result of our function}
    \NormalTok{(v1, v2, }\DecValTok{42}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{v1 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
\KeywordTok{let} \NormalTok{v2 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{(v1, v2, answer) = foo(v1, v2);}
\end{Highlighting}
\end{Shaded}

This is not idiomatic Rust, however, as it doesn't take advantage of
borrowing. Here's the first step:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(v1: &}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>, v2: &}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) -> }\DataTypeTok{i32} \NormalTok{\{}
    \CommentTok{// do stuff with v1 and v2}

    \CommentTok{// return the answer}
    \DecValTok{42}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{v1 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
\KeywordTok{let} \NormalTok{v2 = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{answer = foo(&v1, &v2);}

\CommentTok{// we can use v1 and v2 here!}
\end{Highlighting}
\end{Shaded}

Instead of taking \texttt{Vec\textless{}i32\textgreater{}}s as our
arguments, we take a reference:
\texttt{\&Vec\textless{}i32\textgreater{}}. And instead of passing
\texttt{v1} and \texttt{v2} directly, we pass \texttt{\&v1} and
\texttt{\&v2}. We call the \texttt{\&T} type a `reference', and rather
than owning the resource, it borrows ownership. A binding that borrows
something does not deallocate the resource when it goes out of scope.
This means that after the call to \texttt{foo()}, we can use our
original bindings again.

References are immutable, just like bindings. This means that inside of
\texttt{foo()}, the vectors can't be changed at all:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(v: &}\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{i32}\NormalTok{>) \{}
     \NormalTok{v.push(}\DecValTok{5}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[];}

\NormalTok{foo(&v);}
\end{Highlighting}
\end{Shaded}

errors with:

\begin{verbatim}
error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
\end{verbatim}

Pushing a value mutates the vector, and so we aren't allowed to do it.

\subsection{\&mut references}\label{mut-references}

There's a second kind of reference: \texttt{\&mut\ T}. A `mutable
reference' allows you to mutate the resource you're borrowing. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\NormalTok{\{}
    \KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;}
    \NormalTok{*y += }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

This will print \texttt{6}. We make \texttt{y} a mutable reference to
\texttt{x}, then add one to the thing \texttt{y} points at. You'll
notice that \texttt{x} had to be marked \texttt{mut} as well, if it
wasn't, we couldn't take a mutable borrow to an immutable value.

You'll also notice we added an asterisk (\texttt{*}) in front of
\texttt{y}, making it \texttt{*y}, this is because \texttt{y} is an
\texttt{\&mut} reference. You'll also need to use them for accessing the
contents of a reference as well.

Otherwise, \texttt{\&mut} references are just like references. There
\emph{is} a large difference between the two, and how they interact,
though. You can tell something is fishy in the above example, because we
need that extra scope, with the \texttt{\{} and \texttt{\}}. If we
remove them, we get an error:

\begin{verbatim}
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
\end{verbatim}

As it turns out, there are rules.

\subsection{The Rules}\label{the-rules}

Here's the rules about borrowing in Rust:

First, any borrow must last for a scope no greater than that of the
owner. Second, you may have one or the other of these two kinds of
borrows, but not both at the same time:

\begin{itemize}
\tightlist
\item
  one or more references (\texttt{\&T}) to a resource,
\item
  exactly one mutable reference (\texttt{\&mut\ T}).
\end{itemize}

You may notice that this is very similar, though not exactly the same
as, to the definition of a data race:

\begin{quote}
There is a `data race' when two or more pointers access the same memory
location at the same time, where at least one of them is writing, and
the operations are not synchronized.
\end{quote}

With references, you may have as many as you'd like, since none of them
are writing. If you are writing, you need two or more pointers to the
same memory, and you can only have one \texttt{\&mut} at a time. This is
how Rust prevents data races at compile time: we'll get errors if we
break the rules.

With this in mind, let's consider our example again.

\subsubsection{Thinking in scopes}\label{thinking-in-scopes}

Here's the code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;}

\NormalTok{*y += }\DecValTok{1}\NormalTok{;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

This code gives us this error:

\begin{verbatim}
error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!("{}", x);
                   ^
\end{verbatim}

This is because we've violated the rules: we have a \texttt{\&mut\ T}
pointing to \texttt{x}, and so we aren't allowed to create any
\texttt{\&T}s. One or the other. The note hints at how to think about
this problem:

\begin{verbatim}
note: previous borrow ends here
fn main() {

}
^
\end{verbatim}

In other words, the mutable borrow is held through the rest of our
example. What we want is for the mutable borrow to end \emph{before} we
try to call \texttt{println!} and make an immutable borrow. In Rust,
borrowing is tied to the scope that the borrow is valid for. And our
scopes look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;    }\CommentTok{// -+ &mut borrow of x starts here}
                   \CommentTok{//  |}
\NormalTok{*y += }\DecValTok{1}\NormalTok{;           }\CommentTok{//  |}
                   \CommentTok{//  |}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x); }\CommentTok{// -+ - try to borrow x here}
                   \CommentTok{// -+ &mut borrow of x ends here}
\end{Highlighting}
\end{Shaded}

The scopes conflict: we can't make an \texttt{\&x} while \texttt{y} is
in scope.

So when we add the curly braces:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\NormalTok{\{                   }
    \KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x; }\CommentTok{// -+ &mut borrow starts here}
    \NormalTok{*y += }\DecValTok{1}\NormalTok{;        }\CommentTok{//  |}
\NormalTok{\}                   }\CommentTok{// -+ ... and ends here}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);  }\CommentTok{// <- try to borrow x here}
\end{Highlighting}
\end{Shaded}

There's no problem. Our mutable borrow goes out of scope before we
create an immutable one. But scope is the key to seeing how long a
borrow lasts for.

\subsubsection{Issues borrowing
prevents}\label{issues-borrowing-prevents}

Why have these restrictive rules? Well, as we noted, these rules prevent
data races. What kinds of issues do data races cause? Here's a few.

\paragraph{Iterator invalidation}\label{iterator-invalidation}

One example is `iterator invalidation', which happens when you try to
mutate a collection that you're iterating over. Rust's borrow checker
prevents this from happening:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{&v \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, i);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints out one through three. As we iterate through the vectors,
we're only given references to the elements. And \texttt{v} is itself
borrowed as immutable, which means we can't change it while we're
iterating:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{&v \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, i);}
    \NormalTok{v.push(}\DecValTok{34}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here's the error:

\begin{verbatim}
error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &v {
          ^
note: previous borrow ends here
for i in &v {
    println!(‚Äú{}‚Äù, i);
    v.push(34);
}
^
\end{verbatim}

We can't modify \texttt{v} because it's borrowed by the loop.

\paragraph{use after free}\label{use-after-free}

References must not live longer than the resource they refer to. Rust
will check the scopes of your references to ensure that this is true.

If Rust didn't check this property, we could accidentally use a
reference which was invalid. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{y: &}\DataTypeTok{i32}\NormalTok{;}
\NormalTok{\{ }
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
    \NormalTok{y = &x;}
\NormalTok{\}}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, y);}
\end{Highlighting}
\end{Shaded}

We get this error:

\begin{verbatim}
error: `x` does not live long enough
    y = &x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &i32;
{ 
    let x = 5;
    y = &x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &x;
}
\end{verbatim}

In other words, \texttt{y} is only valid for the scope where \texttt{x}
exists. As soon as \texttt{x} goes away, it becomes invalid to refer to
it. As such, the error says that the borrow `doesn't live long enough'
because it's not valid for the right amount of time.

The same problem occurs when the reference is declared \emph{before} the
variable it refers to. This is because resources within the same scope
are freed in the opposite order they were declared:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{y: &}\DataTypeTok{i32}\NormalTok{;}
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\NormalTok{y = &x;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, y);}
\end{Highlighting}
\end{Shaded}

We get this error:

\begin{verbatim}
error: `x` does not live long enough
y = &x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &i32;
    let x = 5;
    y = &x;
    
    println!("{}", y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &x;
    
    println!("{}", y);
}
\end{verbatim}

In the above example, \texttt{y} is declared before \texttt{x}, meaning
that \texttt{y} lives longer than \texttt{x}, which is not allowed.

\hyperdef{}{sec--lifetimes}{\section{Lifetimes}\label{sec--lifetimes}}

This guide is one of three presenting Rust's ownership system. This is
one of Rust's most unique and compelling features, with which Rust
developers should become quite acquainted. Ownership is how Rust
achieves its largest goal, memory safety. There are a few distinct
concepts, each with its own chapter:

\begin{itemize}
\tightlist
\item
  \hyperref[sec--ownership]{ownership}, the key concept
\item
  \hyperref[sec--references-and-borrowing]{borrowing}, and their
  associated feature `references'
\item
  lifetimes, which you're reading now
\end{itemize}

These three chapters are related, and in order. You'll need all three to
fully understand the ownership system.

\subsection{Meta}\label{meta-2}

Before we get to the details, two important notes about the ownership
system.

Rust has a focus on safety and speed. It accomplishes these goals
through many `zero-cost abstractions', which means that in Rust,
abstractions cost as little as possible in order to make them work. The
ownership system is a prime example of a zero-cost abstraction. All of
the analysis we'll talk about in this guide is \emph{done at compile
time}. You do not pay any run-time cost for any of these features.

However, this system does have a certain cost: learning curve. Many new
users to Rust experience something we like to call `fighting with the
borrow checker', where the Rust compiler refuses to compile a program
that the author thinks is valid. This often happens because the
programmer's mental model of how ownership should work doesn't match the
actual rules that Rust implements. You probably will experience similar
things at first. There is good news, however: more experienced Rust
developers report that once they work with the rules of the ownership
system for a period of time, they fight the borrow checker less and
less.

With that in mind, let's learn about lifetimes.

\subsection{Lifetimes}\label{lifetimes}

Lending out a reference to a resource that someone else owns can be
complicated. For example, imagine this set of operations:

\begin{itemize}
\tightlist
\item
  I acquire a handle to some kind of resource.
\item
  I lend you a reference to the resource.
\item
  I decide I'm done with the resource, and deallocate it, while you
  still have your reference.
\item
  You decide to use the resource.
\end{itemize}

Uh oh! Your reference is pointing to an invalid resource. This is called
a dangling pointer or `use after free', when the resource is memory.

To fix this, we have to make sure that step four never happens after
step three. The ownership system in Rust does this through a concept
called lifetimes, which describe the scope that a reference is valid
for.

When we have a function that takes a reference by argument, we can be
implicit or explicit about the lifetime of the reference:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// implicit}
\KeywordTok{fn} \NormalTok{foo(x: &}\DataTypeTok{i32}\NormalTok{) \{}
\NormalTok{\}}

\CommentTok{// explicit}
\KeywordTok{fn} \NormalTok{bar<}\OtherTok{'a}\NormalTok{>(x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{) \{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{\textquotesingle{}a} reads `the lifetime a'. Technically,
every reference has some lifetime associated with it, but the compiler
lets you elide them in common cases. Before we get to that, though,
let's break the explicit example down:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{bar<}\OtherTok{'a}\NormalTok{>(...)}
\end{Highlighting}
\end{Shaded}

We previously talked a little about \hyperref[sec--functions]{function
syntax}, but we didn't discuss the \texttt{\textless{}\textgreater{}}s
after a function's name. A function can have `generic parameters'
between the \texttt{\textless{}\textgreater{}}s, of which lifetimes are
one kind. We'll discuss other kinds of generics
\hyperref[sec--generics]{later in the book}, but for now, let's just
focus on the lifetimes aspect.

We use \texttt{\textless{}\textgreater{}} to declare our lifetimes. This
says that \texttt{bar} has one lifetime, \texttt{\textquotesingle{}a}.
If we had two reference parameters, it would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{bar<}\OtherTok{'a}\NormalTok{, }\OtherTok{'b}\NormalTok{>(...)}
\end{Highlighting}
\end{Shaded}

Then in our parameter list, we use the lifetimes we've named:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...(x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If we wanted an \texttt{\&mut} reference, we'd do this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...(x: &}\OtherTok{'a} \KeywordTok{mut} \DataTypeTok{i32}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you compare \texttt{\&mut\ i32} to
\texttt{\&\textquotesingle{}a\ mut\ i32}, they're the same, it's just
that the lifetime \texttt{\textquotesingle{}a} has snuck in between the
\texttt{\&} and the \texttt{mut\ i32}. We read \texttt{\&mut\ i32} as `a
mutable reference to an \texttt{i32}' and
\texttt{\&\textquotesingle{}a\ mut\ i32} as `a mutable reference to an
\texttt{i32} with the lifetime \texttt{\textquotesingle{}a}'.

\subsection{\texorpdfstring{In
\texttt{struct}s}{In structs}}\label{in-structs}

You'll also need explicit lifetimes when working with
\hyperref[sec--structs]{\texttt{struct}}s:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<}\OtherTok{'a}\NormalTok{> \{}
    \NormalTok{x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{y = &}\DecValTok{5}\NormalTok{; }\CommentTok{// this is the same as `let _y = 5; let y = &_y;`}
    \KeywordTok{let} \NormalTok{f = Foo \{ x: y \};}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, f.x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As you can see, \texttt{struct}s can also have lifetimes. In a similar
way to functions,

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<}\OtherTok{'a}\NormalTok{> \{}
\end{Highlighting}
\end{Shaded}

declares a lifetime, and

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{,}
\end{Highlighting}
\end{Shaded}

uses it. So why do we need a lifetime here? We need to ensure that any
reference to a \texttt{Foo} cannot outlive the reference to an
\texttt{i32} it contains.

\subsubsection{\texorpdfstring{\texttt{impl}
blocks}{impl blocks}}\label{impl-blocks}

Let's implement a method on \texttt{Foo}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<}\OtherTok{'a}\NormalTok{> \{}
    \NormalTok{x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl}\NormalTok{<}\OtherTok{'a}\NormalTok{> Foo<}\OtherTok{'a}\NormalTok{> \{}
    \KeywordTok{fn} \NormalTok{x(&}\KeywordTok{self}\NormalTok{) -> &}\OtherTok{'a} \DataTypeTok{i32} \NormalTok{\{ }\KeywordTok{self}\NormalTok{.x \}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{y = &}\DecValTok{5}\NormalTok{; }\CommentTok{// this is the same as `let _y = 5; let y = &_y;`}
    \KeywordTok{let} \NormalTok{f = Foo \{ x: y \};}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is: \{\}"}\NormalTok{, f.x());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As you can see, we need to declare a lifetime for \texttt{Foo} in the
\texttt{impl} line. We repeat \texttt{\textquotesingle{}a} twice, just
like on functions:
\texttt{impl\textless{}\textquotesingle{}a\textgreater{}} defines a
lifetime \texttt{\textquotesingle{}a}, and
\texttt{Foo\textless{}\textquotesingle{}a\textgreater{}} uses it.

\subsubsection{Multiple lifetimes}\label{multiple-lifetimes}

If you have multiple references, you can use the same lifetime multiple
times:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{x_or_y<}\OtherTok{'a}\NormalTok{>(x: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{, y: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{) -> &}\OtherTok{'a} \DataTypeTok{str} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

This says that \texttt{x} and \texttt{y} both are alive for the same
scope, and that the return value is also alive for that scope. If you
wanted \texttt{x} and \texttt{y} to have different lifetimes, you can
use multiple lifetime parameters:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{x_or_y<}\OtherTok{'a}\NormalTok{, }\OtherTok{'b}\NormalTok{>(x: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{, y: &}\OtherTok{'b} \DataTypeTok{str}\NormalTok{) -> &}\OtherTok{'a} \DataTypeTok{str} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

In this example, \texttt{x} and \texttt{y} have different valid scopes,
but the return value has the same lifetime as \texttt{x}.

\subsubsection{Thinking in scopes}\label{thinking-in-scopes-1}

A way to think about lifetimes is to visualize the scope that a
reference is valid for. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{y = &}\DecValTok{5}\NormalTok{;     }\CommentTok{// -+ y goes into scope}
                    \CommentTok{//  |}
    \CommentTok{// stuff        //  |}
                    \CommentTok{//  |}
\NormalTok{\}                   }\CommentTok{// -+ y goes out of scope}
\end{Highlighting}
\end{Shaded}

Adding in our \texttt{Foo}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<}\OtherTok{'a}\NormalTok{> \{}
    \NormalTok{x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{y = &}\DecValTok{5}\NormalTok{;           }\CommentTok{// -+ y goes into scope}
    \KeywordTok{let} \NormalTok{f = Foo \{ x: y \}; }\CommentTok{// -+ f goes into scope}
    \CommentTok{// stuff              //  |}
                          \CommentTok{//  |}
\NormalTok{\}                         }\CommentTok{// -+ f and y go out of scope}
\end{Highlighting}
\end{Shaded}

Our \texttt{f} lives within the scope of \texttt{y}, so everything
works. What if it didn't? This code won't work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<}\OtherTok{'a}\NormalTok{> \{}
    \NormalTok{x: &}\OtherTok{'a} \DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x;                    }\CommentTok{// -+ x goes into scope}
                              \CommentTok{//  |}
    \NormalTok{\{                         }\CommentTok{//  |}
        \KeywordTok{let} \NormalTok{y = &}\DecValTok{5}\NormalTok{;           }\CommentTok{// ---+ y goes into scope}
        \KeywordTok{let} \NormalTok{f = Foo \{ x: y \}; }\CommentTok{// ---+ f goes into scope}
        \NormalTok{x = &f.x;             }\CommentTok{//  | | error here}
    \NormalTok{\}                         }\CommentTok{// ---+ f and y go out of scope}
                              \CommentTok{//  |}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);        }\CommentTok{//  |}
\NormalTok{\}                             }\CommentTok{// -+ x goes out of scope}
\end{Highlighting}
\end{Shaded}

Whew! As you can see here, the scopes of \texttt{f} and \texttt{y} are
smaller than the scope of \texttt{x}. But when we do
\texttt{x\ =\ \&f.x}, we make \texttt{x} a reference to something that's
about to go out of scope.

Named lifetimes are a way of giving these scopes a name. Giving
something a name is the first step towards being able to talk about it.

\hyperdef{}{static}{\subsubsection{'static}\label{static}}

The lifetime named `static' is a special lifetime. It signals that
something has the lifetime of the entire program. Most Rust programmers
first come across \texttt{\textquotesingle{}static} when dealing with
strings:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: &}\OtherTok{'static} \DataTypeTok{str} \NormalTok{= }\StringTok{"Hello, world."}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

String literals have the type \texttt{\&\textquotesingle{}static\ str}
because the reference is always alive: they are baked into the data
segment of the final binary. Another example are globals:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{static} \NormalTok{FOO: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{x: &}\OtherTok{'static} \DataTypeTok{i32} \NormalTok{= &FOO;}
\end{Highlighting}
\end{Shaded}

This adds an \texttt{i32} to the data segment of the binary, and
\texttt{x} is a reference to it.

\subsubsection{Lifetime Elision}\label{lifetime-elision}

Rust supports powerful local type inference in function bodies, but it's
forbidden in item signatures to allow reasoning about the types based on
the item signature alone. However, for ergonomic reasons a very
restricted secondary inference algorithm called ``lifetime elision''
applies in function signatures. It infers only based on the signature
components themselves and not based on the body of the function, only
infers lifetime parameters, and does this with only three easily
memorizable and unambiguous rules. This makes lifetime elision a
shorthand for writing an item signature, while not hiding away the
actual types involved as full local inference would if applied to it.

When talking about lifetime elision, we use the term \emph{input
lifetime} and \emph{output lifetime}. An \emph{input lifetime} is a
lifetime associated with a parameter of a function, and an \emph{output
lifetime} is a lifetime associated with the return value of a function.
For example, this function has an input lifetime:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo<}\OtherTok{'a}\NormalTok{>(bar: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This one has an output lifetime:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo<}\OtherTok{'a}\NormalTok{>() -> &}\OtherTok{'a} \DataTypeTok{str}
\end{Highlighting}
\end{Shaded}

This one has a lifetime in both positions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo<}\OtherTok{'a}\NormalTok{>(bar: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{) -> &}\OtherTok{'a} \DataTypeTok{str}
\end{Highlighting}
\end{Shaded}

Here are the three rules:

\begin{itemize}
\item
  Each elided lifetime in a function's arguments becomes a distinct
  lifetime parameter.
\item
  If there is exactly one input lifetime, elided or not, that lifetime
  is assigned to all elided lifetimes in the return values of that
  function.
\item
  If there are multiple input lifetimes, but one of them is
  \texttt{\&self} or \texttt{\&mut\ \ \ self}, the lifetime of
  \texttt{self} is assigned to all elided output lifetimes.
\end{itemize}

Otherwise, it is an error to elide an output lifetime.

\paragraph{Examples}\label{examples}

Here are some examples of functions with elided lifetimes. We've paired
each example of an elided lifetime with its expanded form.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print(s: &}\DataTypeTok{str}\NormalTok{); }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{print<}\OtherTok{'a}\NormalTok{>(s: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{); }\CommentTok{// expanded}

\KeywordTok{fn} \NormalTok{debug(lvl: }\DataTypeTok{u32}\NormalTok{, s: &}\DataTypeTok{str}\NormalTok{); }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{debug<}\OtherTok{'a}\NormalTok{>(lvl: }\DataTypeTok{u32}\NormalTok{, s: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{); }\CommentTok{// expanded}

\CommentTok{// In the preceding example, `lvl` doesn‚Äôt need a lifetime because it‚Äôs not a}
\CommentTok{// reference (`&`). Only things relating to references (such as a `struct`}
\CommentTok{// which contains a reference) need lifetimes.}

\KeywordTok{fn} \NormalTok{substr(s: &}\DataTypeTok{str}\NormalTok{, until: }\DataTypeTok{u32}\NormalTok{) -> &}\DataTypeTok{str}\NormalTok{; }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{substr<}\OtherTok{'a}\NormalTok{>(s: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{, until: }\DataTypeTok{u32}\NormalTok{) -> &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{; }\CommentTok{// expanded}

\KeywordTok{fn} \NormalTok{get_str() -> &}\DataTypeTok{str}\NormalTok{; }\CommentTok{// ILLEGAL, no inputs}

\KeywordTok{fn} \NormalTok{frob(s: &}\DataTypeTok{str}\NormalTok{, t: &}\DataTypeTok{str}\NormalTok{) -> &}\DataTypeTok{str}\NormalTok{; }\CommentTok{// ILLEGAL, two inputs}
\KeywordTok{fn} \NormalTok{frob<}\OtherTok{'a}\NormalTok{, }\OtherTok{'b}\NormalTok{>(s: &}\OtherTok{'a} \DataTypeTok{str}\NormalTok{, t: &}\OtherTok{'b} \DataTypeTok{str}\NormalTok{) -> &}\DataTypeTok{str}\NormalTok{; }\CommentTok{// Expanded: Output lifetime is ambig}
\NormalTok{‚Ü≥ uous}

\KeywordTok{fn} \NormalTok{get_mut(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{) -> &}\KeywordTok{mut} \NormalTok{T; }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{get_mut<}\OtherTok{'a}\NormalTok{>(&}\OtherTok{'a} \KeywordTok{mut} \KeywordTok{self}\NormalTok{) -> &}\OtherTok{'a} \KeywordTok{mut} \NormalTok{T; }\CommentTok{// expanded}

\KeywordTok{fn} \NormalTok{args<T:ToCStr>(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{, args: &[T]) -> &}\KeywordTok{mut} \NormalTok{Command }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{args<}\OtherTok{'a}\NormalTok{, }\OtherTok{'b}\NormalTok{, T:ToCStr>(&}\OtherTok{'a} \KeywordTok{mut} \KeywordTok{self}\NormalTok{, args: &}\OtherTok{'b} \NormalTok{[T]) -> &}\OtherTok{'a} \KeywordTok{mut} \NormalTok{Command }\CommentTok{// expanded}

\KeywordTok{fn} \NormalTok{new(buf: &}\KeywordTok{mut} \NormalTok{[}\DataTypeTok{u8}\NormalTok{]) -> BufWriter; }\CommentTok{// elided}
\KeywordTok{fn} \NormalTok{new<}\OtherTok{'a}\NormalTok{>(buf: &}\OtherTok{'a} \KeywordTok{mut} \NormalTok{[}\DataTypeTok{u8}\NormalTok{]) -> BufWriter<}\OtherTok{'a}\NormalTok{> }\CommentTok{// expanded}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--mutability}{\section{Mutability}\label{sec--mutability}}

Mutability, the ability to change something, works a bit differently in
Rust than in other languages. The first aspect of mutability is its
non-default status:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\NormalTok{x = }\DecValTok{6}\NormalTok{; }\CommentTok{// error!}
\end{Highlighting}
\end{Shaded}

We can introduce mutability with the \texttt{mut} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\NormalTok{x = }\DecValTok{6}\NormalTok{; }\CommentTok{// no problem!}
\end{Highlighting}
\end{Shaded}

This is a mutable \hyperref[sec--variable-bindings]{variable binding}.
When a binding is mutable, it means you're allowed to change what the
binding points to. So in the above example, it's not so much that the
value at \texttt{x} is changing, but that the binding changed from one
\texttt{i32} to another.

If you want to change what the binding points to, you'll need a
\hyperref[sec--references-and-borrowing]{mutable reference}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;}
\end{Highlighting}
\end{Shaded}

\texttt{y} is an immutable binding to a mutable reference, which means
that you can't bind \texttt{y} to something else
(\texttt{y\ =\ \&mut\ z}), but you can mutate the thing that's bound to
\texttt{y} (\texttt{*y\ =\ 5}). A subtle distinction.

Of course, if you need both:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{x;}
\end{Highlighting}
\end{Shaded}

Now \texttt{y} can be bound to another value, and the value it's
referencing can be changed.

It's important to note that \texttt{mut} is part of a
\hyperref[sec--patterns]{pattern}, so you can do things like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{(}\KeywordTok{mut} \NormalTok{x, y) = (}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{);}

\KeywordTok{fn} \NormalTok{foo(}\KeywordTok{mut} \NormalTok{x: }\DataTypeTok{i32}\NormalTok{) \{}
\end{Highlighting}
\end{Shaded}

\subsection{Interior vs.~Exterior
Mutability}\label{interior-vs.exterior-mutability}

However, when we say something is `immutable' in Rust, that doesn't mean
that it's not able to be changed: we mean something has `exterior
mutability'. Consider, for example,
\href{http://doc.rust-lang.org/std/sync/struct.Arc.html}{\texttt{Arc\textless{}T\textgreater{}}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::sync::Arc;}

\KeywordTok{let} \NormalTok{x = Arc::new(}\DecValTok{5}\NormalTok{);}
\KeywordTok{let} \NormalTok{y = x.clone();}
\end{Highlighting}
\end{Shaded}

When we call \texttt{clone()}, the
\texttt{Arc\textless{}T\textgreater{}} needs to update the reference
count. Yet we've not used any \texttt{mut}s here, \texttt{x} is an
immutable binding, and we didn't take \texttt{\&mut\ 5} or anything. So
what gives?

To understand this, we have to go back to the core of Rust's guiding
philosophy, memory safety, and the mechanism by which Rust guarantees
it, the \hyperref[sec--ownership]{ownership} system, and more
specifically, \hyperref[borrowing]{borrowing}:

\begin{quote}
You may have one or the other of these two kinds of borrows, but not
both at the same time:

\begin{itemize}
\tightlist
\item
  one or more references (\texttt{\&T}) to a resource,
\item
  exactly one mutable reference (\texttt{\&mut\ T}).
\end{itemize}
\end{quote}

So, that's the real definition of `immutability': is this safe to have
two pointers to? In \texttt{Arc\textless{}T\textgreater{}}'s case, yes:
the mutation is entirely contained inside the structure itself. It's not
user facing. For this reason, it hands out \texttt{\&T} with
\texttt{clone()}. If it handed out \texttt{\&mut\ T}s, though, that
would be a problem.

Other types, like the ones in the
\href{http://doc.rust-lang.org/std/cell/index.html}{\texttt{std::cell}}
module, have the opposite: interior mutability. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::cell::RefCell;}

\KeywordTok{let} \NormalTok{x = RefCell::new(}\DecValTok{42}\NormalTok{);}

\KeywordTok{let} \NormalTok{y = x.borrow_mut();}
\end{Highlighting}
\end{Shaded}

RefCell hands out \texttt{\&mut} references to what's inside of it with
the \texttt{borrow\_mut()} method. Isn't that dangerous? What if we do:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::cell::RefCell;}

\KeywordTok{let} \NormalTok{x = RefCell::new(}\DecValTok{42}\NormalTok{);}

\KeywordTok{let} \NormalTok{y = x.borrow_mut();}
\KeywordTok{let} \NormalTok{z = x.borrow_mut();}
\end{Highlighting}
\end{Shaded}

This will in fact panic, at runtime. This is what \texttt{RefCell} does:
it enforces Rust's borrowing rules at runtime, and \texttt{panic!}s if
they're violated. This allows us to get around another aspect of Rust's
mutability rules. Let's talk about it first.

\subsubsection{Field-level mutability}\label{field-level-mutability}

Mutability is a property of either a borrow (\texttt{\&mut}) or a
binding (\texttt{let\ mut}). This means that, for example, you cannot
have a \hyperref[sec--structs]{\texttt{struct}} with some fields mutable
and some immutable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \KeywordTok{mut} \NormalTok{y: }\DataTypeTok{i32}\NormalTok{, }\CommentTok{// nope}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The mutability of a struct is in its binding:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{a = Point \{ x: }\DecValTok{5}\NormalTok{, y: }\DecValTok{6} \NormalTok{\};}

\NormalTok{a.x = }\DecValTok{10}\NormalTok{;}

\KeywordTok{let} \NormalTok{b = Point \{ x: }\DecValTok{5}\NormalTok{, y: }\DecValTok{6}\NormalTok{\};}

\NormalTok{b.x = }\DecValTok{10}\NormalTok{; }\CommentTok{// error: cannot assign to immutable field `b.x`}
\end{Highlighting}
\end{Shaded}

However, by using
\href{http://doc.rust-lang.org/std/cell/struct.Cell.html}{\texttt{Cell\textless{}T\textgreater{}}},
you can emulate field-level mutability:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::cell::Cell;}

\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: Cell<}\DataTypeTok{i32}\NormalTok{>,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{point = Point \{ x: }\DecValTok{5}\NormalTok{, y: Cell::new(}\DecValTok{6}\NormalTok{) \};}

\NormalTok{point.y.set(}\DecValTok{7}\NormalTok{);}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"y: \{:?\}"}\NormalTok{, point.y);}
\end{Highlighting}
\end{Shaded}

This will print \texttt{y:\ Cell\ \{\ value:\ 7\ \}}. We've successfully
updated \texttt{y}.

\hyperdef{}{sec--structs}{\section{Structs}\label{sec--structs}}

\texttt{struct}s are a way of creating more complex data types. For
example, if we were doing calculations involving coordinates in 2D
space, we would need both an \texttt{x} and a \texttt{y} value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{origin_x = }\DecValTok{0}\NormalTok{;}
\KeywordTok{let} \NormalTok{origin_y = }\DecValTok{0}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

A \texttt{struct} lets us combine these two into a single, unified
datatype:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\}; }\CommentTok{// origin: Point}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The origin is at (\{\}, \{\})"}\NormalTok{, origin.x, origin.y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's a lot going on here, so let's break it down. We declare a
\texttt{struct} with the \texttt{struct} keyword, and then with a name.
By convention, \texttt{struct}s begin with a capital letter and are
camel cased: \texttt{PointInSpace}, not \texttt{Point\_In\_Space}.

We can create an instance of our \texttt{struct} via \texttt{let}, as
usual, but we use a \texttt{key:\ value} style syntax to set each field.
The order doesn't need to be the same as in the original declaration.

Finally, because fields have names, we can access the field through dot
notation: \texttt{origin.x}.

The values in \texttt{struct}s are immutable by default, like other
bindings in Rust. Use \texttt{mut} to make them mutable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{point = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

    \NormalTok{point.x = }\DecValTok{5}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The point is at (\{\}, \{\})"}\NormalTok{, point.x, point.y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print \texttt{The\ point\ is\ at\ (5,\ 0)}.

Rust does not support field mutability at the language level, so you
cannot write something like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \KeywordTok{mut} \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Mutability is a property of the binding, not of the structure itself. If
you're used to field-level mutability, this may seem strange at first,
but it significantly simplifies things. It even lets you make things
mutable for a short time only:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{point = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

    \NormalTok{point.x = }\DecValTok{5}\NormalTok{;}

    \KeywordTok{let} \NormalTok{point = point; }\CommentTok{// this new binding can‚Äôt change now}

    \NormalTok{point.y = }\DecValTok{6}\NormalTok{; }\CommentTok{// this causes an error}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Update syntax}\label{update-syntax}

A \texttt{struct} can include \texttt{..} to indicate that you want to
use a copy of some other \texttt{struct} for some of the values. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point3d \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{z: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{point = Point3d \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0}\NormalTok{, z: }\DecValTok{0} \NormalTok{\};}
\NormalTok{point = Point3d \{ y: }\DecValTok{1}\NormalTok{, .. point \};}
\end{Highlighting}
\end{Shaded}

This gives \texttt{point} a new \texttt{y}, but keeps the old \texttt{x}
and \texttt{z} values. It doesn't have to be the same \texttt{struct}
either, you can use this syntax when making new ones, and it will copy
the values you don't specify:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{origin = Point3d \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0}\NormalTok{, z: }\DecValTok{0} \NormalTok{\};}
\KeywordTok{let} \NormalTok{point = Point3d \{ z: }\DecValTok{1}\NormalTok{, x: }\DecValTok{2}\NormalTok{, .. origin \};}
\end{Highlighting}
\end{Shaded}

\subsection{Tuple structs}\label{tuple-structs}

Rust has another data type that's like a hybrid between a
\hyperref[tuples]{tuple} and a \texttt{struct}, called a `tuple struct'.
Tuple structs have a name, but their fields don't:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Color(}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{);}
\KeywordTok{struct} \NormalTok{Point(}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

These two will not be equal, even if they have the same values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{black = Color(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{);}
\KeywordTok{let} \NormalTok{origin = Point(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

It is almost always better to use a \texttt{struct} than a tuple struct.
We would write \texttt{Color} and \texttt{Point} like this instead:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Color \{}
    \NormalTok{red: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{blue: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{green: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{z: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, we have actual names, rather than positions. Good names are
important, and with a \texttt{struct}, we have actual names.

There \emph{is} one case when a tuple struct is very useful, though, and
that's a tuple struct with only one element. We call this the `newtype'
pattern, because it allows you to create a new type, distinct from that
of its contained value and expressing its own semantic meaning:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Inches(}\DataTypeTok{i32}\NormalTok{);}

\KeywordTok{let} \NormalTok{length = Inches(}\DecValTok{10}\NormalTok{);}

\KeywordTok{let} \NormalTok{Inches(integer_length) = length;}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"length is \{\} inches"}\NormalTok{, integer_length);}
\end{Highlighting}
\end{Shaded}

As you can see here, you can extract the inner integer type through a
destructuring \texttt{let}, just as with regular tuples. In this case,
the \texttt{let\ Inches(integer\_length)} assigns \texttt{10} to
\texttt{integer\_length}.

\subsection{Unit-like structs}\label{unit-like-structs}

You can define a \texttt{struct} with no members at all:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Electron;}
\end{Highlighting}
\end{Shaded}

Such a \texttt{struct} is called `unit-like' because it resembles the
empty tuple, \texttt{()}, sometimes called `unit'. Like a tuple struct,
it defines a new type.

This is rarely useful on its own (although sometimes it can serve as a
marker type), but in combination with other features, it can become
useful. For instance, a library may ask you to create a structure that
implements a certain \hyperref[sec--traits]{trait} to handle events. If
you don't have any data you need to store in the structure, you can just
create a unit-like \texttt{struct}.

\hyperdef{}{sec--enums}{\section{Enums}\label{sec--enums}}

An \texttt{enum} in Rust is a type that represents data that could be
one of several possible variants:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \NormalTok{Message \{}
    \NormalTok{Quit,}
    \NormalTok{ChangeColor(}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{),}
    \NormalTok{Move \{ x: }\DataTypeTok{i32}\NormalTok{, y: }\DataTypeTok{i32} \NormalTok{\},}
    \NormalTok{Write(}\DataTypeTok{String}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Each variant can optionally have data associated with it. The syntax for
defining variants resembles the syntaxes used to define structs: you can
have variants with no data (like unit-like structs), variants with named
data, and variants with unnamed data (like tuple structs). Unlike
separate struct definitions, however, an \texttt{enum} is a single type.
A value of the enum can match any of the variants. For this reason, an
enum is sometimes called a `sum type': the set of possible values of the
enum is the sum of the sets of possible values for each variant.

We use the \texttt{::} syntax to use the name of each variant: they're
scoped by the name of the \texttt{enum} itself. This allows both of
these to work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: Message = Message::Move \{ x: }\DecValTok{3}\NormalTok{, y: }\DecValTok{4} \NormalTok{\};}

\KeywordTok{enum} \NormalTok{BoardGameTurn \{}
    \NormalTok{Move \{ squares: }\DataTypeTok{i32} \NormalTok{\},}
    \NormalTok{Pass,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{y: BoardGameTurn = BoardGameTurn::Move \{ squares: }\DecValTok{1} \NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Both variants are named \texttt{Move}, but since they're scoped to the
name of the enum, they can both be used without conflict.

A value of an enum type contains information about which variant it is,
in addition to any data associated with that variant. This is sometimes
referred to as a `tagged union', since the data includes a `tag'
indicating what type it is. The compiler uses this information to
enforce that you're accessing the data in the enum safely. For instance,
you can't simply try to destructure a value as if it were one of the
possible variants:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{process_color_change(msg: Message) \{}
    \KeywordTok{let} \NormalTok{Message::ChangeColor(r, g, b) = msg; }\CommentTok{// compile-time error}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Not supporting these operations may seem rather limiting, but it's a
limitation which we can overcome. There are two ways: by implementing
equality ourselves, or by pattern matching variants with
\hyperref[sec--match]{\texttt{match}} expressions, which you'll learn in
the next section. We don't know enough about Rust to implement equality
yet, but we'll find out in the \hyperref[sec--traits]{\texttt{traits}}
section.

\subsection{Constructors as functions}\label{constructors-as-functions}

An enum's constructors can also be used like functions. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{m = Message::Write(}\StringTok{"Hello, world"}\NormalTok{.to_string());}
\end{Highlighting}
\end{Shaded}

Is the same as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{String}\NormalTok{) -> Message \{}
    \NormalTok{Message::Write(x)}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{x = foo(}\StringTok{"Hello, world"}\NormalTok{.to_string());}
\end{Highlighting}
\end{Shaded}

This is not immediately useful to us, but when we get to
\hyperref[sec--closures]{\texttt{closures}}, we'll talk about passing
functions as arguments to other functions. For example, with
\hyperref[sec--iterators]{\texttt{iterators}}, we can do this to convert
a vector of \texttt{String}s into a vector of \texttt{Message::Write}s:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"Hello"}\NormalTok{.to_string(), }\StringTok{"World"}\NormalTok{.to_string()];}

\KeywordTok{let} \NormalTok{v1: }\DataTypeTok{Vec}\NormalTok{<Message> = v.into_iter().map(Message::Write).collect();}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--match}{\section{Match}\label{sec--match}}

Often, a simple \hyperref[sec--if]{\texttt{if}}/\texttt{else} isn't
enough, because you have more than two possible options. Also,
conditions can get quite complex. Rust has a keyword, \texttt{match},
that allows you to replace complicated \texttt{if}/\texttt{else}
groupings with something more powerful. Check it out:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"one"}\NormalTok{),}
    \DecValTok{2} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"two"}\NormalTok{),}
    \DecValTok{3} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"three"}\NormalTok{),}
    \DecValTok{4} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"four"}\NormalTok{),}
    \DecValTok{5} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"five"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"something else"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{match} takes an expression and then branches based on its value.
Each `arm' of the branch is of the form
\texttt{val\ =\textgreater{}\ expression}. When the value matches, that
arm's expression will be evaluated. It's called \texttt{match} because
of the term `pattern matching', which \texttt{match} is an
implementation of. There's an \hyperref[sec--patterns]{entire section on
patterns} that covers all the patterns that are possible here.

So what's the big advantage? Well, there are a few. First of all,
\texttt{match} enforces `exhaustiveness checking'. Do you see that last
arm, the one with the underscore (\texttt{\_})? If we remove that arm,
Rust will give us an error:

\begin{verbatim}
error: non-exhaustive patterns: `_` not covered
\end{verbatim}

In other words, Rust is trying to tell us we forgot a value. Because
\texttt{x} is an integer, Rust knows that it can have a number of
different values -- for example, \texttt{6}. Without the \texttt{\_},
however, there is no arm that could match, and so Rust refuses to
compile the code. \texttt{\_} acts like a `catch-all arm'. If none of
the other arms match, the arm with \texttt{\_} will, and since we have
this catch-all arm, we now have an arm for every possible value of
\texttt{x}, and so our program will compile successfully.

\texttt{match} is also an expression, which means we can use it on the
right-hand side of a \texttt{let} binding or directly where an
expression is used:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{number = }\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{=> }\StringTok{"one"}\NormalTok{,}
    \DecValTok{2} \NormalTok{=> }\StringTok{"two"}\NormalTok{,}
    \DecValTok{3} \NormalTok{=> }\StringTok{"three"}\NormalTok{,}
    \DecValTok{4} \NormalTok{=> }\StringTok{"four"}\NormalTok{,}
    \DecValTok{5} \NormalTok{=> }\StringTok{"five"}\NormalTok{,}
    \NormalTok{_ => }\StringTok{"something else"}\NormalTok{,}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Sometimes it's a nice way of converting something from one type to
another.

\subsection{Matching on enums}\label{matching-on-enums}

Another important use of the \texttt{match} keyword is to process the
possible variants of an enum:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \NormalTok{Message \{}
    \NormalTok{Quit,}
    \NormalTok{ChangeColor(}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{),}
    \NormalTok{Move \{ x: }\DataTypeTok{i32}\NormalTok{, y: }\DataTypeTok{i32} \NormalTok{\},}
    \NormalTok{Write(}\DataTypeTok{String}\NormalTok{),}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{quit() \{ }\CommentTok{/* ... */} \NormalTok{\}}
\KeywordTok{fn} \NormalTok{change_color(r: }\DataTypeTok{i32}\NormalTok{, g: }\DataTypeTok{i32}\NormalTok{, b: }\DataTypeTok{i32}\NormalTok{) \{ }\CommentTok{/* ... */} \NormalTok{\}}
\KeywordTok{fn} \NormalTok{move_cursor(x: }\DataTypeTok{i32}\NormalTok{, y: }\DataTypeTok{i32}\NormalTok{) \{ }\CommentTok{/* ... */} \NormalTok{\}}

\KeywordTok{fn} \NormalTok{process_message(msg: Message) \{}
    \KeywordTok{match} \NormalTok{msg \{}
        \NormalTok{Message::Quit => quit(),}
        \NormalTok{Message::ChangeColor(r, g, b) => change_color(r, g, b),}
        \NormalTok{Message::Move \{ x: x, y: y \} => move_cursor(x, y),}
        \NormalTok{Message::Write(s) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, s),}
    \NormalTok{\};}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Again, the Rust compiler checks exhaustiveness, so it demands that you
have a match arm for every variant of the enum. If you leave one off, it
will give you a compile-time error unless you use \texttt{\_}.

Unlike the previous uses of \texttt{match}, you can't use the normal
\texttt{if} statement to do this. You can use the
\hyperref[sec--if-let]{\texttt{if\ let}} statement, which can be seen as
an abbreviated form of \texttt{match}.

\hyperdef{}{sec--patterns}{\section{Patterns}\label{sec--patterns}}

Patterns are quite common in Rust. We use them in
\hyperref[sec--variable-bindings]{variable bindings},
\hyperref[sec--match]{match statements}, and other places, too. Let's go
on a whirlwind tour of all of the things patterns can do!

A quick refresher: you can match against literals directly, and
\texttt{\_} acts as an `any' case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{1}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"one"}\NormalTok{),}
    \DecValTok{2} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"two"}\NormalTok{),}
    \DecValTok{3} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"three"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"anything"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{one}.

\subsection{Multiple patterns}\label{multiple-patterns}

You can match multiple patterns with \texttt{\textbar{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{1}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{| }\DecValTok{2} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"one or two"}\NormalTok{),}
    \DecValTok{3} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"three"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"anything"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{one\ or\ two}.

\subsection{Destructuring}\label{destructuring}

If you have a compound data type, like a
\hyperref[sec--structs]{\texttt{struct}}, you can destructure it inside
of a pattern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

\KeywordTok{match} \NormalTok{origin \{}
    \NormalTok{Point \{ x, y \} => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"(\{\},\{\})"}\NormalTok{, x, y),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can use \texttt{:} to give a value a different name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

\KeywordTok{match} \NormalTok{origin \{}
    \NormalTok{Point \{ x: x1, y: y1 \} => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"(\{\},\{\})"}\NormalTok{, x1, y1),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we only care about some of the values, we don't have to give them all
names:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

\KeywordTok{match} \NormalTok{origin \{}
    \NormalTok{Point \{ x, .. \} => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"x is \{\}"}\NormalTok{, x),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{x\ is\ 0}.

You can do this kind of match on any member, not just the first:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}

\KeywordTok{match} \NormalTok{origin \{}
    \NormalTok{Point \{ y, .. \} => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"y is \{\}"}\NormalTok{, y),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{y\ is\ 0}.

This `destructuring' behavior works on any compound data type, like
\hyperref[tuples]{tuples} or \hyperref[sec--enums]{enums}.

\subsection{Ignoring bindings}\label{ignoring-bindings}

You can use \texttt{\_} in a pattern to disregard the type and value.
For example, here's a \texttt{match} against a
\texttt{Result\textless{}T,\ E\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{some_value \{}
    \ConstantTok{Ok}\NormalTok{(value) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"got a value: \{\}"}\NormalTok{, value),}
    \ConstantTok{Err}\NormalTok{(_) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"an error occurred"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the first arm, we bind the value inside the \texttt{Ok} variant to
\texttt{value}. But in the \texttt{Err} arm, we use \texttt{\_} to
disregard the specific error, and just print a general error message.

\texttt{\_} is valid in any pattern that creates a binding. This can be
useful to ignore parts of a larger structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{coordinate() -> (}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{) \{}
    \CommentTok{// generate and return some sort of triple tuple}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{(x, _, z) = coordinate();}
\end{Highlighting}
\end{Shaded}

Here, we bind the first and last element of the tuple to \texttt{x} and
\texttt{z}, but ignore the middle element.

Similarly, you can use \texttt{..} in a pattern to disregard multiple
values.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \NormalTok{OptionalTuple \{}
    \NormalTok{Value(}\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{, }\DataTypeTok{i32}\NormalTok{),}
    \NormalTok{Missing,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{x = OptionalTuple::Value(}\DecValTok{5}\NormalTok{, -}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}

\KeywordTok{match} \NormalTok{x \{}
    \NormalTok{OptionalTuple::Value(..) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got a tuple!"}\NormalTok{),}
    \NormalTok{OptionalTuple::Missing => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"No such luck."}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{Got\ a\ tuple!}.

\subsection{ref and ref mut}\label{ref-and-ref-mut}

If you want to get a
\hyperref[sec--references-and-borrowing]{reference}, use the
\texttt{ref} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \KeywordTok{ref} \NormalTok{r => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got a reference to \{\}"}\NormalTok{, r),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{Got\ a\ reference\ to\ 5}.

Here, the \texttt{r} inside the \texttt{match} has the type
\texttt{\&i32}. In other words, the \texttt{ref} keyword \emph{creates}
a reference, for use in the pattern. If you need a mutable reference,
\texttt{ref\ mut} will work in the same way:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \KeywordTok{ref} \KeywordTok{mut} \NormalTok{mr => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got a mutable reference to \{\}"}\NormalTok{, mr),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Ranges}\label{ranges}

You can match a range of values with \texttt{...}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{1}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{... }\DecValTok{5} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"one through five"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"anything"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{one\ through\ five}.

Ranges are mostly used with integers and \texttt{char}s:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\CharTok{'üíÖ'}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \CharTok{'a'} \NormalTok{... }\CharTok{'j'} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"early letter"}\NormalTok{),}
    \CharTok{'k'} \NormalTok{... }\CharTok{'z'} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"late letter"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"something else"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{something\ else}.

\subsection{Bindings}\label{bindings}

You can bind values to names with \texttt{@}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{1}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \NormalTok{e @ }\DecValTok{1} \NormalTok{... }\DecValTok{5} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"got a range element \{\}"}\NormalTok{, e),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"anything"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{got\ a\ range\ element\ 1}. This is useful when you
want to do a complicated match of part of a data structure:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{struct} \NormalTok{Person \{}
    \NormalTok{name: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{String}\NormalTok{>,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{name = }\StringTok{"Steve"}\NormalTok{.to_string();}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{x: }\DataTypeTok{Option}\NormalTok{<Person> = }\ConstantTok{Some}\NormalTok{(Person \{ name: }\ConstantTok{Some}\NormalTok{(name) \});}
\KeywordTok{match} \NormalTok{x \{}
    \ConstantTok{Some}\NormalTok{(Person \{ name: }\KeywordTok{ref} \NormalTok{a @ }\ConstantTok{Some}\NormalTok{(_), .. \}) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, a),}
    \NormalTok{_ => \{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{Some("Steve")}: we've bound the inner \texttt{name}
to \texttt{a}.

If you use \texttt{@} with \texttt{\textbar{}}, you need to make sure
the name is bound in each part of the pattern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \NormalTok{e @ }\DecValTok{1} \NormalTok{... }\DecValTok{5} \NormalTok{| e @ }\DecValTok{8} \NormalTok{... }\DecValTok{10} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"got a range element \{\}"}\NormalTok{, e),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"anything"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Guards}\label{guards}

You can introduce `match guards' with \texttt{if}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \NormalTok{OptionalInt \{}
    \NormalTok{Value(}\DataTypeTok{i32}\NormalTok{),}
    \NormalTok{Missing,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{x = OptionalInt::Value(}\DecValTok{5}\NormalTok{);}

\KeywordTok{match} \NormalTok{x \{}
    \NormalTok{OptionalInt::Value(i) }\KeywordTok{if} \NormalTok{i > }\DecValTok{5} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got an int bigger than five!"}\NormalTok{),}
    \NormalTok{OptionalInt::Value(..) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got an int!"}\NormalTok{),}
    \NormalTok{OptionalInt::Missing => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"No such luck."}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{Got\ an\ int!}.

If you're using \texttt{if} with multiple patterns, the \texttt{if}
applies to both sides:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{4}\NormalTok{;}
\KeywordTok{let} \NormalTok{y = }\ConstantTok{false}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{4} \NormalTok{| }\DecValTok{5} \KeywordTok{if} \NormalTok{y => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"yes"}\NormalTok{),}
    \NormalTok{_ => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"no"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This prints \texttt{no}, because the \texttt{if} applies to the whole of
\texttt{4\ \textbar{}\ 5}, and not to just the \texttt{5}, In other
words, the the precedence of \texttt{if} behaves like this:

\begin{verbatim}
(4 | 5) if y => ...
\end{verbatim}

not this:

\begin{verbatim}
4 | (5 if y) => ...
\end{verbatim}

\subsection{Mix and Match}\label{mix-and-match}

Whew! That's a lot of different ways to match things, and they can all
be mixed and matched, depending on what you're doing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{x \{}
    \NormalTok{Foo \{ x: }\ConstantTok{Some}\NormalTok{(}\KeywordTok{ref} \NormalTok{name), y: }\ConstantTok{None} \NormalTok{\} => ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Patterns are very powerful. Make good use of them.

\hyperdef{}{sec--method-syntax}{\section{Method
Syntax}\label{sec--method-syntax}}

Functions are great, but if you want to call a bunch of them on some
data, it can be awkward. Consider this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{baz(bar(foo));}
\end{Highlighting}
\end{Shaded}

We would read this left-to-right, and so we see `baz bar foo'. But this
isn't the order that the functions would get called in, that's
inside-out: `foo bar baz'. Wouldn't it be nice if we could do this
instead?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo.bar().baz();}
\end{Highlighting}
\end{Shaded}

Luckily, as you may have guessed with the leading question, you can!
Rust provides the ability to use this `method call syntax' via the
\texttt{impl} keyword.

\subsection{Method calls}\label{method-calls}

Here's how it works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{c = Circle \{ x: }\DecValTok{0.0}\NormalTok{, y: }\DecValTok{0.0}\NormalTok{, radius: }\DecValTok{2.0} \NormalTok{\};}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, c.area());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print \texttt{12.566371}.

We've made a \texttt{struct} that represents a circle. We then write an
\texttt{impl} block, and inside it, define a method, \texttt{area}.

Methods take a special first parameter, of which there are three
variants: \texttt{self}, \texttt{\&self}, and \texttt{\&mut\ self}. You
can think of this first parameter as being the \texttt{foo} in
\texttt{foo.bar()}. The three variants correspond to the three kinds of
things \texttt{foo} could be: \texttt{self} if it's just a value on the
stack, \texttt{\&self} if it's a reference, and \texttt{\&mut\ self} if
it's a mutable reference. Because we took the \texttt{\&self} parameter
to \texttt{area}, we can use it just like any other parameter. Because
we know it's a \texttt{Circle}, we can access the \texttt{radius} just
like we would with any other \texttt{struct}.

We should default to using \texttt{\&self}, as you should prefer
borrowing over taking ownership, as well as taking immutable references
over mutable ones. Here's an example of all three variants:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{reference(&}\KeywordTok{self}\NormalTok{) \{}
       \PreprocessorTok{println!}\NormalTok{(}\StringTok{"taking self by reference!"}\NormalTok{);}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{mutable_reference(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{) \{}
       \PreprocessorTok{println!}\NormalTok{(}\StringTok{"taking self by mutable reference!"}\NormalTok{);}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{takes_ownership(}\KeywordTok{self}\NormalTok{) \{}
       \PreprocessorTok{println!}\NormalTok{(}\StringTok{"taking ownership of self!"}\NormalTok{);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Chaining method calls}\label{chaining-method-calls}

So, now we know how to call a method, such as \texttt{foo.bar()}. But
what about our original example, \texttt{foo.bar().baz()}? This is
called `method chaining'. Let's look at an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{grow(&}\KeywordTok{self}\NormalTok{, increment: }\DataTypeTok{f64}\NormalTok{) -> Circle \{}
        \NormalTok{Circle \{ x: }\KeywordTok{self}\NormalTok{.x, y: }\KeywordTok{self}\NormalTok{.y, radius: }\KeywordTok{self}\NormalTok{.radius + increment \}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{c = Circle \{ x: }\DecValTok{0.0}\NormalTok{, y: }\DecValTok{0.0}\NormalTok{, radius: }\DecValTok{2.0} \NormalTok{\};}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, c.area());}

    \KeywordTok{let} \NormalTok{d = c.grow(}\DecValTok{2.0}\NormalTok{).area();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, d);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Check the return type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{grow(&}\KeywordTok{self}\NormalTok{, increment: }\DataTypeTok{f64}\NormalTok{) -> Circle \{}
\end{Highlighting}
\end{Shaded}

We just say we're returning a \texttt{Circle}. With this method, we can
grow a new \texttt{Circle} to any arbitrary size.

\subsection{Associated functions}\label{associated-functions}

You can also define associated functions that do not take a
\texttt{self} parameter. Here's a pattern that's very common in Rust
code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{new(x: }\DataTypeTok{f64}\NormalTok{, y: }\DataTypeTok{f64}\NormalTok{, radius: }\DataTypeTok{f64}\NormalTok{) -> Circle \{}
        \NormalTok{Circle \{}
            \NormalTok{x: x,}
            \NormalTok{y: y,}
            \NormalTok{radius: radius,}
        \NormalTok{\}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{c = Circle::new(}\DecValTok{0.0}\NormalTok{, }\DecValTok{0.0}\NormalTok{, }\DecValTok{2.0}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This `associated function' builds a new \texttt{Circle} for us. Note
that associated functions are called with the
\texttt{Struct::function()} syntax, rather than the
\texttt{ref.method()} syntax. Some other languages call associated
functions `static methods'.

\subsection{Builder Pattern}\label{builder-pattern}

Let's say that we want our users to be able to create \texttt{Circle}s,
but we will allow them to only set the properties they care about.
Otherwise, the \texttt{x} and \texttt{y} attributes will be
\texttt{0.0}, and the \texttt{radius} will be \texttt{1.0}. Rust doesn't
have method overloading, named arguments, or variable arguments. We
employ the builder pattern instead. It looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{CircleBuilder \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{CircleBuilder \{}
    \KeywordTok{fn} \NormalTok{new() -> CircleBuilder \{}
        \NormalTok{CircleBuilder \{ x: }\DecValTok{0.0}\NormalTok{, y: }\DecValTok{0.0}\NormalTok{, radius: }\DecValTok{1.0}\NormalTok{, \}}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{x(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{, coordinate: }\DataTypeTok{f64}\NormalTok{) -> &}\KeywordTok{mut} \NormalTok{CircleBuilder \{}
        \KeywordTok{self}\NormalTok{.x = coordinate;}
        \KeywordTok{self}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{y(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{, coordinate: }\DataTypeTok{f64}\NormalTok{) -> &}\KeywordTok{mut} \NormalTok{CircleBuilder \{}
        \KeywordTok{self}\NormalTok{.y = coordinate;}
        \KeywordTok{self}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{radius(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{, radius: }\DataTypeTok{f64}\NormalTok{) -> &}\KeywordTok{mut} \NormalTok{CircleBuilder \{}
        \KeywordTok{self}\NormalTok{.radius = radius;}
        \KeywordTok{self}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{finalize(&}\KeywordTok{self}\NormalTok{) -> Circle \{}
        \NormalTok{Circle \{ x: }\KeywordTok{self}\NormalTok{.x, y: }\KeywordTok{self}\NormalTok{.y, radius: }\KeywordTok{self}\NormalTok{.radius \}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{c = CircleBuilder::new()}
                \NormalTok{.x(}\DecValTok{1.0}\NormalTok{)}
                \NormalTok{.y(}\DecValTok{2.0}\NormalTok{)}
                \NormalTok{.radius(}\DecValTok{2.0}\NormalTok{)}
                \NormalTok{.finalize();}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"area: \{\}"}\NormalTok{, c.area());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"x: \{\}"}\NormalTok{, c.x);}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"y: \{\}"}\NormalTok{, c.y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

What we've done here is make another \texttt{struct},
\texttt{CircleBuilder}. We've defined our builder methods on it. We've
also defined our \texttt{area()} method on \texttt{Circle}. We also made
one more method on \texttt{CircleBuilder}: \texttt{finalize()}. This
method creates our final \texttt{Circle} from the builder. Now, we've
used the type system to enforce our concerns: we can use the methods on
\texttt{CircleBuilder} to constrain making \texttt{Circle}s in any way
we choose.

\hyperdef{}{sec--vectors}{\section{Vectors}\label{sec--vectors}}

A `vector' is a dynamic or `growable' array, implemented as the standard
library type
\href{http://doc.rust-lang.org/std/vec/index.html}{\texttt{Vec\textless{}T\textgreater{}}}.
The \texttt{T} means that we can have vectors of any type (see the
chapter on \hyperref[sec--generics]{generics} for more). Vectors always
allocate their data on the heap. You can create them with the
\texttt{vec!} macro:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]; }\CommentTok{// v: Vec<i32>}
\end{Highlighting}
\end{Shaded}

(Notice that unlike the \texttt{println!} macro we've used in the past,
we use square brackets \texttt{{[}{]}} with \texttt{vec!} macro. Rust
allows you to use either in either situation, this is just convention.)

There's an alternate form of \texttt{vec!} for repeating an initial
value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{0}\NormalTok{; }\DecValTok{10}\NormalTok{]; }\CommentTok{// ten zeroes}
\end{Highlighting}
\end{Shaded}

\subsubsection{Accessing elements}\label{accessing-elements}

To get the value at a particular index in the vector, we use
\texttt{{[}{]}}s:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{];}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"The third element of v is \{\}"}\NormalTok{, v[}\DecValTok{2}\NormalTok{]);}
\end{Highlighting}
\end{Shaded}

The indices count from \texttt{0}, so the third element is
\texttt{v{[}2{]}}.

\subsubsection{Iterating}\label{iterating}

Once you have a vector, you can iterate through its elements with
\texttt{for}. There are three versions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{];}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{&v \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"A reference to \{\}"}\NormalTok{, i);}
\NormalTok{\}}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{&}\KeywordTok{mut} \NormalTok{v \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"A mutable reference to \{\}"}\NormalTok{, i);}
\NormalTok{\}}

\KeywordTok{for} \NormalTok{i }\KeywordTok{in} \NormalTok{v \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Take ownership of the vector and its element \{\}"}\NormalTok{, i);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Vectors have many more useful methods, which you can read about in
\href{http://doc.rust-lang.org/std/vec/index.html}{their API
documentation}.

\hyperdef{}{sec--strings}{\section{Strings}\label{sec--strings}}

Strings are an important concept for any programmer to master. Rust's
string handling system is a bit different from other languages, due to
its systems focus. Any time you have a data structure of variable size,
things can get tricky, and strings are a re-sizable data structure. That
being said, Rust's strings also work differently than in some other
systems languages, such as C.

Let's dig into the details. A `string' is a sequence of Unicode scalar
values encoded as a stream of UTF-8 bytes. All strings are guaranteed to
be a valid encoding of UTF-8 sequences. Additionally, unlike some
systems languages, strings are not null-terminated and can contain null
bytes.

Rust has two main types of strings: \texttt{\&str} and \texttt{String}.
Let's talk about \texttt{\&str} first. These are called `string slices'.
String literals are of the type
\texttt{\&\textquotesingle{}static\ str}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{greeting = }\StringTok{"Hello there."}\NormalTok{; }\CommentTok{// greeting: &'static str}
\end{Highlighting}
\end{Shaded}

This string is statically allocated, meaning that it's saved inside our
compiled program, and exists for the entire duration it runs. The
\texttt{greeting} binding is a reference to this statically allocated
string. String slices have a fixed size, and cannot be mutated.

A \texttt{String}, on the other hand, is a heap-allocated string. This
string is growable, and is also guaranteed to be UTF-8. \texttt{String}s
are commonly created by converting from a string slice using the
\texttt{to\_string} method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{s = }\StringTok{"Hello"}\NormalTok{.to_string(); }\CommentTok{// mut s: String}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, s);}

\NormalTok{s.push_str(}\StringTok{", world."}\NormalTok{);}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, s);}
\end{Highlighting}
\end{Shaded}

\texttt{String}s will coerce into \texttt{\&str} with an \texttt{\&}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{takes_slice(slice: &}\DataTypeTok{str}\NormalTok{) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Got: \{\}"}\NormalTok{, slice);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{s = }\StringTok{"Hello"}\NormalTok{.to_string();}
    \NormalTok{takes_slice(&s);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This coercion does not happen for functions that accept one of
\texttt{\&str}'s traits instead of \texttt{\&str}. For example,
\href{http://doc.rust-lang.org/std/net/struct.TcpStream.html\#method.connect}{\texttt{TcpStream::connect}}
has a parameter of type \texttt{ToSocketAddrs}. A \texttt{\&str} is okay
but a \texttt{String} must be explicitly converted using \texttt{\&*}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::net::TcpStream;}

\NormalTok{TcpStream::connect(}\StringTok{"192.168.0.1:3000"}\NormalTok{); }\CommentTok{// &str parameter}

\KeywordTok{let} \NormalTok{addr_string = }\StringTok{"192.168.0.1:3000"}\NormalTok{.to_string();}
\NormalTok{TcpStream::connect(&*addr_string); }\CommentTok{// convert addr_string to &str}
\end{Highlighting}
\end{Shaded}

Viewing a \texttt{String} as a \texttt{\&str} is cheap, but converting
the \texttt{\&str} to a \texttt{String} involves allocating memory. No
reason to do that unless you have to!

\subsubsection{Indexing}\label{indexing}

Because strings are valid UTF-8, strings do not support indexing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{s = }\StringTok{"hello"}\NormalTok{;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"The first letter of s is \{\}"}\NormalTok{, s[}\DecValTok{0}\NormalTok{]); }\CommentTok{// ERROR!!!}
\end{Highlighting}
\end{Shaded}

Usually, access to a vector with \texttt{{[}{]}} is very fast. But,
because each character in a UTF-8 encoded string can be multiple bytes,
you have to walk over the string to find the n·µó ∞ letter of a string.
This is a significantly more expensive operation, and we don't want to
be misleading. Furthermore, `letter' isn't something defined in Unicode,
exactly. We can choose to look at a string as individual bytes, or as
codepoints:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{hachiko = }\StringTok{"Âø†Áä¨„Éè„ÉÅÂÖ¨"}\NormalTok{;}

\KeywordTok{for} \NormalTok{b }\KeywordTok{in} \NormalTok{hachiko.as_bytes() \{}
    \PreprocessorTok{print!}\NormalTok{(}\StringTok{"\{\}, "}\NormalTok{, b);}
\NormalTok{\}}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{""}\NormalTok{);}

\KeywordTok{for} \NormalTok{c }\KeywordTok{in} \NormalTok{hachiko.chars() \{}
    \PreprocessorTok{print!}\NormalTok{(}\StringTok{"\{\}, "}\NormalTok{, c);}
\NormalTok{\}}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{""}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

This prints:

\begin{verbatim}
229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
Âø†, Áä¨, „Éè, „ÉÅ, ÂÖ¨, 
\end{verbatim}

As you can see, there are more bytes than \texttt{char}s.

You can get something similar to an index like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{dog = hachiko.chars().nth(}\DecValTok{1}\NormalTok{); }\CommentTok{// kinda like hachiko[1]}
\end{Highlighting}
\end{Shaded}

This emphasizes that we have to walk from the beginning of the list of
\texttt{chars}.

\subsubsection{Slicing}\label{slicing}

You can get a slice of a string with slicing syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{dog = }\StringTok{"hachiko"}\NormalTok{;}
\KeywordTok{let} \NormalTok{hachi = &dog[}\DecValTok{0.}\NormalTok{.}\DecValTok{5}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

But note that these are \emph{byte} offsets, not \emph{character}
offsets. So this will fail at runtime:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{dog = }\StringTok{"Âø†Áä¨„Éè„ÉÅÂÖ¨"}\NormalTok{;}
\KeywordTok{let} \NormalTok{hachi = &dog[}\DecValTok{0.}\NormalTok{.}\DecValTok{2}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

with this error:

\begin{verbatim}
thread '<main>' panicked at 'index 0 and/or 2 in `Âø†Áä¨„Éè„ÉÅÂÖ¨` do not lie on
character boundary'
\end{verbatim}

\subsubsection{Concatenation}\label{concatenation}

If you have a \texttt{String}, you can concatenate a \texttt{\&str} to
the end of it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{hello = }\StringTok{"Hello "}\NormalTok{.to_string();}
\KeywordTok{let} \NormalTok{world = }\StringTok{"world!"}\NormalTok{;}

\KeywordTok{let} \NormalTok{hello_world = hello + world;}
\end{Highlighting}
\end{Shaded}

But if you have two \texttt{String}s, you need an \texttt{\&}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{hello = }\StringTok{"Hello "}\NormalTok{.to_string();}
\KeywordTok{let} \NormalTok{world = }\StringTok{"world!"}\NormalTok{.to_string();}

\KeywordTok{let} \NormalTok{hello_world = hello + &world;}
\end{Highlighting}
\end{Shaded}

This is because \texttt{\&String} can automatically coerce to a
\texttt{\&str}. This is a feature called
`\hyperref[sec--deref-coercions]{\texttt{Deref} coercions}'.

\hyperdef{}{sec--generics}{\section{Generics}\label{sec--generics}}

Sometimes, when writing a function or data type, we may want it to work
for multiple types of arguments. In Rust, we can do this with generics.
Generics are called `parametric polymorphism' in type theory, which
means that they are types or functions that have multiple forms (`poly'
is multiple, `morph' is form) over a given parameter (`parametric').

Anyway, enough type theory, let's check out some generic code. Rust's
standard library provides a type,
\texttt{Option\textless{}T\textgreater{}}, that's generic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Option}\NormalTok{<T> \{}
    \ConstantTok{Some}\NormalTok{(T),}
    \ConstantTok{None}\NormalTok{,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{\textless{}T\textgreater{}} part, which you've seen a few
times before, indicates that this is a generic data type. Inside the
declaration of our \texttt{enum}, wherever we see a \texttt{T}, we
substitute that type for the same type used in the generic. Here's an
example of using \texttt{Option\textless{}T\textgreater{}}, with some
extra type annotations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{i32}\NormalTok{> = }\ConstantTok{Some}\NormalTok{(}\DecValTok{5}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

In the type declaration, we say
\texttt{Option\textless{}i32\textgreater{}}. Note how similar this looks
to \texttt{Option\textless{}T\textgreater{}}. So, in this particular
\texttt{Option}, \texttt{T} has the value of \texttt{i32}. On the
right-hand side of the binding, we make a \texttt{Some(T)}, where
\texttt{T} is \texttt{5}. Since that's an \texttt{i32}, the two sides
match, and Rust is happy. If they didn't match, we'd get an error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{f64}\NormalTok{> = }\ConstantTok{Some}\NormalTok{(}\DecValTok{5}\NormalTok{);}
\CommentTok{// error: mismatched types: expected `core::option::Option<f64>`,}
\CommentTok{// found `core::option::Option<_>` (expected f64 but found integral variable)}
\end{Highlighting}
\end{Shaded}

That doesn't mean we can't make
\texttt{Option\textless{}T\textgreater{}}s that hold an \texttt{f64}!
They just have to match up:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{i32}\NormalTok{> = }\ConstantTok{Some}\NormalTok{(}\DecValTok{5}\NormalTok{);}
\KeywordTok{let} \NormalTok{y: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{f64}\NormalTok{> = }\ConstantTok{Some}\NormalTok{(}\DecValTok{5.0f64}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

This is just fine. One definition, multiple uses.

Generics don't have to only be generic over one type. Consider another
type from Rust's standard library that's similar,
\texttt{Result\textless{}T,\ E\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Result}\NormalTok{<T, E> \{}
    \ConstantTok{Ok}\NormalTok{(T),}
    \ConstantTok{Err}\NormalTok{(E),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This type is generic over \emph{two} types: \texttt{T} and \texttt{E}.
By the way, the capital letters can be any letter you'd like. We could
define \texttt{Result\textless{}T,\ E\textgreater{}} as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \DataTypeTok{Result}\NormalTok{<A, Z> \{}
    \ConstantTok{Ok}\NormalTok{(A),}
    \ConstantTok{Err}\NormalTok{(Z),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

if we wanted to. Convention says that the first generic parameter should
be \texttt{T}, for `type', and that we use \texttt{E} for `error'. Rust
doesn't care, however.

The \texttt{Result\textless{}T,\ E\textgreater{}} type is intended to be
used to return the result of a computation, and to have the ability to
return an error if it didn't work out.

\subsubsection{Generic functions}\label{generic-functions}

We can write functions that take generic types with a similar syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{takes_anything<T>(x: T) \{}
    \CommentTok{// do something with x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The syntax has two parts: the \texttt{\textless{}T\textgreater{}} says
``this function is generic over one type, \texttt{T}'', and the
\texttt{x:\ T} says ``x has the type \texttt{T}.''

Multiple arguments can have the same generic type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{takes_two_of_the_same_things<T>(x: T, y: T) \{}
    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We could write a version that takes multiple types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{takes_two_things<T, U>(x: T, y: U) \{}
    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Generic structs}\label{generic-structs}

You can store a generic type in a \texttt{struct} as well:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point<T> \{}
    \NormalTok{x: T,}
    \NormalTok{y: T,}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{int_origin = Point \{ x: }\DecValTok{0}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}
\KeywordTok{let} \NormalTok{float_origin = Point \{ x: }\DecValTok{0.0}\NormalTok{, y: }\DecValTok{0.0} \NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Similar to functions, the \texttt{\textless{}T\textgreater{}} is where
we declare the generic parameters, and we then use \texttt{x:\ T} in the
type declaration, too.

When you want to add an implementation for the generic \texttt{struct},
you just declare the type parameter after the \texttt{impl}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{#}
\KeywordTok{impl}\NormalTok{<T> Point<T> \{}
    \KeywordTok{fn} \NormalTok{swap(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{) \{}
        \NormalTok{std::mem::swap(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{.x, &}\KeywordTok{mut} \KeywordTok{self}\NormalTok{.y);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

So far you've seen generics that take absolutely any type. These are
useful in many cases: you've already seen
\texttt{Option\textless{}T\textgreater{}}, and later you'll meet
universal container types like
\href{http://doc.rust-lang.org/std/vec/struct.Vec.html}{\texttt{Vec\textless{}T\textgreater{}}}.
On the other hand, often you want to trade that flexibility for
increased expressive power. Read about \hyperref[sec--traits]{trait
bounds} to see why and how.

\hyperdef{}{sec--traits}{\section{Traits}\label{sec--traits}}

A trait is a language feature that tells the Rust compiler about
functionality a type must provide.

Do you remember the \texttt{impl} keyword, used to call a function with
\hyperref[sec--method-syntax]{method syntax}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Traits are similar, except that we define a trait with just the method
signature, then implement the trait for that struct. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{trait} \NormalTok{HasArea \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{HasArea }\KeywordTok{for} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As you can see, the \texttt{trait} block looks very similar to the
\texttt{impl} block, but we don't define a body, just a type signature.
When we \texttt{impl} a trait, we use \texttt{impl\ Trait\ for\ Item},
rather than just \texttt{impl\ Item}.

\subsubsection{Traits bounds for generic
functions}\label{traits-bounds-for-generic-functions}

Traits are useful because they allow a type to make certain promises
about its behavior. Generic functions can exploit this to constrain the
types they accept. Consider this function, which does not compile:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print_area<T>(shape: T) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"This shape has an area of \{\}"}\NormalTok{, shape.area());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Rust complains:

\begin{verbatim}
error: no method named `area` found for type `T` in the current scope
\end{verbatim}

Because \texttt{T} can be any type, we can't be sure that it implements
the \texttt{area} method. But we can add a `trait constraint' to our
generic \texttt{T}, ensuring that it does:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{print_area<T: HasArea>(shape: T) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"This shape has an area of \{\}"}\NormalTok{, shape.area());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The syntax \texttt{\textless{}T:\ HasArea\textgreater{}} means ``any
type that implements the \texttt{HasArea} trait.'' Because traits define
function type signatures, we can be sure that any type which implements
\texttt{HasArea} will have an \texttt{.area()} method.

Here's an extended example of how this works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{HasArea \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Circle \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{radius: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{HasArea }\KeywordTok{for} \NormalTok{Circle \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \NormalTok{std::}\DataTypeTok{f64}\NormalTok{::consts::PI * (}\KeywordTok{self}\NormalTok{.radius * }\KeywordTok{self}\NormalTok{.radius)}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Square \{}
    \NormalTok{x: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{f64}\NormalTok{,}
    \NormalTok{side: }\DataTypeTok{f64}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{HasArea }\KeywordTok{for} \NormalTok{Square \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \KeywordTok{self}\NormalTok{.side * }\KeywordTok{self}\NormalTok{.side}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{print_area<T: HasArea>(shape: T) \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"This shape has an area of \{\}"}\NormalTok{, shape.area());}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{c = Circle \{}
        \NormalTok{x: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{y: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{radius: }\DecValTok{1.0f64}\NormalTok{,}
    \NormalTok{\};}

    \KeywordTok{let} \NormalTok{s = Square \{}
        \NormalTok{x: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{y: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{side: }\DecValTok{1.0f64}\NormalTok{,}
    \NormalTok{\};}

    \NormalTok{print_area(c);}
    \NormalTok{print_area(s);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This program outputs:

\begin{verbatim}
This shape has an area of 3.141593
This shape has an area of 1
\end{verbatim}

As you can see, \texttt{print\_area} is now generic, but also ensures
that we have passed in the correct types. If we pass in an incorrect
type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print_area(}\DecValTok{5}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

We get a compile-time error:

\begin{verbatim}
error: the trait `HasArea` is not implemented for the type `_` [E0277]
\end{verbatim}

\subsubsection{Traits bounds for generic
structs}\label{traits-bounds-for-generic-structs}

Your generic structs can also benefit from trait constraints. All you
need to do is append the constraint when you declare type parameters.
Here is a new type \texttt{Rectangle\textless{}T\textgreater{}} and its
operation \texttt{is\_square()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Rectangle<T> \{}
    \NormalTok{x: T,}
    \NormalTok{y: T,}
    \NormalTok{width: T,}
    \NormalTok{height: T,}
\NormalTok{\}}

\KeywordTok{impl}\NormalTok{<T: }\BuiltInTok{PartialEq}\NormalTok{> Rectangle<T> \{}
    \KeywordTok{fn} \NormalTok{is_square(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
        \KeywordTok{self}\NormalTok{.width == }\KeywordTok{self}\NormalTok{.height}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{r = Rectangle \{}
        \NormalTok{x: }\DecValTok{0}\NormalTok{,}
        \NormalTok{y: }\DecValTok{0}\NormalTok{,}
        \NormalTok{width: }\DecValTok{47}\NormalTok{,}
        \NormalTok{height: }\DecValTok{47}\NormalTok{,}
    \NormalTok{\};}

    \PreprocessorTok{assert!}\NormalTok{(r.is_square());}

    \NormalTok{r.height = }\DecValTok{42}\NormalTok{;}
    \PreprocessorTok{assert!}\NormalTok{(!r.is_square());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{is\_square()} needs to check that the sides are equal, so the
sides must be of a type that implements the
\href{http://doc.rust-lang.org/core/cmp/trait.PartialEq.html}{\texttt{core::cmp::PartialEq}}
trait:

\begin{verbatim}
impl<T: PartialEq> Rectangle<T> { ... }
\end{verbatim}

Now, a rectangle can be defined in terms of any type that can be
compared for equality.

Here we defined a new struct \texttt{Rectangle} that accepts numbers of
any precision---really, objects of pretty much any type---as long as
they can be compared for equality. Could we do the same for our
\texttt{HasArea} structs, \texttt{Square} and \texttt{Circle}? Yes, but
they need multiplication, and to work with that we need to know more
about \hyperref[sec--operators-and-overloading]{operator traits}.

\subsection{Rules for implementing
traits}\label{rules-for-implementing-traits}

So far, we've only added trait implementations to structs, but you can
implement a trait for any type. So technically, we \emph{could}
implement \texttt{HasArea} for \texttt{i32}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{HasArea \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{HasArea }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"this is silly"}\NormalTok{);}

        \NormalTok{*}\KeywordTok{self} \KeywordTok{as} \DataTypeTok{f64}
    \NormalTok{\}}
\NormalTok{\}}

\DecValTok{5.}\NormalTok{area();}
\end{Highlighting}
\end{Shaded}

It is considered poor style to implement methods on such primitive
types, even though it is possible.

This may seem like the Wild West, but there are two restrictions around
implementing traits that prevent this from getting out of hand. The
first is that if the trait isn't defined in your scope, it doesn't
apply. Here's an example: the standard library provides a
\href{http://doc.rust-lang.org/std/io/trait.Write.html}{\texttt{Write}}
trait which adds extra functionality to \texttt{File}s, for doing file
I/O. By default, a \texttt{File} won't have its methods:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{f = std::fs::File::open(}\StringTok{"foo.txt"}\NormalTok{).ok().expect(}\StringTok{"Couldn‚Äôt open foo.txt"}\NormalTok{);}
\KeywordTok{let} \NormalTok{buf = b}\StringTok{"whatever"}\NormalTok{; }\CommentTok{// byte string literal. buf: &[u8; 8]}
\KeywordTok{let} \NormalTok{result = f.write(buf);}
\end{Highlighting}
\end{Shaded}

Here's the error:

\begin{verbatim}
error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
\end{verbatim}

We need to \texttt{use} the \texttt{Write} trait first:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::io::Write;}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{f = std::fs::File::open(}\StringTok{"foo.txt"}\NormalTok{).ok().expect(}\StringTok{"Couldn‚Äôt open foo.txt"}\NormalTok{);}
\KeywordTok{let} \NormalTok{buf = b}\StringTok{"whatever"}\NormalTok{;}
\KeywordTok{let} \NormalTok{result = f.write(buf);}
\end{Highlighting}
\end{Shaded}

This will compile without error.

This means that even if someone does something bad like add methods to
\texttt{i32}, it won't affect you, unless you \texttt{use} that trait.

There's one more restriction on implementing traits: either the trait,
or the type you're writing the \texttt{impl} for, must be defined by
you. So, we could implement the \texttt{HasArea} type for \texttt{i32},
because \texttt{HasArea} is in our code. But if we tried to implement
\texttt{ToString}, a trait provided by Rust, for \texttt{i32}, we could
not, because neither the trait nor the type are in our code.

One last thing about traits: generic functions with a trait bound use
`monomorphization' (mono: one, morph: form), so they are statically
dispatched. What's that mean? Check out the chapter on
\hyperref[sec--trait-objects]{trait objects} for more details.

\subsection{Multiple trait bounds}\label{multiple-trait-bounds}

You've seen that you can bound a generic type parameter with a trait:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo<T: }\BuiltInTok{Clone}\NormalTok{>(x: T) \{}
    \NormalTok{x.clone();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you need more than one bound, you can use \texttt{+}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt::}\BuiltInTok{Debug}\NormalTok{;}

\KeywordTok{fn} \NormalTok{foo<T: }\BuiltInTok{Clone} \NormalTok{+ }\BuiltInTok{Debug}\NormalTok{>(x: T) \{}
    \NormalTok{x.clone();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{T} now needs to be both \texttt{Clone} as well as
\texttt{Debug}.

\subsection{Where clause}\label{where-clause}

Writing functions with only a few generic types and a small number of
trait bounds isn't too bad, but as the number increases, the syntax gets
increasingly awkward:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt::}\BuiltInTok{Debug}\NormalTok{;}

\KeywordTok{fn} \NormalTok{foo<T: }\BuiltInTok{Clone}\NormalTok{, K: }\BuiltInTok{Clone} \NormalTok{+ }\BuiltInTok{Debug}\NormalTok{>(x: T, y: K) \{}
    \NormalTok{x.clone();}
    \NormalTok{y.clone();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The name of the function is on the far left, and the parameter list is
on the far right. The bounds are getting in the way.

Rust has a solution, and it's called a `\texttt{where} clause':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt::}\BuiltInTok{Debug}\NormalTok{;}

\KeywordTok{fn} \NormalTok{foo<T: }\BuiltInTok{Clone}\NormalTok{, K: }\BuiltInTok{Clone} \NormalTok{+ }\BuiltInTok{Debug}\NormalTok{>(x: T, y: K) \{}
    \NormalTok{x.clone();}
    \NormalTok{y.clone();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, y);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{bar<T, K>(x: T, y: K) }\KeywordTok{where} \NormalTok{T: }\BuiltInTok{Clone}\NormalTok{, K: }\BuiltInTok{Clone} \NormalTok{+ }\BuiltInTok{Debug} \NormalTok{\{}
    \NormalTok{x.clone();}
    \NormalTok{y.clone();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, y);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \NormalTok{foo(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{);}
    \NormalTok{bar(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"world"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{foo()} uses the syntax we showed earlier, and \texttt{bar()}
uses a \texttt{where} clause. All you need to do is leave off the bounds
when defining your type parameters, and then add \texttt{where} after
the parameter list. For longer lists, whitespace can be added:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt::}\BuiltInTok{Debug}\NormalTok{;}

\KeywordTok{fn} \NormalTok{bar<T, K>(x: T, y: K)}
    \KeywordTok{where} \NormalTok{T: }\BuiltInTok{Clone}\NormalTok{,}
          \NormalTok{K: }\BuiltInTok{Clone} \NormalTok{+ }\BuiltInTok{Debug} \NormalTok{\{}

    \NormalTok{x.clone();}
    \NormalTok{y.clone();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This flexibility can add clarity in complex situations.

\texttt{where} is also more powerful than the simpler syntax. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{ConvertTo<Output> \{}
    \KeywordTok{fn} \NormalTok{convert(&}\KeywordTok{self}\NormalTok{) -> Output;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{ConvertTo<}\DataTypeTok{i64}\NormalTok{> }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{convert(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{i64} \NormalTok{\{ *}\KeywordTok{self} \KeywordTok{as} \DataTypeTok{i64} \NormalTok{\}}
\NormalTok{\}}

\CommentTok{// can be called with T == i32}
\KeywordTok{fn} \NormalTok{normal<T: ConvertTo<}\DataTypeTok{i64}\NormalTok{>>(x: &T) -> }\DataTypeTok{i64} \NormalTok{\{}
    \NormalTok{x.convert()}
\NormalTok{\}}

\CommentTok{// can be called with T == i64}
\KeywordTok{fn} \NormalTok{inverse<T>() -> T}
        \CommentTok{// this is using ConvertTo as if it were "ConvertTo<i64>"}
        \KeywordTok{where} \DataTypeTok{i32}\NormalTok{: ConvertTo<T> \{}
    \DecValTok{42.}\NormalTok{convert()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This shows off the additional feature of \texttt{where} clauses: they
allow bounds where the left-hand side is an arbitrary type (\texttt{i32}
in this case), not just a plain type parameter (like \texttt{T}).

\subsection{Default methods}\label{default-methods}

If you already know how a typical implementor will define a method, you
can let your trait supply a default:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{is_valid(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool}\NormalTok{;}

    \KeywordTok{fn} \NormalTok{is_invalid(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{ !}\KeywordTok{self}\NormalTok{.is_valid() \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Implementors of the \texttt{Foo} trait need to implement
\texttt{is\_valid()}, but they don't need to implement
\texttt{is\_invalid()}. They'll get this default behavior. They can
override the default if they so choose:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{#}
\KeywordTok{struct} \NormalTok{UseDefault;}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{UseDefault \{}
    \KeywordTok{fn} \NormalTok{is_valid(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Called UseDefault.is_valid."}\NormalTok{);}
        \ConstantTok{true}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{OverrideDefault;}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{OverrideDefault \{}
    \KeywordTok{fn} \NormalTok{is_valid(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Called OverrideDefault.is_valid."}\NormalTok{);}
        \ConstantTok{true}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{is_invalid(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{bool} \NormalTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Called OverrideDefault.is_invalid!"}\NormalTok{);}
        \ConstantTok{true} \CommentTok{// this implementation is a self-contradiction!}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{default = UseDefault;}
\PreprocessorTok{assert!}\NormalTok{(!default.is_invalid()); }\CommentTok{// prints "Called UseDefault.is_valid."}

\KeywordTok{let} \NormalTok{over = OverrideDefault;}
\PreprocessorTok{assert!}\NormalTok{(over.is_invalid()); }\CommentTok{// prints "Called OverrideDefault.is_invalid!"}
\end{Highlighting}
\end{Shaded}

\subsection{Inheritance}\label{inheritance}

Sometimes, implementing a trait requires implementing another trait:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{foo(&}\KeywordTok{self}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{trait} \NormalTok{FooBar : Foo \{}
    \KeywordTok{fn} \NormalTok{foobar(&}\KeywordTok{self}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Implementors of \texttt{FooBar} must also implement \texttt{Foo}, like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Baz;}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{Baz \{}
    \KeywordTok{fn} \NormalTok{foo(&}\KeywordTok{self}\NormalTok{) \{ }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"foo"}\NormalTok{); \}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{FooBar }\KeywordTok{for} \NormalTok{Baz \{}
    \KeywordTok{fn} \NormalTok{foobar(&}\KeywordTok{self}\NormalTok{) \{ }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"foobar"}\NormalTok{); \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we forget to implement \texttt{Foo}, Rust will tell us:

\begin{verbatim}
error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
\end{verbatim}

\hyperdef{}{sec--drop}{\section{Drop}\label{sec--drop}}

Now that we've discussed traits, let's talk about a particular trait
provided by the Rust standard library,
\href{http://doc.rust-lang.org/std/ops/trait.Drop.html}{\texttt{Drop}}.
The \texttt{Drop} trait provides a way to run some code when a value
goes out of scope. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{HasDrop;}

\KeywordTok{impl} \BuiltInTok{Drop} \KeywordTok{for} \NormalTok{HasDrop \{}
    \KeywordTok{fn} \NormalTok{drop(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Dropping!"}\NormalTok{);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = HasDrop;}

    \CommentTok{// do stuff}

\NormalTok{\} }\CommentTok{// x goes out of scope here}
\end{Highlighting}
\end{Shaded}

When \texttt{x} goes out of scope at the end of \texttt{main()}, the
code for \texttt{Drop} will run. \texttt{Drop} has one method, which is
also called \texttt{drop()}. It takes a mutable reference to
\texttt{self}.

That's it! The mechanics of \texttt{Drop} are very simple, but there are
some subtleties. For example, values are dropped in the opposite order
they are declared. Here's another example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Firework \{}
    \NormalTok{strength: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \BuiltInTok{Drop} \KeywordTok{for} \NormalTok{Firework \{}
    \KeywordTok{fn} \NormalTok{drop(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"BOOM times \{\}!!!"}\NormalTok{, }\KeywordTok{self}\NormalTok{.strength);}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{firecracker = Firework \{ strength: }\DecValTok{1} \NormalTok{\};}
    \KeywordTok{let} \NormalTok{tnt = Firework \{ strength: }\DecValTok{100} \NormalTok{\};}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will output:

\begin{verbatim}
BOOM times 100!!!
BOOM times 1!!!
\end{verbatim}

The TNT goes off before the firecracker does, because it was declared
afterwards. Last in, first out.

So what is \texttt{Drop} good for? Generally, \texttt{Drop} is used to
clean up any resources associated with a \texttt{struct}. For example,
the
\href{http://doc.rust-lang.org/std/sync/struct.Arc.html}{\texttt{Arc\textless{}T\textgreater{}}
type} is a reference-counted type. When \texttt{Drop} is called, it will
decrement the reference count, and if the total number of references is
zero, will clean up the underlying value.

\hyperdef{}{sec--if-let}{\section{if let}\label{sec--if-let}}

\texttt{if\ let} allows you to combine \texttt{if} and \texttt{let}
together to reduce the overhead of certain kinds of pattern matches.

For example, let's say we have some sort of
\texttt{Option\textless{}T\textgreater{}}. We want to call a function on
it if it's \texttt{Some\textless{}T\textgreater{}}, but do nothing if
it's \texttt{None}. That looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{match} \NormalTok{option \{}
    \ConstantTok{Some}\NormalTok{(x) => \{ foo(x) \},}
    \ConstantTok{None} \NormalTok{=> \{\},}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We don't have to use \texttt{match} here, for example, we could use
\texttt{if}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \NormalTok{option.is_some() \{}
    \KeywordTok{let} \NormalTok{x = option.unwrap();}
    \NormalTok{foo(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Neither of these options is particularly appealing. We can use
\texttt{if\ let} to do the same thing in a nicer way:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \KeywordTok{let} \ConstantTok{Some}\NormalTok{(x) = option \{}
    \NormalTok{foo(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If a \hyperref[sec--patterns]{pattern} matches successfully, it binds
any appropriate parts of the value to the identifiers in the pattern,
then evaluates the expression. If the pattern doesn't match, nothing
happens.

If you'd rather to do something else when the pattern does not match,
you can use \texttt{else}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \KeywordTok{let} \ConstantTok{Some}\NormalTok{(x) = option \{}
    \NormalTok{foo(x);}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \NormalTok{bar();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{while\ let}}{while let}}\label{while-let}

In a similar fashion, \texttt{while\ let} can be used when you want to
conditionally loop as long as a value matches a certain pattern. It
turns code like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{loop} \NormalTok{\{}
    \KeywordTok{match} \NormalTok{option \{}
        \ConstantTok{Some}\NormalTok{(x) => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x),}
        \NormalTok{_ => }\KeywordTok{break}\NormalTok{,}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Into code like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{while} \KeywordTok{let} \ConstantTok{Some}\NormalTok{(x) = option \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--trait-objects}{\section{Trait
Objects}\label{sec--trait-objects}}

When code involves polymorphism, there needs to be a mechanism to
determine which specific version is actually run. This is called
`dispatch'. There are two major forms of dispatch: static dispatch and
dynamic dispatch. While Rust favors static dispatch, it also supports
dynamic dispatch through a mechanism called `trait objects'.

\subsubsection{Background}\label{background}

For the rest of this chapter, we'll need a trait and some
implementations. Let's make a simple one, \texttt{Foo}. It has one
method that is expected to return a \texttt{String}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{method(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{String}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We'll also implement this trait for \texttt{u8} and \texttt{String}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{u8} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{method(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{String} \NormalTok{\{ }\PreprocessorTok{format!}\NormalTok{(}\StringTok{"u8: \{\}"}\NormalTok{, *}\KeywordTok{self}\NormalTok{) \}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{String} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{method(&}\KeywordTok{self}\NormalTok{) -> }\DataTypeTok{String} \NormalTok{\{ }\PreprocessorTok{format!}\NormalTok{(}\StringTok{"string: \{\}"}\NormalTok{, *}\KeywordTok{self}\NormalTok{) \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Static dispatch}\label{static-dispatch}

We can use this trait to perform static dispatch with trait bounds:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{do_something<T: Foo>(x: T) \{}
    \NormalTok{x.method();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5u8}\NormalTok{;}
    \KeywordTok{let} \NormalTok{y = }\StringTok{"Hello"}\NormalTok{.to_string();}

    \NormalTok{do_something(x);}
    \NormalTok{do_something(y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Rust uses `monomorphization' to perform static dispatch here. This means
that Rust will create a special version of \texttt{do\_something()} for
both \texttt{u8} and \texttt{String}, and then replace the call sites
with calls to these specialized functions. In other words, Rust
generates something like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{do_something_u8(x: }\DataTypeTok{u8}\NormalTok{) \{}
    \NormalTok{x.method();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{do_something_string(x: }\DataTypeTok{String}\NormalTok{) \{}
    \NormalTok{x.method();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5u8}\NormalTok{;}
    \KeywordTok{let} \NormalTok{y = }\StringTok{"Hello"}\NormalTok{.to_string();}

    \NormalTok{do_something_u8(x);}
    \NormalTok{do_something_string(y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This has a great upside: static dispatch allows function calls to be
inlined because the callee is known at compile time, and inlining is the
key to good optimization. Static dispatch is fast, but it comes at a
tradeoff: `code bloat', due to many copies of the same function existing
in the binary, one for each type.

Furthermore, compilers aren't perfect and may ``optimize'' code to
become slower. For example, functions inlined too eagerly will bloat the
instruction cache (cache rules everything around us). This is part of
the reason that \texttt{\#{[}inline{]}} and
\texttt{\#{[}inline(always){]}} should be used carefully, and one reason
why using a dynamic dispatch is sometimes more efficient.

However, the common case is that it is more efficient to use static
dispatch, and one can always have a thin statically-dispatched wrapper
function that does a dynamic dispatch, but not vice versa, meaning
static calls are more flexible. The standard library tries to be
statically dispatched where possible for this reason.

\subsubsection{Dynamic dispatch}\label{dynamic-dispatch}

Rust provides dynamic dispatch through a feature called `trait objects'.
Trait objects, like \texttt{\&Foo} or
\texttt{Box\textless{}Foo\textgreater{}}, are normal values that store a
value of \emph{any} type that implements the given trait, where the
precise type can only be known at runtime.

A trait object can be obtained from a pointer to a concrete type that
implements the trait by \emph{casting} it (e.g. \texttt{\&x\ as\ \&Foo})
or \emph{coercing} it (e.g.~using \texttt{\&x} as an argument to a
function that takes \texttt{\&Foo}).

These trait object coercions and casts also work for pointers like
\texttt{\&mut\ T} to \texttt{\&mut\ Foo} and
\texttt{Box\textless{}T\textgreater{}} to
\texttt{Box\textless{}Foo\textgreater{}}, but that's all at the moment.
Coercions and casts are identical.

This operation can be seen as `erasing' the compiler's knowledge about
the specific type of the pointer, and hence trait objects are sometimes
referred to as `type erasure'.

Coming back to the example above, we can use the same trait to perform
dynamic dispatch with trait objects by casting:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{fn} \NormalTok{do_something(x: &Foo) \{}
    \NormalTok{x.method();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5u8}\NormalTok{;}
    \NormalTok{do_something(&x }\KeywordTok{as} \NormalTok{&Foo);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

or by coercing:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{fn} \NormalTok{do_something(x: &Foo) \{}
    \NormalTok{x.method();}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\StringTok{"Hello"}\NormalTok{.to_string();}
    \NormalTok{do_something(&x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A function that takes a trait object is not specialized to each of the
types that implements \texttt{Foo}: only one copy is generated, often
(but not always) resulting in less code bloat. However, this comes at
the cost of requiring slower virtual function calls, and effectively
inhibiting any chance of inlining and related optimizations from
occurring.

\paragraph{Why pointers?}\label{why-pointers}

Rust does not put things behind a pointer by default, unlike many
managed languages, so types can have different sizes. Knowing the size
of the value at compile time is important for things like passing it as
an argument to a function, moving it about on the stack and allocating
(and deallocating) space on the heap to store it.

For \texttt{Foo}, we would need to have a value that could be at least
either a \texttt{String} (24 bytes) or a \texttt{u8} (1 byte), as well
as any other type for which dependent crates may implement \texttt{Foo}
(any number of bytes at all). There's no way to guarantee that this last
point can work if the values are stored without a pointer, because those
other types can be arbitrarily large.

Putting the value behind a pointer means the size of the value is not
relevant when we are tossing a trait object around, only the size of the
pointer itself.

\paragraph{Representation}\label{representation}

The methods of the trait can be called on a trait object via a special
record of function pointers traditionally called a `vtable' (created and
managed by the compiler).

Trait objects are both simple and complicated: their core representation
and layout is quite straight-forward, but there are some curly error
messages and surprising behaviors to discover.

Let's start simple, with the runtime representation of a trait object.
The \texttt{std::raw} module contains structs with layouts that are the
same as the complicated built-in types,
\href{http://doc.rust-lang.org/std/raw/struct.TraitObject.html}{including
trait objects}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{struct} \NormalTok{TraitObject \{}
    \KeywordTok{pub} \NormalTok{data: *}\KeywordTok{mut} \NormalTok{(),}
    \KeywordTok{pub} \NormalTok{vtable: *}\KeywordTok{mut} \NormalTok{(),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That is, a trait object like \texttt{\&Foo} consists of a `data' pointer
and a `vtable' pointer.

The data pointer addresses the data (of some unknown type \texttt{T})
that the trait object is storing, and the vtable pointer points to the
vtable (`virtual method table') corresponding to the implementation of
\texttt{Foo} for \texttt{T}.

A vtable is essentially a struct of function pointers, pointing to the
concrete piece of machine code for each method in the implementation. A
method call like \texttt{trait\_object.method()} will retrieve the
correct pointer out of the vtable and then do a dynamic call of it. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{FooVtable \{}
    \NormalTok{destructor: }\KeywordTok{fn}\NormalTok{(*}\KeywordTok{mut} \NormalTok{()),}
    \NormalTok{size: }\DataTypeTok{usize}\NormalTok{,}
    \NormalTok{align: }\DataTypeTok{usize}\NormalTok{,}
    \NormalTok{method: }\KeywordTok{fn}\NormalTok{(*}\KeywordTok{const} \NormalTok{()) -> }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\}}

\CommentTok{// u8:}

\KeywordTok{fn} \NormalTok{call_method_on_u8(x: *}\KeywordTok{const} \NormalTok{()) -> }\DataTypeTok{String} \NormalTok{\{}
    \CommentTok{// the compiler guarantees that this function is only called}
    \CommentTok{// with `x` pointing to a u8}
    \KeywordTok{let} \NormalTok{byte: &}\DataTypeTok{u8} \NormalTok{= }\KeywordTok{unsafe} \NormalTok{\{ &*(x }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{u8}\NormalTok{) \};}

    \NormalTok{byte.method()}
\NormalTok{\}}

\KeywordTok{static} \NormalTok{Foo_for_u8_vtable: FooVtable = FooVtable \{}
    \NormalTok{destructor: }\CommentTok{/* compiler magic */}\NormalTok{,}
    \NormalTok{size: }\DecValTok{1}\NormalTok{,}
    \NormalTok{align: }\DecValTok{1}\NormalTok{,}

    \CommentTok{// cast to a function pointer}
    \NormalTok{method: call_method_on_u8 }\KeywordTok{as} \KeywordTok{fn}\NormalTok{(*}\KeywordTok{const} \NormalTok{()) -> }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\};}


\CommentTok{// String:}

\KeywordTok{fn} \NormalTok{call_method_on_String(x: *}\KeywordTok{const} \NormalTok{()) -> }\DataTypeTok{String} \NormalTok{\{}
    \CommentTok{// the compiler guarantees that this function is only called}
    \CommentTok{// with `x` pointing to a String}
    \KeywordTok{let} \NormalTok{string: &}\DataTypeTok{String} \NormalTok{= }\KeywordTok{unsafe} \NormalTok{\{ &*(x }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{String}\NormalTok{) \};}

    \NormalTok{string.method()}
\NormalTok{\}}

\KeywordTok{static} \NormalTok{Foo_for_String_vtable: FooVtable = FooVtable \{}
    \NormalTok{destructor: }\CommentTok{/* compiler magic */}\NormalTok{,}
    \CommentTok{// values for a 64-bit computer, halve them for 32-bit ones}
    \NormalTok{size: }\DecValTok{24}\NormalTok{,}
    \NormalTok{align: }\DecValTok{8}\NormalTok{,}

    \NormalTok{method: call_method_on_String }\KeywordTok{as} \KeywordTok{fn}\NormalTok{(*}\KeywordTok{const} \NormalTok{()) -> }\DataTypeTok{String}\NormalTok{,}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

The \texttt{destructor} field in each vtable points to a function that
will clean up any resources of the vtable's type: for \texttt{u8} it is
trivial, but for \texttt{String} it will free the memory. This is
necessary for owning trait objects like
\texttt{Box\textless{}Foo\textgreater{}}, which need to clean-up both
the \texttt{Box} allocation as well as the internal type when they go
out of scope. The \texttt{size} and \texttt{align} fields store the size
of the erased type, and its alignment requirements; these are
essentially unused at the moment since the information is embedded in
the destructor, but will be used in the future, as trait objects are
progressively made more flexible.

Suppose we've got some values that implement \texttt{Foo}. The explicit
form of construction and use of \texttt{Foo} trait objects might look a
bit like (ignoring the type mismatches: they're all just pointers
anyway):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a: }\DataTypeTok{String} \NormalTok{= }\StringTok{"foo"}\NormalTok{.to_string();}
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{u8} \NormalTok{= }\DecValTok{1}\NormalTok{;}

\CommentTok{// let b: &Foo = &a;}
\KeywordTok{let} \NormalTok{b = TraitObject \{}
    \CommentTok{// store the data}
    \NormalTok{data: &a,}
    \CommentTok{// store the methods}
    \NormalTok{vtable: &Foo_for_String_vtable}
\NormalTok{\};}

\CommentTok{// let y: &Foo = x;}
\KeywordTok{let} \NormalTok{y = TraitObject \{}
    \CommentTok{// store the data}
    \NormalTok{data: &x,}
    \CommentTok{// store the methods}
    \NormalTok{vtable: &Foo_for_u8_vtable}
\NormalTok{\};}

\CommentTok{// b.method();}
\NormalTok{(b.vtable.method)(b.data);}

\CommentTok{// y.method();}
\NormalTok{(y.vtable.method)(y.data);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Object Safety}\label{object-safety}

Not every trait can be used to make a trait object. For example, vectors
implement \texttt{Clone}, but if we try to make a trait object:

\begin{verbatim}
let v = vec![1, 2, 3];
let o = &v as &Clone;
\end{verbatim}

We get an error:

\begin{verbatim}
error: cannot convert to a trait object because trait `core::clone::Clone` is not obje
‚Ü≥ ct-safe [E0038]
let o = &v as &Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &v as &Clone;
        ^~
\end{verbatim}

The error says that \texttt{Clone} is not `object-safe'. Only traits
that are object-safe can be made into trait objects. A trait is
object-safe if both of these are true:

\begin{itemize}
\tightlist
\item
  the trait does not require that \texttt{Self:\ Sized}
\item
  all of its methods are object-safe
\end{itemize}

So what makes a method object-safe? Each method must require that
\texttt{Self:\ Sized} or all of the following:

\begin{itemize}
\tightlist
\item
  must not have any type parameters
\item
  must not use \texttt{Self}
\end{itemize}

Whew! As we can see, almost all of these rules talk about \texttt{Self}.
A good intuition is ``except in special circumstances, if your trait's
method uses \texttt{Self}, it is not object-safe.''

\hyperdef{}{sec--closures}{\section{Closures}\label{sec--closures}}

Rust not only has named functions, but anonymous functions as well.
Anonymous functions that have an associated environment are called
`closures', because they close over an environment. Rust has a really
great implementation of them, as we'll see.

\subsection{Syntax}\label{syntax}

Closures look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{plus_one = |x: }\DataTypeTok{i32}\NormalTok{| x + }\DecValTok{1}\NormalTok{;}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{2}\NormalTok{, plus_one(}\DecValTok{1}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

We create a binding, \texttt{plus\_one}, and assign it to a closure. The
closure's arguments go between the pipes (\texttt{\textbar{}}), and the
body is an expression, in this case, \texttt{x\ +\ 1}. Remember that
\texttt{\{\ \}} is an expression, so we can have multi-line closures
too:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{plus_two = |x| \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{result: }\DataTypeTok{i32} \NormalTok{= x;}

    \NormalTok{result += }\DecValTok{1}\NormalTok{;}
    \NormalTok{result += }\DecValTok{1}\NormalTok{;}

    \NormalTok{result}
\NormalTok{\};}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, plus_two(}\DecValTok{2}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

You'll notice a few things about closures that are a bit different from
regular functions defined with \texttt{fn}. The first is that we did not
need to annotate the types of arguments the closure takes or the values
it returns. We can:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{plus_one = |x: }\DataTypeTok{i32}\NormalTok{| -> }\DataTypeTok{i32} \NormalTok{\{ x + }\DecValTok{1} \NormalTok{\};}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{2}\NormalTok{, plus_one(}\DecValTok{1}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

But we don't have to. Why is this? Basically, it was chosen for
ergonomic reasons. While specifying the full type for named functions is
helpful with things like documentation and type inference, the types of
closures are rarely documented since they're anonymous, and they don't
cause the kinds of error-at-a-distance problems that inferring named
function types can.

The second is that the syntax is similar, but a bit different. I've
added spaces here for easier comparison:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}  \NormalTok{plus_one_v1   (x: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{ x + }\DecValTok{1} \NormalTok{\}}
\KeywordTok{let} \NormalTok{plus_one_v2 = |x: }\DataTypeTok{i32}\NormalTok{| -> }\DataTypeTok{i32} \NormalTok{\{ x + }\DecValTok{1} \NormalTok{\};}
\KeywordTok{let} \NormalTok{plus_one_v3 = |x: }\DataTypeTok{i32}\NormalTok{|          x + }\DecValTok{1}  \NormalTok{;}
\end{Highlighting}
\end{Shaded}

Small differences, but they're similar.

\subsection{Closures and their
environment}\label{closures-and-their-environment}

Closures are called such because they `close over their environment'. It
looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{plus_num = |x: }\DataTypeTok{i32}\NormalTok{| x + num;}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{10}\NormalTok{, plus_num(}\DecValTok{5}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

This closure, \texttt{plus\_num}, refers to a \texttt{let} binding in
its scope: \texttt{num}. More specifically, it borrows the binding. If
we do something that would conflict with that binding, we get an error.
Like this one:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{num = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{plus_num = |x: }\DataTypeTok{i32}\NormalTok{| x + num;}

\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{num;}
\end{Highlighting}
\end{Shaded}

Which errors with:

\begin{verbatim}
error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;

    let y = &mut num;
}
^
\end{verbatim}

A verbose yet helpful error message! As it says, we can't take a mutable
borrow on \texttt{num} because the closure is already borrowing it. If
we let the closure go out of scope, we can:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{num = }\DecValTok{5}\NormalTok{;}
\NormalTok{\{}
    \KeywordTok{let} \NormalTok{plus_num = |x: }\DataTypeTok{i32}\NormalTok{| x + num;}

\NormalTok{\} }\CommentTok{// plus_num goes out of scope, borrow of num ends}

\KeywordTok{let} \NormalTok{y = &}\KeywordTok{mut} \NormalTok{num;}
\end{Highlighting}
\end{Shaded}

If your closure requires it, however, Rust will take ownership and move
the environment instead. This doesn't work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{nums = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\KeywordTok{let} \NormalTok{takes_nums = || nums;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, nums);}
\end{Highlighting}
\end{Shaded}

We get this error:

\begin{verbatim}
note: `nums` moved into closure environment here because it has type
  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable
let takes_nums = || nums;
                 ^~~~~~~
\end{verbatim}

\texttt{Vec\textless{}T\textgreater{}} has ownership over its contents,
and therefore, when we refer to it in our closure, we have to take
ownership of \texttt{nums}. It's the same as if we'd passed
\texttt{nums} to a function that took ownership of it.

\subsubsection{\texorpdfstring{\texttt{move}
closures}{move closures}}\label{move-closures}

We can force our closure to take ownership of its environment with the
\texttt{move} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{owns_num = }\KeywordTok{move} \NormalTok{|x: }\DataTypeTok{i32}\NormalTok{| x + num;}
\end{Highlighting}
\end{Shaded}

Now, even though the keyword is \texttt{move}, the variables follow
normal move semantics. In this case, \texttt{5} implements
\texttt{Copy}, and so \texttt{owns\_num} takes ownership of a copy of
\texttt{num}. So what's the difference?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

\NormalTok{\{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{add_num = |x: }\DataTypeTok{i32}\NormalTok{| num += x;}

    \NormalTok{add_num(}\DecValTok{5}\NormalTok{);}
\NormalTok{\}}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{10}\NormalTok{, num);}
\end{Highlighting}
\end{Shaded}

So in this case, our closure took a mutable reference to \texttt{num},
and then when we called \texttt{add\_num}, it mutated the underlying
value, as we'd expect. We also needed to declare \texttt{add\_num} as
\texttt{mut} too, because we're mutating its environment.

If we change to a \texttt{move} closure, it's different:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \KeywordTok{mut} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

\NormalTok{\{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{add_num = }\KeywordTok{move} \NormalTok{|x: }\DataTypeTok{i32}\NormalTok{| num += x;}

    \NormalTok{add_num(}\DecValTok{5}\NormalTok{);}
\NormalTok{\}}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{5}\NormalTok{, num);}
\end{Highlighting}
\end{Shaded}

We only get \texttt{5}. Rather than taking a mutable borrow out on our
\texttt{num}, we took ownership of a copy.

Another way to think about \texttt{move} closures: they give a closure
its own stack frame. Without \texttt{move}, a closure may be tied to the
stack frame that created it, while a \texttt{move} closure is
self-contained. This means that you cannot generally return a
non-\texttt{move} closure from a function, for example.

But before we talk about taking and returning closures, we should talk
some more about the way that closures are implemented. As a systems
language, Rust gives you tons of control over what your code does, and
closures are no different.

\subsection{Closure implementation}\label{closure-implementation}

Rust's implementation of closures is a bit different than other
languages. They are effectively syntax sugar for traits. You'll want to
make sure to have read the \hyperref[sec--traits]{traits chapter} before
this one, as well as the chapter on \hyperref[sec--trait-objects]{trait
objects}.

Got all that? Good.

The key to understanding how closures work under the hood is something a
bit strange: Using \texttt{()} to call a function, like \texttt{foo()},
is an overloadable operator. From this, everything else clicks into
place. In Rust, we use the trait system to overload operators. Calling
functions is no different. We have three separate traits to overload
with:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{trait} \BuiltInTok{Fn}\NormalTok{<Args> : }\BuiltInTok{FnMut}\NormalTok{<Args> \{}
    \KeywordTok{extern} \StringTok{"rust-call"} \KeywordTok{fn} \NormalTok{call(&}\KeywordTok{self}\NormalTok{, args: Args) -> }\KeywordTok{Self}\NormalTok{::Output;}
\NormalTok{\}}

\KeywordTok{pub} \KeywordTok{trait} \BuiltInTok{FnMut}\NormalTok{<Args> : }\BuiltInTok{FnOnce}\NormalTok{<Args> \{}
    \KeywordTok{extern} \StringTok{"rust-call"} \KeywordTok{fn} \NormalTok{call_mut(&}\KeywordTok{mut} \KeywordTok{self}\NormalTok{, args: Args) -> }\KeywordTok{Self}\NormalTok{::Output;}
\NormalTok{\}}

\KeywordTok{pub} \KeywordTok{trait} \BuiltInTok{FnOnce}\NormalTok{<Args> \{}
    \KeywordTok{type} \NormalTok{Output;}

    \KeywordTok{extern} \StringTok{"rust-call"} \KeywordTok{fn} \NormalTok{call_once(}\KeywordTok{self}\NormalTok{, args: Args) -> }\KeywordTok{Self}\NormalTok{::Output;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You'll notice a few differences between these traits, but a big one is
\texttt{self}: \texttt{Fn} takes \texttt{\&self}, \texttt{FnMut} takes
\texttt{\&mut\ self}, and \texttt{FnOnce} takes \texttt{self}. This
covers all three kinds of \texttt{self} via the usual method call
syntax. But we've split them up into three traits, rather than having a
single one. This gives us a large amount of control over what kind of
closures we can take.

The \texttt{\textbar{}\textbar{}\ \{\}} syntax for closures is sugar for
these three traits. Rust will generate a struct for the environment,
\texttt{impl} the appropriate trait, and then use it.

\subsection{Taking closures as
arguments}\label{taking-closures-as-arguments}

Now that we know that closures are traits, we already know how to accept
and return closures: just like any other trait!

This also means that we can choose static vs dynamic dispatch as well.
First, let's write a function which takes something callable, calls it,
and returns the result:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{call_with_one<F>(some_closure: F) -> }\DataTypeTok{i32}
    \KeywordTok{where} \NormalTok{F : }\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}

    \NormalTok{some_closure(}\DecValTok{1}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{answer = call_with_one(|x| x + }\DecValTok{2}\NormalTok{);}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{3}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

We pass our closure, \texttt{\textbar{}x\textbar{}\ x\ +\ 2}, to
\texttt{call\_with\_one}. It just does what it suggests: it calls the
closure, giving it \texttt{1} as an argument.

Let's examine the signature of \texttt{call\_with\_one} in more depth:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{call_with_one<F>(some_closure: F) -> }\DataTypeTok{i32}
\end{Highlighting}
\end{Shaded}

We take one parameter, and it has the type \texttt{F}. We also return a
\texttt{i32}. This part isn't interesting. The next part is:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{where} \NormalTok{F : }\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

Because \texttt{Fn} is a trait, we can bound our generic with it. In
this case, our closure takes a \texttt{i32} as an argument and returns
an \texttt{i32}, and so the generic bound we use is
\texttt{Fn(i32)\ -\textgreater{}\ i32}.

There's one other key point here: because we're bounding a generic with
a trait, this will get monomorphized, and therefore, we'll be doing
static dispatch into the closure. That's pretty neat. In many languages,
closures are inherently heap allocated, and will always involve dynamic
dispatch. In Rust, we can stack allocate our closure environment, and
statically dispatch the call. This happens quite often with iterators
and their adapters, which often take closures as arguments.

Of course, if we want dynamic dispatch, we can get that too. A trait
object handles this case, as usual:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{call_with_one(some_closure: &}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{some_closure(}\DecValTok{1}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{answer = call_with_one(&|x| x + }\DecValTok{2}\NormalTok{);}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{3}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

Now we take a trait object, a \texttt{\&Fn}. And we have to make a
reference to our closure when we pass it to \texttt{call\_with\_one}, so
we use \texttt{\&\textbar{}\textbar{}}.

\subsection{Function pointers and
closures}\label{function-pointers-and-closures}

A function pointer is kind of like a closure that has no environment. As
such, you can pass a function pointer to any function expecting a
closure argument, and it will work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{call_with_one(some_closure: &}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{some_closure(}\DecValTok{1}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{add_one(i: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{i + }\DecValTok{1}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{f = add_one;}

\KeywordTok{let} \NormalTok{answer = call_with_one(&f);}

\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{2}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

In this example, we don't strictly need the intermediate variable
\texttt{f}, the name of the function works just fine too:

\begin{verbatim}
let answer = call_with_one(&add_one);
\end{verbatim}

\subsection{Returning closures}\label{returning-closures}

It's very common for functional-style code to return closures in various
situations. If you try to return a closure, you may run into an error.
At first, it may seem strange, but we'll figure it out. Here's how you'd
probably try to return a closure from a function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{factory() -> (}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

    \NormalTok{|x| x + num}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{f = factory();}

\KeywordTok{let} \NormalTok{answer = f(}\DecValTok{1}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{6}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

This gives us these long, related errors:

\begin{verbatim}
error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -> i32` [E0277]
fn factory() -> (Fn(i32) -> i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time
fn factory() -> (Fn(i32) -> i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(
‚Ü≥ i32) -> i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time
let f = factory();
    ^
\end{verbatim}

In order to return something from a function, Rust needs to know what
size the return type is. But since \texttt{Fn} is a trait, it could be
various things of various sizes: many different types can implement
\texttt{Fn}. An easy way to give something a size is to take a reference
to it, as references have a known size. So we'd write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{factory() -> &(}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

    \NormalTok{|x| x + num}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{f = factory();}

\KeywordTok{let} \NormalTok{answer = f(}\DecValTok{1}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{6}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

But we get another error:

\begin{verbatim}
error: missing lifetime specifier [E0106]
fn factory() -> &(Fn(i32) -> i32) {
                ^~~~~~~~~~~~~~~~~
\end{verbatim}

Right. Because we have a reference, we need to give it a lifetime. But
our \texttt{factory()} function takes no arguments, so elision doesn't
kick in here. What lifetime can we choose?
\texttt{\textquotesingle{}static}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{factory() -> &}\OtherTok{'static} \NormalTok{(}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{) \{}
    \KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

    \NormalTok{|x| x + num}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{f = factory();}

\KeywordTok{let} \NormalTok{answer = f(}\DecValTok{1}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{6}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

But we get another error:

\begin{verbatim}
error: mismatched types:
 expected `&'static core::ops::Fn(i32) -> i32`,
    found `[closure <anon>:7:9: 7:20]`
(expected &-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~
\end{verbatim}

This error is letting us know that we don't have a
\texttt{\&\textquotesingle{}static\ Fn(i32)\ -\textgreater{}\ i32}, we
have a \texttt{{[}closure\ \textless{}anon\textgreater{}:7:9:\ 7:20{]}}.
Wait, what?

Because each closure generates its own environment \texttt{struct} and
implementation of \texttt{Fn} and friends, these types are anonymous.
They exist just solely for this closure. So Rust shows them as
\texttt{closure\ \textless{}anon\textgreater{}}, rather than some
autogenerated name.

But why doesn't our closure implement
\texttt{\&\textquotesingle{}static\ Fn}? Well, as we discussed before,
closures borrow their environment. And in this case, our environment is
based on a stack-allocated \texttt{5}, the \texttt{num} variable
binding. So the borrow has a lifetime of the stack frame. So if we
returned this closure, the function call would be over, the stack frame
would go away, and our closure is capturing an environment of garbage
memory!

So what to do? This \emph{almost} works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{factory() -> }\DataTypeTok{Box}\NormalTok{<}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{> \{}
    \KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

    \DataTypeTok{Box}\NormalTok{::new(|x| x + num)}
\NormalTok{\}}
\KeywordTok{let} \NormalTok{f = factory();}

\KeywordTok{let} \NormalTok{answer = f(}\DecValTok{1}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{6}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

We use a trait object, by \texttt{Box}ing up the \texttt{Fn}. There's
just one last problem:

\begin{verbatim}
error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
\end{verbatim}

We still have a reference to the parent stack frame. With one last fix,
we can make this work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{factory() -> }\DataTypeTok{Box}\NormalTok{<}\BuiltInTok{Fn}\NormalTok{(}\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32}\NormalTok{> \{}
    \KeywordTok{let} \NormalTok{num = }\DecValTok{5}\NormalTok{;}

    \DataTypeTok{Box}\NormalTok{::new(}\KeywordTok{move} \NormalTok{|x| x + num)}
\NormalTok{\}}
\KeywordTok{let} \NormalTok{f = factory();}

\KeywordTok{let} \NormalTok{answer = f(}\DecValTok{1}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{6}\NormalTok{, answer);}
\end{Highlighting}
\end{Shaded}

By making the inner closure a \texttt{move\ Fn}, we create a new stack
frame for our closure. By \texttt{Box}ing it up, we've given it a known
size, and allowing it to escape our stack frame.

\section{Universal Function Call Syntax}\label{sec--ufcs}

Sometimes, functions can have the same names. Consider this code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{f(&}\KeywordTok{self}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{trait} \NormalTok{Bar \{}
    \KeywordTok{fn} \NormalTok{f(&}\KeywordTok{self}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Baz;}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{Baz \{}
    \KeywordTok{fn} \NormalTok{f(&}\KeywordTok{self}\NormalTok{) \{ }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Baz‚Äôs impl of Foo"}\NormalTok{); \}}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Bar }\KeywordTok{for} \NormalTok{Baz \{}
    \KeywordTok{fn} \NormalTok{f(&}\KeywordTok{self}\NormalTok{) \{ }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Baz‚Äôs impl of Bar"}\NormalTok{); \}}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{b = Baz;}
\end{Highlighting}
\end{Shaded}

If we were to try to call \texttt{b.f()}, we'd get an error:

\begin{verbatim}
error: multiple applicable methods in scope [E0034]
b.f();
  ^~~
note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
`main::Baz`
    fn f(&self) { println!("Baz‚Äôs impl of Foo"); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
`main::Baz`
    fn f(&self) { println!("Baz‚Äôs impl of Bar"); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{verbatim}

We need a way to disambiguate which method we need. This feature is
called `universal function call syntax', and it looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Foo::f(&b);}
\NormalTok{Bar::f(&b);}
\end{Highlighting}
\end{Shaded}

Let's break it down.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Foo::}
\NormalTok{Bar::}
\end{Highlighting}
\end{Shaded}

These halves of the invocation are the types of the two traits:
\texttt{Foo} and \texttt{Bar}. This is what ends up actually doing the
disambiguation between the two: Rust calls the one from the trait name
you use.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f(&b)}
\end{Highlighting}
\end{Shaded}

When we call a method like \texttt{b.f()} using
\hyperref[sec--method-syntax]{method syntax}, Rust will automatically
borrow \texttt{b} if \texttt{f()} takes \texttt{\&self}. In this case,
Rust will not, and so we need to pass an explicit \texttt{\&b}.

\subsection{Angle-bracket Form}\label{angle-bracket-form}

The form of UFCS we just talked about:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Trait::method(args);}
\end{Highlighting}
\end{Shaded}

Is a short-hand. There's an expanded form of this that's needed in some
situations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{<Type }\KeywordTok{as} \NormalTok{Trait>::method(args);}
\end{Highlighting}
\end{Shaded}

The \texttt{\textless{}\textgreater{}::} syntax is a means of providing
a type hint. The type goes inside the
\texttt{\textless{}\textgreater{}}s. In this case, the type is
\texttt{Type\ as\ Trait}, indicating that we want \texttt{Trait}'s
version of \texttt{method} to be called here. The \texttt{as\ Trait}
part is optional if it's not ambiguous. Same with the angle brackets,
hence the shorter form.

Here's an example of using the longer form.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{clone(&}\KeywordTok{self}\NormalTok{);}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Clone}\AttributeTok{)]}
\KeywordTok{struct} \NormalTok{Bar;}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{Bar \{}
    \KeywordTok{fn} \NormalTok{clone(&}\KeywordTok{self}\NormalTok{) \{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Making a clone of Bar"}\NormalTok{);}

        \NormalTok{<Bar }\KeywordTok{as} \BuiltInTok{Clone}\NormalTok{>::clone(}\KeywordTok{self}\NormalTok{);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will call the \texttt{Clone} trait's \texttt{clone()} method,
rather than \texttt{Foo}'s.

\section{Crates and Modules}\label{sec--crates-and-modules}

When a project starts getting large, it's considered good software
engineering practice to split it up into a bunch of smaller pieces, and
then fit them together. It's also important to have a well-defined
interface, so that some of your functionality is private, and some is
public. To facilitate these kinds of things, Rust has a module system.

\subsection{Basic terminology: Crates and
Modules}\label{basic-terminology-crates-and-modules}

Rust has two distinct terms that relate to the module system: `crate'
and `module'. A crate is synonymous with a `library' or `package' in
other languages. Hence ``Cargo'' as the name of Rust's package
management tool: you ship your crates to others with Cargo. Crates can
produce an executable or a library, depending on the project.

Each crate has an implicit \emph{root module} that contains the code for
that crate. You can then define a tree of sub-modules under that root
module. Modules allow you to partition your code within the crate
itself.

As an example, let's make a \emph{phrases} crate, which will give us
various phrases in different languages. To keep things simple, we'll
stick to `greetings' and `farewells' as two kinds of phrases, and use
English and Japanese (Êó•Êú¨Ë™û) as two languages for those phrases to be
in. We'll use this module layout:

\begin{verbatim}
                                    +-----------+
                                +---| greetings |
                                |   +-----------+
                  +---------+   |
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |
                                |   +-----------+
                                +---| farewells |
                                    +-----------+
\end{verbatim}

In this example, \texttt{phrases} is the name of our crate. All of the
rest are modules. You can see that they form a tree, branching out from
the crate \emph{root}, which is the root of the tree: \texttt{phrases}
itself.

Now that we have a plan, let's define these modules in code. To start,
generate a new crate with Cargo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{new phrases}
\NormalTok{$ }\KeywordTok{cd} \NormalTok{phrases}
\end{Highlighting}
\end{Shaded}

If you remember, this generates a simple project for us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{tree} \NormalTok{.}
\KeywordTok{.}
\NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{Cargo.toml}
\NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{src}
    \NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{lib.rs}

\KeywordTok{1} \NormalTok{directory, 2 files}
\end{Highlighting}
\end{Shaded}

\texttt{src/lib.rs} is our crate root, corresponding to the
\texttt{phrases} in our diagram above.

\subsection{Defining Modules}\label{defining-modules}

To define each of our modules, we use the \texttt{mod} keyword. Let's
make our \texttt{src/lib.rs} look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{english \{}
    \KeywordTok{mod} \NormalTok{greetings \{}
    \NormalTok{\}}

    \KeywordTok{mod} \NormalTok{farewells \{}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{mod} \NormalTok{japanese \{}
    \KeywordTok{mod} \NormalTok{greetings \{}
    \NormalTok{\}}

    \KeywordTok{mod} \NormalTok{farewells \{}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After the \texttt{mod} keyword, you give the name of the module. Module
names follow the conventions for other Rust identifiers:
\texttt{lower\_snake\_case}. The contents of each module are within
curly braces (\texttt{\{\}}).

Within a given \texttt{mod}, you can declare sub-\texttt{mod}s. We can
refer to sub-modules with double-colon (\texttt{::}) notation: our four
nested modules are \texttt{english::greetings},
\texttt{english::farewells}, \texttt{japanese::greetings}, and
\texttt{japanese::farewells}. Because these sub-modules are namespaced
under their parent module, the names don't conflict:
\texttt{english::greetings} and \texttt{japanese::greetings} are
distinct, even though their names are both \texttt{greetings}.

Because this crate does not have a \texttt{main()} function, and is
called \texttt{lib.rs}, Cargo will build this crate as a library:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{phrases v0.0.1 (file:///home/you/projects/phrases)}
\NormalTok{$ }\KeywordTok{ls} \NormalTok{target/debug}
\KeywordTok{build}  \NormalTok{deps  examples  libphrases-a7448e02a0468eaa.rlib  native}
\end{Highlighting}
\end{Shaded}

\texttt{libphrases-hash.rlib} is the compiled crate. Before we see how
to use this crate from another crate, let's break it up into multiple
files.

\subsection{Multiple file crates}\label{multiple-file-crates}

If each crate were just one file, these files would get very large. It's
often easier to split up crates into multiple files, and Rust supports
this in two ways.

Instead of declaring a module like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{english \{}
    \CommentTok{// contents of our module go here}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can instead declare our module like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{english;}
\end{Highlighting}
\end{Shaded}

If we do that, Rust will expect to find either a \texttt{english.rs}
file, or a \texttt{english/mod.rs} file with the contents of our module.

Note that in these files, you don't need to re-declare the module:
that's already been done with the initial \texttt{mod} declaration.

Using these two techniques, we can break up our crate into two
directories and seven files:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{tree} \NormalTok{.}
\KeywordTok{.}
\NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{Cargo.lock}
\NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{Cargo.toml}
\NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{src}
\NormalTok{‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{english}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{farewells.rs}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{greetings.rs}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ }\KeywordTok{mod.rs}
\NormalTok{‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{japanese}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{farewells.rs}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ }\KeywordTok{greetings.rs}
\NormalTok{‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ }\KeywordTok{mod.rs}
\NormalTok{‚îÇ¬†¬† ‚îî‚îÄ‚îÄ }\KeywordTok{lib.rs}
\NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{target}
    \NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{debug}
        \NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{build}
        \NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{deps}
        \NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{examples}
        \NormalTok{‚îú‚îÄ‚îÄ }\KeywordTok{libphrases-a7448e02a0468eaa.rlib}
        \NormalTok{‚îî‚îÄ‚îÄ }\KeywordTok{native}
\end{Highlighting}
\end{Shaded}

\texttt{src/lib.rs} is our crate root, and looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{english;}
\KeywordTok{mod} \NormalTok{japanese;}
\end{Highlighting}
\end{Shaded}

These two declarations tell Rust to look for either
\texttt{src/english.rs} and \texttt{src/japanese.rs}, or
\texttt{src/english/mod.rs} and \texttt{src/japanese/mod.rs}, depending
on our preference. In this case, because our modules have sub-modules,
we've chosen the second. Both \texttt{src/english/mod.rs} and
\texttt{src/japanese/mod.rs} look like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mod} \NormalTok{greetings;}
\KeywordTok{mod} \NormalTok{farewells;}
\end{Highlighting}
\end{Shaded}

Again, these declarations tell Rust to look for either
\texttt{src/english/greetings.rs} and \texttt{src/japanese/greetings.rs}
or \texttt{src/english/farewells/mod.rs} and
\texttt{src/japanese/farewells/mod.rs}. Because these sub-modules don't
have their own sub-modules, we've chosen to make them
\texttt{src/english/greetings.rs} and
\texttt{src/japanese/farewells.rs}. Whew!

The contents of \texttt{src/english/greetings.rs} and
\texttt{src/japanese/farewells.rs} are both empty at the moment. Let's
add some functions.

Put this in \texttt{src/english/greetings.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{hello() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"Hello!"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Put this in \texttt{src/english/farewells.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{goodbye() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"Goodbye."}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Put this in \texttt{src/japanese/greetings.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{hello() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"„Åì„Çì„Å´„Å°„ÅØ"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Of course, you can copy and paste this from this web page, or just type
something else. It's not important that you actually put `konnichiwa' to
learn about the module system.

Put this in \texttt{src/japanese/farewells.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{goodbye() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"„Åï„Çà„ÅÜ„Å™„Çâ"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(This is `Say≈çnara', if you're curious.)

Now that we have some functionality in our crate, let's try to use it
from another crate.

\subsection{Importing External Crates}\label{importing-external-crates}

We have a library crate. Let's make an executable crate that imports and
uses our library.

Make a \texttt{src/main.rs} and put this in it (it won't quite compile
yet):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, phrases::english::greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, phrases::english::farewells::goodbye());}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in Japanese: \{\}"}\NormalTok{, phrases::japanese::greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in Japanese: \{\}"}\NormalTok{, phrases::japanese::farewells::goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{extern\ crate} declaration tells Rust that we need to
compile and link to the \texttt{phrases} crate. We can then use
\texttt{phrases}' modules in this one. As we mentioned earlier, you can
use double colons to refer to sub-modules and the functions inside of
them.

(Note: when importing a crate that has dashes in its name ``like-this'',
which is not a valid Rust identifier, it will be converted by changing
the dashes to underscores, so you would write
\texttt{extern\ crate\ like\_this;}.)

Also, Cargo assumes that \texttt{src/main.rs} is the crate root of a
binary crate, rather than a library crate. Our package now has two
crates: \texttt{src/lib.rs} and \texttt{src/main.rs}. This pattern is
quite common for executable crates: most functionality is in a library
crate, and the executable crate uses that library. This way, other
programs can also use the library crate, and it's also a nice separation
of concerns.

This doesn't quite work yet, though. We get four errors that look
similar to this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{build}
   \KeywordTok{Compiling} \NormalTok{phrases v0.0.1 (file:///home/you/projects/phrases)}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{4}\NormalTok{:38: 4:72 error: function }\KeywordTok{`hello`} \NormalTok{is private}
\KeywordTok{src}\NormalTok{/main.rs:}\KeywordTok{4}     \NormalTok{println!(}\StringTok{"Hello in English: \{\}"}\NormalTok{, phrases::english::greetings::hello(}
\NormalTok{‚Ü≥ ));}
                                                   \NormalTok{^}\KeywordTok{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
\KeywordTok{note}\NormalTok{: in expansion of format_args!}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:2:25: 2:58 note: expansion site}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:1:1: 2:62 note: in expansion of print!}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:3:1: 3:54 note: expansion site}
\KeywordTok{<std} \NormalTok{macros}\KeywordTok{>}\NormalTok{:1:1: 3:58 note: in expansion of println!}
\KeywordTok{phrases/src}\NormalTok{/main.rs:}\KeywordTok{4}\NormalTok{:5: 4:76 note: expansion site}
\end{Highlighting}
\end{Shaded}

By default, everything is private in Rust. Let's talk about this in some
more depth.

\subsection{Exporting a Public
Interface}\label{exporting-a-public-interface}

Rust allows you to precisely control which aspects of your interface are
public, and so private is the default. To make things public, you use
the \texttt{pub} keyword. Let's focus on the \texttt{english} module
first, so let's reduce our \texttt{src/main.rs} to just this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, phrases::english::greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, phrases::english::farewells::goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In our \texttt{src/lib.rs}, let's add \texttt{pub} to the
\texttt{english} module declaration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{mod} \NormalTok{english;}
\KeywordTok{mod} \NormalTok{japanese;}
\end{Highlighting}
\end{Shaded}

And in our \texttt{src/english/mod.rs}, let's make both \texttt{pub}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{mod} \NormalTok{greetings;}
\KeywordTok{pub} \KeywordTok{mod} \NormalTok{farewells;}
\end{Highlighting}
\end{Shaded}

In our \texttt{src/english/greetings.rs}, let's add \texttt{pub} to our
\texttt{fn} declaration:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{hello() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"Hello!"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And also in \texttt{src/english/farewells.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{goodbye() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"Goodbye."}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, our crate compiles, albeit with warnings about not using the
\texttt{japanese} functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{phrases v0.0.1 (file:///home/you/projects/phrases)}
\KeywordTok{src/japanese}\NormalTok{/greetings.rs:}\KeywordTok{1}\NormalTok{:1: 3:2 warning: function is never used: }\KeywordTok{`hello`}\NormalTok{, }\CommentTok{#[warn(de}
\NormalTok{‚Ü≥ }\KeywordTok{ad_code}\NormalTok{)] }\KeywordTok{on} \NormalTok{by default}
\KeywordTok{src/japanese}\NormalTok{/greetings.rs:}\KeywordTok{1} \NormalTok{fn hello() }\KeywordTok{->} \NormalTok{String \{}
\KeywordTok{src/japanese}\NormalTok{/greetings.rs:}\KeywordTok{2}     \StringTok{"„Åì„Çì„Å´„Å°„ÅØ"}\NormalTok{.to_string()}
\KeywordTok{src/japanese}\NormalTok{/greetings.rs:}\KeywordTok{3} \NormalTok{\}}
\KeywordTok{src/japanese}\NormalTok{/farewells.rs:}\KeywordTok{1}\NormalTok{:1: 3:2 warning: function is never used: }\KeywordTok{`goodbye`}\NormalTok{, }\CommentTok{#[warn(}
\NormalTok{‚Ü≥ }\KeywordTok{dead_code}\NormalTok{)] }\KeywordTok{on} \NormalTok{by default}
\KeywordTok{src/japanese}\NormalTok{/farewells.rs:}\KeywordTok{1} \NormalTok{fn goodbye() }\KeywordTok{->} \NormalTok{String \{}
\KeywordTok{src/japanese}\NormalTok{/farewells.rs:}\KeywordTok{2}     \StringTok{"„Åï„Çà„ÅÜ„Å™„Çâ"}\NormalTok{.to_string()}
\KeywordTok{src/japanese}\NormalTok{/farewells.rs:}\KeywordTok{3} \NormalTok{\}}
     \KeywordTok{Running} \KeywordTok{`target/debug/phrases`}
\KeywordTok{Hello} \NormalTok{in English: Hello!}
\KeywordTok{Goodbye} \NormalTok{in English: Goodbye.}
\end{Highlighting}
\end{Shaded}

\texttt{pub} also applies to \texttt{struct}s and their member fields.
In keeping with Rust's tendency toward safety, simply making a
\texttt{struct} public won't automatically make its members public: you
must mark the fields individually with \texttt{pub}.

Now that our functions are public, we can use them. Great! However,
typing out \texttt{phrases::english::greetings::hello()} is very long
and repetitive. Rust has another keyword for importing names into the
current scope, so that you can refer to them with shorter names. Let's
talk about \texttt{use}.

\subsection{\texorpdfstring{Importing Modules with
\texttt{use}}{Importing Modules with use}}\label{importing-modules-with-use}

Rust has a \texttt{use} keyword, which allows us to import names into
our local scope. Let's change our \texttt{src/main.rs} to look like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{use} \NormalTok{phrases::english::greetings;}
\KeywordTok{use} \NormalTok{phrases::english::farewells;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, farewells::goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The two \texttt{use} lines import each module into the local scope, so
we can refer to the functions by a much shorter name. By convention,
when importing functions, it's considered best practice to import the
module, rather than the function directly. In other words, you
\emph{can} do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{use} \NormalTok{phrases::english::greetings::hello;}
\KeywordTok{use} \NormalTok{phrases::english::farewells::goodbye;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

But it is not idiomatic. This is significantly more likely to introduce
a naming conflict. In our short program, it's not a big deal, but as it
grows, it becomes a problem. If we have conflicting names, Rust will
give a compilation error. For example, if we made the \texttt{japanese}
functions public, and tried to do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{use} \NormalTok{phrases::english::greetings::hello;}
\KeywordTok{use} \NormalTok{phrases::japanese::greetings::hello;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in Japanese: \{\}"}\NormalTok{, hello());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Rust will give us a compile-time error:

\begin{verbatim}
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this m
‚Ü≥ odule [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
\end{verbatim}

If we're importing multiple names from the same module, we don't have to
type it out twice. Instead of this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{phrases::english::greetings;}
\KeywordTok{use} \NormalTok{phrases::english::farewells;}
\end{Highlighting}
\end{Shaded}

We can use this shortcut:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{phrases::english::\{greetings, farewells\};}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Re-exporting with
\texttt{pub\ use}}{Re-exporting with pub use}}\label{re-exporting-with-pub-use}

You don't just use \texttt{use} to shorten identifiers. You can also use
it inside of your crate to re-export a function inside another module.
This allows you to present an external interface that may not directly
map to your internal code organization.

Let's look at an example. Modify your \texttt{src/main.rs} to read like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases;}

\KeywordTok{use} \NormalTok{phrases::english::\{greetings,farewells\};}
\KeywordTok{use} \NormalTok{phrases::japanese;}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English: \{\}"}\NormalTok{, greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, farewells::goodbye());}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in Japanese: \{\}"}\NormalTok{, japanese::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in Japanese: \{\}"}\NormalTok{, japanese::goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then, modify your \texttt{src/lib.rs} to make the \texttt{japanese} mod
public:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{mod} \NormalTok{english;}
\KeywordTok{pub} \KeywordTok{mod} \NormalTok{japanese;}
\end{Highlighting}
\end{Shaded}

Next, make the two functions public, first in
\texttt{src/japanese/greetings.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{hello() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"„Åì„Çì„Å´„Å°„ÅØ"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And then in \texttt{src/japanese/farewells.rs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{goodbye() -> }\DataTypeTok{String} \NormalTok{\{}
    \StringTok{"„Åï„Çà„ÅÜ„Å™„Çâ"}\NormalTok{.to_string()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Finally, modify your \texttt{src/japanese/mod.rs} to read like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{use} \KeywordTok{self}\NormalTok{::greetings::hello;}
\KeywordTok{pub} \KeywordTok{use} \KeywordTok{self}\NormalTok{::farewells::goodbye;}

\KeywordTok{mod} \NormalTok{greetings;}
\KeywordTok{mod} \NormalTok{farewells;}
\end{Highlighting}
\end{Shaded}

The \texttt{pub\ use} declaration brings the function into scope at this
part of our module hierarchy. Because we've \texttt{pub\ use}d this
inside of our \texttt{japanese} module, we now have a
\texttt{phrases::japanese::hello()} function and a
\texttt{phrases::japanese::goodbye()} function, even though the code for
them lives in \texttt{phrases::japanese::greetings::hello()} and
\texttt{phrases::japanese::farewells::goodbye()}. Our internal
organization doesn't define our external interface.

Here we have a \texttt{pub\ use} for each function we want to bring into
the \texttt{japanese} scope. We could alternatively use the wildcard
syntax to include everything from \texttt{greetings} into the current
scope: \texttt{pub\ use\ self::greetings::*}.

What about the \texttt{self}? Well, by default, \texttt{use}
declarations are absolute paths, starting from your crate root.
\texttt{self} makes that path relative to your current place in the
hierarchy instead. There's one more special form of \texttt{use}: you
can \texttt{use\ super::} to reach one level up the tree from your
current location. Some people like to think of \texttt{self} as
\texttt{.} and \texttt{super} as \texttt{..}, from many shells' display
for the current directory and the parent directory.

Outside of \texttt{use}, paths are relative: \texttt{foo::bar()} refers
to a function inside of \texttt{foo} relative to where we are. If that's
prefixed with \texttt{::}, as in \texttt{::foo::bar()}, it refers to a
different \texttt{foo}, an absolute path from your crate root.

This will build and run:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{run}
   \KeywordTok{Compiling} \NormalTok{phrases v0.0.1 (file:///home/you/projects/phrases)}
     \KeywordTok{Running} \KeywordTok{`target/debug/phrases`}
\KeywordTok{Hello} \NormalTok{in English: Hello!}
\KeywordTok{Goodbye} \NormalTok{in English: Goodbye.}
\KeywordTok{Hello} \NormalTok{in Japanese: „Åì„Çì„Å´„Å°„ÅØ}
\KeywordTok{Goodbye} \NormalTok{in Japanese: „Åï„Çà„ÅÜ„Å™„Çâ}
\end{Highlighting}
\end{Shaded}

\subsubsection{Complex imports}\label{complex-imports}

Rust offers several advanced options that can add compactness and
convenience to your \texttt{extern\ crate} and \texttt{use} statements.
Here is an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{phrases }\KeywordTok{as} \NormalTok{sayings;}

\KeywordTok{use} \NormalTok{sayings::japanese::greetings }\KeywordTok{as} \NormalTok{ja_greetings;}
\KeywordTok{use} \NormalTok{sayings::japanese::farewells::*;}
\KeywordTok{use} \NormalTok{sayings::english::\{}\KeywordTok{self}\NormalTok{, greetings }\KeywordTok{as} \NormalTok{en_greetings, farewells }\KeywordTok{as} \NormalTok{en_farewells\};}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Hello in English; \{\}"}\NormalTok{, en_greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"And in Japanese: \{\}"}\NormalTok{, ja_greetings::hello());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Goodbye in English: \{\}"}\NormalTok{, english::farewells::goodbye());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Again: \{\}"}\NormalTok{, en_farewells::goodbye());}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"And in Japanese: \{\}"}\NormalTok{, goodbye());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

What's going on here?

First, both \texttt{extern\ crate} and \texttt{use} allow renaming the
thing that is being imported. So the crate is still called ``phrases'',
but here we will refer to it as ``sayings''. Similarly, the first
\texttt{use} statement pulls in the \texttt{japanese::farewells} module
from the crate, but makes it available as \texttt{jp\_farewells} as
opposed to simply \texttt{farewells}. This can help to avoid ambiguity
when importing similarly-named items from different places.

The second \texttt{use} statement uses a star glob to bring in
\emph{all} symbols from the \texttt{sayings::japanese::farewells}
module. As you can see we can later refer to the Japanese
\texttt{goodbye} function with no module qualifiers. This kind of glob
should be used sparingly.

The third \texttt{use} statement bears more explanation. It's using
``brace expansion'' globbing to compress three \texttt{use} statements
into one (this sort of syntax may be familiar if you've written Linux
shell scripts before). The uncompressed form of this statement would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{sayings::english;}
\KeywordTok{use} \NormalTok{sayings::english::greetings }\KeywordTok{as} \NormalTok{en_greetings;}
\KeywordTok{use} \NormalTok{sayings::english::farewells }\KeywordTok{as} \NormalTok{en_farewells;}
\end{Highlighting}
\end{Shaded}

As you can see, the curly brackets compress \texttt{use} statements for
several items under the same path, and in this context \texttt{self}
just refers back to that path. Note: The curly brackets cannot be nested
or mixed with star globbing.

\section{\texorpdfstring{\texttt{const} and
\texttt{static}}{const and static}}\label{sec--const-and-static}

Rust has a way of defining constants with the \texttt{const} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \NormalTok{N: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Unlike \hyperref[sec--variable-bindings]{\texttt{let}} bindings, you
must annotate the type of a \texttt{const}.

Constants live for the entire lifetime of a program. More specifically,
constants in Rust have no fixed address in memory. This is because
they're effectively inlined to each place that they're used. References
to the same constant are not necessarily guaranteed to refer to the same
memory address for this reason.

\subsection{\texorpdfstring{\texttt{static}}{static}}\label{static-1}

Rust provides a `global variable' sort of facility in static items.
They're similar to constants, but static items aren't inlined upon use.
This means that there is only one instance for each value, and it's at a
fixed location in memory.

Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{static} \NormalTok{N: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Unlike \hyperref[sec--variable-bindings]{\texttt{let}} bindings, you
must annotate the type of a \texttt{static}.

Statics live for the entire lifetime of a program, and therefore any
reference stored in a constant has a
\hyperref[sec--lifetimes]{\texttt{\textquotesingle{}static} lifetime}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{static} \NormalTok{NAME: &}\OtherTok{'static} \DataTypeTok{str} \NormalTok{= }\StringTok{"Steve"}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Mutability}\label{mutability}

You can introduce mutability with the \texttt{mut} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{static} \KeywordTok{mut} \NormalTok{N: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

Because this is mutable, one thread could be updating \texttt{N} while
another is reading it, causing memory unsafety. As such both accessing
and mutating a \texttt{static\ mut} is
\hyperref[sec--unsafe]{\texttt{unsafe}}, and so must be done in an
\texttt{unsafe} block:

\begin{Shaded}
\begin{Highlighting}[]

\KeywordTok{unsafe} \NormalTok{\{}
    \NormalTok{N += }\DecValTok{1}\NormalTok{;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"N: \{\}"}\NormalTok{, N);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Furthermore, any type stored in a \texttt{static} must be \texttt{Sync},
and may not have a \hyperref[sec--drop]{\texttt{Drop}} implementation.

\subsection{Initializing}\label{initializing}

Both \texttt{const} and \texttt{static} have requirements for giving
them a value. They may only be given a value that's a constant
expression. In other words, you cannot use the result of a function call
or anything similarly complex or at runtime.

\subsection{Which construct should I
use?}\label{which-construct-should-i-use}

Almost always, if you can choose between the two, choose \texttt{const}.
It's pretty rare that you actually want a memory location associated
with your constant, and using a const allows for optimizations like
constant propagation not only in your crate but downstream crates.

\section{Attributes}\label{sec--attributes}

Declarations can be annotated with `attributes' in Rust. They look like
this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\end{Highlighting}
\end{Shaded}

or like this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{test}\AttributeTok{]}
\end{Highlighting}
\end{Shaded}

The difference between the two is the \texttt{!}, which changes what the
attribute applies to:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{foo}\AttributeTok{]}
\KeywordTok{struct} \NormalTok{Foo;}

\KeywordTok{mod} \NormalTok{bar \{}
    \AttributeTok{#![}\NormalTok{bar}\AttributeTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{\#{[}foo{]}} attribute applies to the next item, which is
the \texttt{struct} declaration. The \texttt{\#!{[}bar{]}} attribute
applies to the item enclosing it, which is the \texttt{mod} declaration.
Otherwise, they're the same. Both change the meaning of the item they're
attached to somehow.

For example, consider a function like this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{check() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1} \NormalTok{+ }\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It is marked with \texttt{\#{[}test{]}}. This means it's special: when
you run \hyperref[sec--testing]{tests}, this function will execute. When
you compile as usual, it won't even be included. This function is now a
test function.

Attributes may also have additional data:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{inline}\AttributeTok{(}\NormalTok{always}\AttributeTok{)]}
\KeywordTok{fn} \NormalTok{super_fast_fn() \{}
\end{Highlighting}
\end{Shaded}

Or even keys and values:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{target_os }\AttributeTok{=} \StringTok{"macos"}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{macos_only \{}
\end{Highlighting}
\end{Shaded}

Rust attributes are used for a number of different things. There is a
full list of attributes
\href{http://doc.rust-lang.org/reference.html\#attributes}{in the
reference}. Currently, you are not allowed to create your own
attributes, the Rust compiler defines them.

\section{\texorpdfstring{\texttt{type}
aliases}{type aliases}}\label{sec--type-aliases}

The \texttt{type} keyword lets you declare an alias of another type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \NormalTok{Name = }\DataTypeTok{String}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

You can then use this type as if it were a real type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \NormalTok{Name = }\DataTypeTok{String}\NormalTok{;}

\KeywordTok{let} \NormalTok{x: Name = }\StringTok{"Hello"}\NormalTok{.to_string();}
\end{Highlighting}
\end{Shaded}

Note, however, that this is an \emph{alias}, not a new type entirely. In
other words, because Rust is strongly typed, you'd expect a comparison
between two different types to fail:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y: }\DataTypeTok{i64} \NormalTok{= }\DecValTok{5}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == y \{}
   \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

this gives

\begin{verbatim}
error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
\end{verbatim}

But, if we had an alias:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \NormalTok{Num = }\DataTypeTok{i32}\NormalTok{;}

\KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{y: Num = }\DecValTok{5}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == y \{}
   \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This compiles without error. Values of a \texttt{Num} type are the same
as a value of type \texttt{i32}, in every way.

You can also use type aliases with generics:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::result;}

\KeywordTok{enum} \NormalTok{ConcreteError \{}
    \NormalTok{Foo,}
    \NormalTok{Bar,}
\NormalTok{\}}

\KeywordTok{type} \NormalTok{Result<T> = result::}\DataTypeTok{Result}\NormalTok{<T, ConcreteError>;}
\end{Highlighting}
\end{Shaded}

This creates a specialized version of the \texttt{Result} type, which
always has a \texttt{ConcreteError} for the \texttt{E} part of
\texttt{Result\textless{}T,\ E\textgreater{}}. This is commonly used in
the standard library to create custom errors for each subsection. For
example,
\href{http://doc.rust-lang.org/std/io/type.Result.html}{io::Result}.

\section{Casting between types}\label{sec--casting-between-types}

Rust, with its focus on safety, provides two different ways of casting
different types between each other. The first, \texttt{as}, is for safe
casts. In contrast, \texttt{transmute} allows for arbitrary casting, and
is one of the most dangerous features of Rust!

\subsection{\texorpdfstring{\texttt{as}}{as}}\label{as}

The \texttt{as} keyword does basic casting:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}

\KeywordTok{let} \NormalTok{y = x }\KeywordTok{as} \DataTypeTok{i64}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

It only allows certain kinds of casting, however:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{a = [}\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{];}

\KeywordTok{let} \NormalTok{b = a }\KeywordTok{as} \DataTypeTok{u32}\NormalTok{; }\CommentTok{// four eights makes 32}
\end{Highlighting}
\end{Shaded}

This errors with:

\begin{verbatim}
error: non-scalar cast: `[u8; 4]` as `u32`
let b = a as u32; // four eights makes 32
        ^~~~~~~~
\end{verbatim}

It's a `non-scalar cast' because we have multiple values here: the four
elements of the array. These kinds of casts are very dangerous, because
they make assumptions about the way that multiple underlying structures
are implemented. For this, we need something more dangerous.

\subsection{\texorpdfstring{\texttt{transmute}}{transmute}}\label{transmute}

The \texttt{transmute} function is provided by a
\hyperref[sec--intrinsics]{compiler intrinsic}, and what it does is very
simple, but very scary. It tells Rust to treat a value of one type as
though it were another type. It does this regardless of the typechecking
system, and just completely trusts you.

In our previous example, we know that an array of four \texttt{u8}s
represents a \texttt{u32} properly, and so we want to do the cast. Using
\texttt{transmute} instead of \texttt{as}, Rust lets us:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::mem;}

\KeywordTok{unsafe} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{a = [}\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{];}

    \KeywordTok{let} \NormalTok{b = mem::transmute::<[}\DataTypeTok{u8}\NormalTok{; }\DecValTok{4}\NormalTok{], }\DataTypeTok{u32}\NormalTok{>(a);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We have to wrap the operation in an \texttt{unsafe} block for this to
compile successfully. Technically, only the \texttt{mem::transmute} call
itself needs to be in the block, but it's nice in this case to enclose
everything related, so you know where to look. In this case, the details
about \texttt{a} are also important, and so they're in the block. You'll
see code in either style, sometimes the context is too far away, and
wrapping all of the code in \texttt{unsafe} isn't a great idea.

While \texttt{transmute} does very little checking, it will at least
make sure that the types are the same size. This errors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::mem;}

\KeywordTok{unsafe} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{a = [}\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{, }\DecValTok{0u8}\NormalTok{];}

    \KeywordTok{let} \NormalTok{b = mem::transmute::<[}\DataTypeTok{u8}\NormalTok{; }\DecValTok{4}\NormalTok{], }\DataTypeTok{u64}\NormalTok{>(a);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

with:

\begin{verbatim}
error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
(64 bits)
\end{verbatim}

Other than that, you're on your own!

\section{Associated Types}\label{sec--associated-types}

Associated types are a powerful part of Rust's type system. They're
related to the idea of a `type family', in other words, grouping
multiple types together. That description is a bit abstract, so let's
dive right into an example. If you want to write a \texttt{Graph} trait,
you have two types to be generic over: the node type and the edge type.
So you might write a trait,
\texttt{Graph\textless{}N,\ E\textgreater{}}, that looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Graph<N, E> \{}
    \KeywordTok{fn} \NormalTok{has_edge(&}\KeywordTok{self}\NormalTok{, &N, &N) -> }\DataTypeTok{bool}\NormalTok{;}
    \KeywordTok{fn} \NormalTok{edges(&}\KeywordTok{self}\NormalTok{, &N) -> }\DataTypeTok{Vec}\NormalTok{<E>;}
    \CommentTok{// etc}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

While this sort of works, it ends up being awkward. For example, any
function that wants to take a \texttt{Graph} as a parameter now
\emph{also} needs to be generic over the \texttt{N}ode and \texttt{E}dge
types too:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> }\DataTypeTok{u32} \NormalTok{\{ ... \}}
\end{Highlighting}
\end{Shaded}

Our distance calculation works regardless of our \texttt{Edge} type, so
the \texttt{E} stuff in this signature is just a distraction.

What we really want to say is that a certain \texttt{E}dge and
\texttt{N}ode type come together to form each kind of \texttt{Graph}. We
can do that with associated types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Graph \{}
    \KeywordTok{type} \NormalTok{N;}
    \KeywordTok{type} \NormalTok{E;}

    \KeywordTok{fn} \NormalTok{has_edge(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{bool}\NormalTok{;}
    \KeywordTok{fn} \NormalTok{edges(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{Vec}\NormalTok{<}\KeywordTok{Self}\NormalTok{::E>;}
    \CommentTok{// etc}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, our clients can be abstract over a given \texttt{Graph}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> }\DataTypeTok{u32} \NormalTok{\{ ... \}}
\end{Highlighting}
\end{Shaded}

No need to deal with the \texttt{E}dge type here!

Let's go over all this in more detail.

\subsubsection{Defining associated
types}\label{defining-associated-types}

Let's build that \texttt{Graph} trait. Here's the definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Graph \{}
    \KeywordTok{type} \NormalTok{N;}
    \KeywordTok{type} \NormalTok{E;}

    \KeywordTok{fn} \NormalTok{has_edge(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{bool}\NormalTok{;}
    \KeywordTok{fn} \NormalTok{edges(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{Vec}\NormalTok{<}\KeywordTok{Self}\NormalTok{::E>;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Simple enough. Associated types use the \texttt{type} keyword, and go
inside the body of the trait, with the functions.

These \texttt{type} declarations can have all the same thing as
functions do. For example, if we wanted our \texttt{N} type to implement
\texttt{Display}, so we can print the nodes out, we could do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fmt;}

\KeywordTok{trait} \NormalTok{Graph \{}
    \KeywordTok{type} \NormalTok{N: fmt::Display;}
    \KeywordTok{type} \NormalTok{E;}

    \KeywordTok{fn} \NormalTok{has_edge(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{bool}\NormalTok{;}
    \KeywordTok{fn} \NormalTok{edges(&}\KeywordTok{self}\NormalTok{, &}\KeywordTok{Self}\NormalTok{::N) -> }\DataTypeTok{Vec}\NormalTok{<}\KeywordTok{Self}\NormalTok{::E>;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Implementing associated
types}\label{implementing-associated-types}

Just like any trait, traits that use associated types use the
\texttt{impl} keyword to provide implementations. Here's a simple
implementation of Graph:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Node;}

\KeywordTok{struct} \NormalTok{Edge;}

\KeywordTok{struct} \NormalTok{MyGraph;}

\KeywordTok{impl} \NormalTok{Graph }\KeywordTok{for} \NormalTok{MyGraph \{}
    \KeywordTok{type} \NormalTok{N = Node;}
    \KeywordTok{type} \NormalTok{E = Edge;}

    \KeywordTok{fn} \NormalTok{has_edge(&}\KeywordTok{self}\NormalTok{, n1: &Node, n2: &Node) -> }\DataTypeTok{bool} \NormalTok{\{}
        \ConstantTok{true}
    \NormalTok{\}}

    \KeywordTok{fn} \NormalTok{edges(&}\KeywordTok{self}\NormalTok{, n: &Node) -> }\DataTypeTok{Vec}\NormalTok{<Edge> \{}
        \DataTypeTok{Vec}\NormalTok{::new()}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This silly implementation always returns \texttt{true} and an empty
\texttt{Vec\textless{}Edge\textgreater{}}, but it gives you an idea of
how to implement this kind of thing. We first need three
\texttt{struct}s, one for the graph, one for the node, and one for the
edge. If it made more sense to use a different type, that would work as
well, we're just going to use \texttt{struct}s for all three here.

Next is the \texttt{impl} line, which is just like implementing any
other trait.

From here, we use \texttt{=} to define our associated types. The name
the trait uses goes on the left of the \texttt{=}, and the concrete type
we're \texttt{impl}ementing this for goes on the right. Finally, we use
the concrete types in our function declarations.

\subsubsection{Trait objects with associated
types}\label{trait-objects-with-associated-types}

There's one more bit of syntax we should talk about: trait objects. If
you try to create a trait object from an associated type, like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{graph = MyGraph;}
\KeywordTok{let} \NormalTok{obj = }\DataTypeTok{Box}\NormalTok{::new(graph) }\KeywordTok{as} \DataTypeTok{Box}\NormalTok{<Graph>;}
\end{Highlighting}
\end{Shaded}

You'll get two errors:

\begin{verbatim}
error: the value of the associated type `E` (from the trait `main::Graph`) must
be specified [E0191]
let obj = Box::new(graph) as Box<Graph>;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Graph`) must be specified [E0191]
let obj = Box::new(graph) as Box<Graph>;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{verbatim}

We can't create a trait object like this, because we don't know the
associated types. Instead, we can write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{graph = MyGraph;}
\KeywordTok{let} \NormalTok{obj = }\DataTypeTok{Box}\NormalTok{::new(graph) }\KeywordTok{as} \DataTypeTok{Box}\NormalTok{<Graph<N=Node, E=Edge>>;}
\end{Highlighting}
\end{Shaded}

The \texttt{N=Node} syntax allows us to provide a concrete type,
\texttt{Node}, for the \texttt{N} type parameter. Same with
\texttt{E=Edge}. If we didn't provide this constraint, we couldn't be
sure which \texttt{impl} to match this trait object to.

\hyperdef{}{sec--unsized-types}{\section{Unsized
Types}\label{sec--unsized-types}}

Most types have a particular size, in bytes, that is knowable at compile
time. For example, an \texttt{i32} is thirty-two bits big, or four
bytes. However, there are some types which are useful to express, but do
not have a defined size. These are called `unsized' or `dynamically
sized' types. One example is \texttt{{[}T{]}}. This type represents a
certain number of \texttt{T} in sequence. But we don't know how many
there are, so the size is not known.

Rust understands a few of these types, but they have some restrictions.
There are three:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We can only manipulate an instance of an unsized type via a pointer.
  An \texttt{\&{[}T{]}} works just fine, but a \texttt{{[}T{]}} does
  not.
\item
  Variables and arguments cannot have dynamically sized types.
\item
  Only the last field in a \texttt{struct} may have a dynamically sized
  type; the other fields must not. Enum variants must not have
  dynamically sized types as data.
\end{enumerate}

So why bother? Well, because \texttt{{[}T{]}} can only be used behind a
pointer, if we didn't have language support for unsized types, it would
be impossible to write this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{str} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl}\NormalTok{<T> Foo }\KeywordTok{for} \NormalTok{[T] \{}
\end{Highlighting}
\end{Shaded}

Instead, you would have to write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \NormalTok{&}\DataTypeTok{str} \NormalTok{\{}
\end{Highlighting}
\end{Shaded}

Meaning, this implementation would only work for
\hyperref[sec--references-and-borrowing]{references}, and not other
types of pointers. With the \texttt{impl\ for\ str}, all pointers,
including (at some point, there are some bugs to fix first) user-defined
custom smart pointers, can use this \texttt{impl}.

\subsection{?Sized}\label{sized}

If you want to write a function that accepts a dynamically sized type,
you can use the special bound, \texttt{?Sized}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo<T: ?}\BuiltInTok{Sized}\NormalTok{> \{}
    \NormalTok{f: T,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This \texttt{?}, read as ``T may be \texttt{Sized}'', means that this
bound is special: it lets us match more kinds, not less. It's almost
like every \texttt{T} implicitly has \texttt{T:\ Sized}, and the
\texttt{?} undoes this default.

\hyperdef{}{sec--operators-and-overloading}{\section{Operators and
Overloading}\label{sec--operators-and-overloading}}

Rust allows for a limited form of operator overloading. There are
certain operators that are able to be overloaded. To support a
particular operator between types, there's a specific trait that you can
implement, which then overloads the operator.

For example, the \texttt{+} operator can be overloaded with the
\texttt{Add} trait:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::ops::Add;}

\AttributeTok{#[}\NormalTok{derive}\AttributeTok{(}\BuiltInTok{Debug}\AttributeTok{)]}
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{y: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Add }\KeywordTok{for} \NormalTok{Point \{}
    \KeywordTok{type} \NormalTok{Output = Point;}

    \KeywordTok{fn} \NormalTok{add(}\KeywordTok{self}\NormalTok{, other: Point) -> Point \{}
        \NormalTok{Point \{ x: }\KeywordTok{self}\NormalTok{.x + other.x, y: }\KeywordTok{self}\NormalTok{.y + other.y \}}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{p1 = Point \{ x: }\DecValTok{1}\NormalTok{, y: }\DecValTok{0} \NormalTok{\};}
    \KeywordTok{let} \NormalTok{p2 = Point \{ x: }\DecValTok{2}\NormalTok{, y: }\DecValTok{3} \NormalTok{\};}

    \KeywordTok{let} \NormalTok{p3 = p1 + p2;}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\NormalTok{, p3);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{main}, we can use \texttt{+} on our two \texttt{Point}s,
since we've implemented
\texttt{Add\textless{}Output=Point\textgreater{}} for \texttt{Point}.

There are a number of operators that can be overloaded this way, and all
of their associated traits live in the
\href{http://doc.rust-lang.org/std/ops/index.html}{\texttt{std::ops}}
module. Check out its documentation for the full list.

Implementing these traits follows a pattern. Let's look at
\href{http://doc.rust-lang.org/std/ops/trait.Add.html}{\texttt{Add}} in
more detail:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{trait} \NormalTok{Add<RHS = }\KeywordTok{Self}\NormalTok{> \{}
    \KeywordTok{type} \NormalTok{Output;}

    \KeywordTok{fn} \NormalTok{add(}\KeywordTok{self}\NormalTok{, rhs: RHS) -> }\KeywordTok{Self}\NormalTok{::Output;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's three types in total involved here: the type you
\texttt{impl\ Add} for, \texttt{RHS}, which defaults to \texttt{Self},
and \texttt{Output}. For an expression \texttt{let\ z\ =\ x\ +\ y},
\texttt{x} is the \texttt{Self} type, \texttt{y} is the RHS, and
\texttt{z} is the \texttt{Self::Output} type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{impl} \NormalTok{Add<}\DataTypeTok{i32}\NormalTok{> }\KeywordTok{for} \NormalTok{Point \{}
    \KeywordTok{type} \NormalTok{Output = }\DataTypeTok{f64}\NormalTok{;}

    \KeywordTok{fn} \NormalTok{add(}\KeywordTok{self}\NormalTok{, rhs: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{f64} \NormalTok{\{}
        \CommentTok{// add an i32 to a Point and get an f64}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

will let you do this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{p: Point = }\CommentTok{// ...}
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{f64} \NormalTok{= p + }\DecValTok{2i32}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{Using operator traits in generic
structs}\label{using-operator-traits-in-generic-structs}

Now that we know how operator traits are defined, we can define our
\texttt{HasArea} trait and \texttt{Square} struct from the
\hyperref[sec--traits]{traits chapter} more generically:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::ops::Mul;}

\KeywordTok{trait} \NormalTok{HasArea<T> \{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> T;}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Square<T> \{}
    \NormalTok{x: T,}
    \NormalTok{y: T,}
    \NormalTok{side: T,}
\NormalTok{\}}

\KeywordTok{impl}\NormalTok{<T> HasArea<T> }\KeywordTok{for} \NormalTok{Square<T>}
        \KeywordTok{where} \NormalTok{T: Mul<Output=T> + }\BuiltInTok{Copy} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{area(&}\KeywordTok{self}\NormalTok{) -> T \{}
        \KeywordTok{self}\NormalTok{.side * }\KeywordTok{self}\NormalTok{.side}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{s = Square \{}
        \NormalTok{x: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{y: }\DecValTok{0.0f64}\NormalTok{,}
        \NormalTok{side: }\DecValTok{12.0f64}\NormalTok{,}
    \NormalTok{\};}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Area of s: \{\}"}\NormalTok{, s.area());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For \texttt{HasArea} and \texttt{Square}, we just declare a type
parameter \texttt{T} and replace \texttt{f64} with it. The \texttt{impl}
needs more involved modifications:

\begin{verbatim}
impl<T> HasArea<T> for Square<T>
        where T: Mul<Output=T> + Copy { ... }
\end{verbatim}

The \texttt{area} method requires that we can multiply the sides, so we
declare that type \texttt{T} must implement \texttt{std::ops::Mul}. Like
\texttt{Add}, mentioned above, \texttt{Mul} itself takes an
\texttt{Output} parameter: since we know that numbers don't change type
when multiplied, we also set it to \texttt{T}. \texttt{T} must also
support copying, so Rust doesn't try to move \texttt{self.side} into the
return value.

\hyperdef{}{sec--deref-coercions}{\section{Deref
coercions}\label{sec--deref-coercions}}

The standard library provides a special trait,
\href{http://doc.rust-lang.org/std/ops/trait.Deref.html}{\texttt{Deref}}.
It's normally used to overload \texttt{*}, the dereference operator:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::ops::Deref;}

\KeywordTok{struct} \NormalTok{DerefExample<T> \{}
    \NormalTok{value: T,}
\NormalTok{\}}

\KeywordTok{impl}\NormalTok{<T> Deref }\KeywordTok{for} \NormalTok{DerefExample<T> \{}
    \KeywordTok{type} \NormalTok{Target = T;}

    \KeywordTok{fn} \NormalTok{deref(&}\KeywordTok{self}\NormalTok{) -> &T \{}
        \NormalTok{&}\KeywordTok{self}\NormalTok{.value}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = DerefExample \{ value: }\CharTok{'a'} \NormalTok{\};}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\CharTok{'a'}\NormalTok{, *x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is useful for writing custom pointer types. However, there's a
language feature related to \texttt{Deref}: `deref coercions'. Here's
the rule: If you have a type \texttt{U}, and it implements
\texttt{Deref\textless{}Target=T\textgreater{}}, values of \texttt{\&U}
will automatically coerce to a \texttt{\&T}. Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(s: &}\DataTypeTok{str}\NormalTok{) \{}
    \CommentTok{// borrow a string for a second}
\NormalTok{\}}

\CommentTok{// String implements Deref<Target=str>}
\KeywordTok{let} \NormalTok{owned = }\StringTok{"Hello"}\NormalTok{.to_string();}

\CommentTok{// therefore, this works:}
\NormalTok{foo(&owned);}
\end{Highlighting}
\end{Shaded}

Using an ampersand in front of a value takes a reference to it. So
\texttt{owned} is a \texttt{String}, \texttt{\&owned} is an
\texttt{\&String}, and since
\texttt{impl\ Deref\textless{}Target=str\textgreater{}\ for\ String},
\texttt{\&String} will deref to \texttt{\&str}, which \texttt{foo()}
takes.

That's it. This rule is one of the only places in which Rust does an
automatic conversion for you, but it adds a lot of flexibility. For
example, the \texttt{Rc\textless{}T\textgreater{}} type implements
\texttt{Deref\textless{}Target=T\textgreater{}}, so this works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::rc::Rc;}

\KeywordTok{fn} \NormalTok{foo(s: &}\DataTypeTok{str}\NormalTok{) \{}
    \CommentTok{// borrow a string for a second}
\NormalTok{\}}

\CommentTok{// String implements Deref<Target=str>}
\KeywordTok{let} \NormalTok{owned = }\StringTok{"Hello"}\NormalTok{.to_string();}
\KeywordTok{let} \NormalTok{counted = Rc::new(owned);}

\CommentTok{// therefore, this works:}
\NormalTok{foo(&counted);}
\end{Highlighting}
\end{Shaded}

All we've done is wrap our \texttt{String} in an
\texttt{Rc\textless{}T\textgreater{}}. But we can now pass the
\texttt{Rc\textless{}String\textgreater{}} around anywhere we'd have a
\texttt{String}. The signature of \texttt{foo} didn't change, but works
just as well with either type. This example has two conversions:
\texttt{Rc\textless{}String\textgreater{}} to \texttt{String} and then
\texttt{String} to \texttt{\&str}. Rust will do this as many times as
possible until the types match.

Another very common implementation provided by the standard library is:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{foo(s: &[}\DataTypeTok{i32}\NormalTok{]) \{}
    \CommentTok{// borrow a slice for a second}
\NormalTok{\}}

\CommentTok{// Vec<T> implements Deref<Target=[T]>}
\KeywordTok{let} \NormalTok{owned = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}

\NormalTok{foo(&owned);}
\end{Highlighting}
\end{Shaded}

Vectors can \texttt{Deref} to a slice.

\subsubsection{Deref and method calls}\label{deref-and-method-calls}

\texttt{Deref} will also kick in when calling a method. Consider the
following example.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Foo;}

\KeywordTok{impl} \NormalTok{Foo \{}
    \KeywordTok{fn} \NormalTok{foo(&}\KeywordTok{self}\NormalTok{) \{ }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"Foo"}\NormalTok{); \}}
\NormalTok{\}}

\KeywordTok{let} \NormalTok{f = &&Foo;}

\NormalTok{f.foo();}
\end{Highlighting}
\end{Shaded}

Even though \texttt{f} is a \texttt{\&\&Foo} and \texttt{foo} takes
\texttt{\&self}, this works. That's because these things are the same:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.foo();}
\NormalTok{(&f).foo();}
\NormalTok{(&&f).foo();}
\NormalTok{(&&&&&&&&f).foo();}
\end{Highlighting}
\end{Shaded}

A value of type \texttt{\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&Foo} can still
have methods defined on \texttt{Foo} called, because the compiler will
insert as many * operations as necessary to get it right. And since it's
inserting \texttt{*}s, that uses \texttt{Deref}.

\hyperdef{}{sec--macros}{\section{Macros}\label{sec--macros}}

By now you've learned about many of the tools Rust provides for
abstracting and reusing code. These units of code reuse have a rich
semantic structure. For example, functions have a type signature, type
parameters have trait bounds, and overloaded functions must belong to a
particular trait.

This structure means that Rust's core abstractions have powerful
compile-time correctness checking. But this comes at the price of
reduced flexibility. If you visually identify a pattern of repeated
code, you may find it's difficult or cumbersome to express that pattern
as a generic function, a trait, or anything else within Rust's
semantics.

Macros allow us to abstract at a syntactic level. A macro invocation is
shorthand for an ``expanded'' syntactic form. This expansion happens
early in compilation, before any static checking. As a result, macros
can capture many patterns of code reuse that Rust's core abstractions
cannot.

The drawback is that macro-based code can be harder to understand,
because fewer of the built-in rules apply. Like an ordinary function, a
well-behaved macro can be used without understanding its implementation.
However, it can be difficult to design a well-behaved macro!
Additionally, compiler errors in macro code are harder to interpret,
because they describe problems in the expanded code, not the
source-level form that developers use.

These drawbacks make macros something of a ``feature of last resort''.
That's not to say that macros are bad; they are part of Rust because
sometimes they're needed for truly concise, well-abstracted code. Just
keep this tradeoff in mind.

\subsection{Defining a macro}\label{defining-a-macro}

You may have seen the \texttt{vec!} macro, used to initialize a
\hyperref[sec--vectors]{vector} with any number of elements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{u32}\NormalTok{> = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

This can't be an ordinary function, because it takes any number of
arguments. But we can imagine it as syntactic shorthand for

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Vec}\NormalTok{<}\DataTypeTok{u32}\NormalTok{> = \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{temp_vec = }\DataTypeTok{Vec}\NormalTok{::new();}
    \NormalTok{temp_vec.push(}\DecValTok{1}\NormalTok{);}
    \NormalTok{temp_vec.push(}\DecValTok{2}\NormalTok{);}
    \NormalTok{temp_vec.push(}\DecValTok{3}\NormalTok{);}
    \NormalTok{temp_vec}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

We can implement this shorthand, using a macro: \footnote{The actual
  definition of \texttt{vec!} in libcollections differs from the one
  presented here, for reasons of efficiency and reusability.}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{vec \{}
    \NormalTok{( $( $x:expr ),* ) => \{}
        \NormalTok{\{}
            \KeywordTok{let} \KeywordTok{mut} \NormalTok{temp_vec = }\DataTypeTok{Vec}\NormalTok{::new();}
            \NormalTok{$(}
                \NormalTok{temp_vec.push($x);}
            \NormalTok{)*}
            \NormalTok{temp_vec}
        \NormalTok{\}}
    \NormalTok{\};}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Whoa, that's a lot of new syntax! Let's break it down.

\begin{verbatim}
macro_rules! vec { ... }
\end{verbatim}

This says we're defining a macro named \texttt{vec}, much as
\texttt{fn\ vec} would define a function named \texttt{vec}. In prose,
we informally write a macro's name with an exclamation point, e.g.
\texttt{vec!}. The exclamation point is part of the invocation syntax
and serves to distinguish a macro from an ordinary function.

\subsubsection{Matching}\label{matching}

The macro is defined through a series of rules, which are
pattern-matching cases. Above, we had

\begin{verbatim}
( $( $x:expr ),* ) => { ... };
\end{verbatim}

This is like a \texttt{match} expression arm, but the matching happens
on Rust syntax trees, at compile time. The semicolon is optional on the
last (here, only) case. The ``pattern'' on the left-hand side of
\texttt{=\textgreater{}} is known as a `matcher'. These have {[}their
own little grammar{]} within the language.

The matcher \texttt{\$x:expr} will match any Rust expression, binding
that syntax tree to the `metavariable' \texttt{\$x}. The identifier
\texttt{expr} is a `fragment specifier'; the full possibilities are
enumerated later in this chapter. Surrounding the matcher with
\texttt{\$(...),*} will match zero or more expressions, separated by
commas.

Aside from the special matcher syntax, any Rust tokens that appear in a
matcher must match exactly. For example,

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{foo \{}
    \NormalTok{(x => $e:expr) => (}\PreprocessorTok{println!}\NormalTok{(}\StringTok{"mode X: \{\}"}\NormalTok{, $e));}
    \NormalTok{(y => $e:expr) => (}\PreprocessorTok{println!}\NormalTok{(}\StringTok{"mode Y: \{\}"}\NormalTok{, $e));}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{foo!}\NormalTok{(y => }\DecValTok{3}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

will print

\begin{verbatim}
mode Y: 3
\end{verbatim}

With

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{foo!}\NormalTok{(z => }\DecValTok{3}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

we get the compiler error

\begin{verbatim}
error: no rules expected the token `z`
\end{verbatim}

\subsubsection{Expansion}\label{expansion}

The right-hand side of a macro rule is ordinary Rust syntax, for the
most part. But we can splice in bits of syntax captured by the matcher.
From the original example:

\begin{verbatim}
$(
    temp_vec.push($x);
)*
\end{verbatim}

Each matched expression \texttt{\$x} will produce a single \texttt{push}
statement in the macro expansion. The repetition in the expansion
proceeds in ``lockstep'' with repetition in the matcher (more on this in
a moment).

Because \texttt{\$x} was already declared as matching an expression, we
don't repeat \texttt{:expr} on the right-hand side. Also, we don't
include a separating comma as part of the repetition operator. Instead,
we have a terminating semicolon within the repeated block.

Another detail: the \texttt{vec!} macro has \emph{two} pairs of braces
on the right-hand side. They are often combined like so:

\begin{verbatim}
macro_rules! foo {
    () => {{
        ...
    }}
}
\end{verbatim}

The outer braces are part of the syntax of \texttt{macro\_rules!}. In
fact, you can use \texttt{()} or \texttt{{[}{]}} instead. They simply
delimit the right-hand side as a whole.

The inner braces are part of the expanded syntax. Remember, the
\texttt{vec!} macro is used in an expression context. To write an
expression with multiple statements, including \texttt{let}-bindings, we
use a block. If your macro expands to a single expression, you don't
need this extra layer of braces.

Note that we never \emph{declared} that the macro produces an
expression. In fact, this is not determined until we use the macro as an
expression. With care, you can write a macro whose expansion works in
several contexts. For example, shorthand for a data type could be valid
as either an expression or a pattern.

\subsubsection{Repetition}\label{repetition}

The repetition operator follows two principal rules:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\$(...)*} walks through one ``layer'' of repetitions, for all
  of the \texttt{\$name}s it contains, in lockstep, and
\item
  each \texttt{\$name} must be under at least as many \texttt{\$(...)*}s
  as it was matched against. If it is under more, it'll be duplicated,
  as appropriate.
\end{enumerate}

This baroque macro illustrates the duplication of variables from outer
repetition levels.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{o_O \{}
    \NormalTok{(}
        \NormalTok{$(}
            \NormalTok{$x:expr; [ $( $y:expr ),* ]}
        \NormalTok{);*}
    \NormalTok{) => \{}
        \NormalTok{&[ $($( $x + $y ),*),* ]}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{a: &[}\DataTypeTok{i32}\NormalTok{]}
        \NormalTok{= }\PreprocessorTok{o_O!}\NormalTok{(}\DecValTok{10}\NormalTok{; [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{];}
               \DecValTok{20}\NormalTok{; [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]);}

    \PreprocessorTok{assert_eq!}\NormalTok{(a, [}\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{26}\NormalTok{]);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That's most of the matcher syntax. These examples use \texttt{\$(...)*},
which is a ``zero or more'' match. Alternatively you can write
\texttt{\$(...)+} for a ``one or more'' match. Both forms optionally
include a separator, which can be any token except \texttt{+} or
\texttt{*}.

This system is based on
``\href{https://www.cs.indiana.edu/ftp/techreports/TR206.pdf}{Macro-by-Example}''
(PDF link).

\subsection{Hygiene}\label{hygiene}

Some languages implement macros using simple text substitution, which
leads to various problems. For example, this C program prints
\texttt{13} instead of the expected \texttt{25}.

\begin{verbatim}
#define FIVE_TIMES(x) 5 * x

int main() {
    printf("%d\n", FIVE_TIMES(2 + 3));
    return 0;
}
\end{verbatim}

After expansion we have \texttt{5\ *\ 2\ +\ 3}, and multiplication has
greater precedence than addition. If you've used C macros a lot, you
probably know the standard idioms for avoiding this problem, as well as
five or six others. In Rust, we don't have to worry about it.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{five_times \{}
    \NormalTok{($x:expr) => (}\DecValTok{5} \NormalTok{* $x);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{25}\NormalTok{, }\PreprocessorTok{five_times!}\NormalTok{(}\DecValTok{2} \NormalTok{+ }\DecValTok{3}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The metavariable \texttt{\$x} is parsed as a single expression node, and
keeps its place in the syntax tree even after substitution.

Another common problem in macro systems is `variable capture'. Here's a
C macro, using {[}a GNU C extension{]} to emulate Rust's expression
blocks.

\begin{verbatim}
#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state > 0) { \
        printf("log(%d): %s\n", state, msg); \
    } \
})
\end{verbatim}

Here's a simple use case that goes terribly wrong:

\begin{verbatim}
const char *state = "reticulating splines";
LOG(state)
\end{verbatim}

This expands to

\begin{verbatim}
const char *state = "reticulating splines";
int state = get_log_state();
if (state > 0) {
    printf("log(%d): %s\n", state, state);
}
\end{verbatim}

The second variable named \texttt{state} shadows the first one. This is
a problem because the print statement should refer to both of them.

The equivalent Rust macro has the desired behavior.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{log \{}
    \NormalTok{($msg:expr) => \{\{}
        \KeywordTok{let} \NormalTok{state: }\DataTypeTok{i32} \NormalTok{= get_log_state();}
        \KeywordTok{if} \NormalTok{state > }\DecValTok{0} \NormalTok{\{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"log(\{\}): \{\}"}\NormalTok{, state, $msg);}
        \NormalTok{\}}
    \NormalTok{\}\};}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{state: &}\DataTypeTok{str} \NormalTok{= }\StringTok{"reticulating splines"}\NormalTok{;}
    \PreprocessorTok{log!}\NormalTok{(state);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This works because Rust has a {[}hygienic macro system{]}. Each macro
expansion happens in a distinct `syntax context', and each variable is
tagged with the syntax context where it was introduced. It's as though
the variable \texttt{state} inside \texttt{main} is painted a different
``color'' from the variable \texttt{state} inside the macro, and
therefore they don't conflict.

This also restricts the ability of macros to introduce new bindings at
the invocation site. Code such as the following will not work:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{foo \{}
    \NormalTok{() => (}\KeywordTok{let} \NormalTok{x = }\DecValTok{3}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{foo!}\NormalTok{();}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Instead you need to pass the variable name into the invocation, so it's
tagged with the right syntax context.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{foo \{}
    \NormalTok{($v:ident) => (}\KeywordTok{let} \NormalTok{$v = }\DecValTok{3}\NormalTok{);}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{foo!}\NormalTok{(x);}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\NormalTok{, x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This holds for \texttt{let} bindings and loop labels, but not for
\href{http://doc.rust-lang.org/reference.html\#items}{items}. So the
following code does compile:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{foo \{}
    \NormalTok{() => (}\KeywordTok{fn} \NormalTok{x() \{ \});}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{foo!}\NormalTok{();}
    \NormalTok{x();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Recursive macros}\label{recursive-macros}

A macro's expansion can include more macro invocations, including
invocations of the very same macro being expanded. These recursive
macros are useful for processing tree-structured input, as illustrated
by this (simplistic) HTML shorthand:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{write_html \{}
    \NormalTok{($w:expr, ) => (());}

    \NormalTok{($w:expr, $e:tt) => (}\PreprocessorTok{write!}\NormalTok{($w, }\StringTok{"\{\}"}\NormalTok{, $e));}

    \NormalTok{($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => \{\{}
        \PreprocessorTok{write!}\NormalTok{($w, }\StringTok{"<\{\}>"}\NormalTok{, }\PreprocessorTok{stringify!}\NormalTok{($tag));}
        \PreprocessorTok{write_html!}\NormalTok{($w, $($inner)*);}
        \PreprocessorTok{write!}\NormalTok{($w, }\StringTok{"</\{\}>"}\NormalTok{, }\PreprocessorTok{stringify!}\NormalTok{($tag));}
        \PreprocessorTok{write_html!}\NormalTok{($w, $($rest)*);}
    \NormalTok{\}\};}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{use} \NormalTok{std::fmt::Write;}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{out = }\DataTypeTok{String}\NormalTok{::new();}

    \PreprocessorTok{write_html!}\NormalTok{(&}\KeywordTok{mut} \NormalTok{out,}
        \NormalTok{html[}
            \NormalTok{head[title[}\StringTok{"Macros guide"}\NormalTok{]]}
            \NormalTok{body[h1[}\StringTok{"Macros are the best!"}\NormalTok{]]}
        \NormalTok{]);}

    \PreprocessorTok{assert_eq!}\NormalTok{(out,}
        \StringTok{"<html><head><title>Macros guide</title></head>}\SpecialCharTok{\textbackslash{}}
\StringTok{         <body><h1>Macros are the best!</h1></body></html>"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{debugging-macro-code}{\subsection{Debugging macro
code}\label{debugging-macro-code}}

To see the results of expanding macros, run
\texttt{rustc\ -\/-pretty\ expanded}. The output represents a whole
crate, so you can also feed it back in to \texttt{rustc}, which will
sometimes produce better error messages than the original compilation.
Note that the \texttt{-\/-pretty\ expanded} output may have a different
meaning if multiple variables of the same name (but different syntax
contexts) are in play in the same scope. In this case
\texttt{-\/-pretty\ expanded,hygiene} will tell you about the syntax
contexts.

\texttt{rustc} provides two syntax extensions that help with macro
debugging. For now, they are unstable and require feature gates.

\begin{itemize}
\item
  \texttt{log\_syntax!(...)} will print its arguments to standard
  output, at compile time, and ``expand'' to nothing.
\item
  \texttt{trace\_macros!(true)} will enable a compiler message every
  time a macro is expanded. Use \texttt{trace\_macros!(false)} later in
  expansion to turn it off.
\end{itemize}

\subsection{Syntactic requirements}\label{syntactic-requirements}

Even when Rust code contains un-expanded macros, it can be parsed as a
full \hyperref[abstract-syntax-tree]{syntax tree}. This property can be
very useful for editors and other tools that process code. It also has a
few consequences for the design of Rust's macro system.

One consequence is that Rust must determine, when it parses a macro
invocation, whether the macro stands in for

\begin{itemize}
\tightlist
\item
  zero or more items,
\item
  zero or more methods,
\item
  an expression,
\item
  a statement, or
\item
  a pattern.
\end{itemize}

A macro invocation within a block could stand for some items, or for an
expression / statement. Rust uses a simple rule to resolve this
ambiguity. A macro invocation that stands for items must be either

\begin{itemize}
\tightlist
\item
  delimited by curly braces, e.g. \texttt{foo!\ \{\ ...\ \}}, or
\item
  terminated by a semicolon, e.g. \texttt{foo!(...);}
\end{itemize}

Another consequence of pre-expansion parsing is that the macro
invocation must consist of valid Rust tokens. Furthermore, parentheses,
brackets, and braces must be balanced within a macro invocation. For
example, \texttt{foo!({[})} is forbidden. This allows Rust to know where
the macro invocation ends.

More formally, the macro invocation body must be a sequence of `token
trees'. A token tree is defined recursively as either

\begin{itemize}
\tightlist
\item
  a sequence of token trees surrounded by matching \texttt{()},
  \texttt{{[}{]}}, or \texttt{\{\}}, or
\item
  any other single token.
\end{itemize}

Within a matcher, each metavariable has a `fragment specifier',
identifying which syntactic form it matches.

\begin{itemize}
\tightlist
\item
  \texttt{ident}: an identifier. Examples: \texttt{x}; \texttt{foo}.
\item
  \texttt{path}: a qualified name. Example: \texttt{T::SpecialA}.
\item
  \texttt{expr}: an expression. Examples: \texttt{2\ +\ 2};
  \texttt{if\ true\ then\ \{\ 1\ \}\ else\ \{\ 2\ \}}; \texttt{f(42)}.
\item
  \texttt{ty}: a type. Examples: \texttt{i32};
  \texttt{Vec\textless{}(char,\ String)\textgreater{}}; \texttt{\&T}.
\item
  \texttt{pat}: a pattern. Examples: \texttt{Some(t)};
  \texttt{(17,\ \textquotesingle{}a\textquotesingle{})}; \texttt{\_}.
\item
  \texttt{stmt}: a single statement. Example: \texttt{let\ x\ =\ 3}.
\item
  \texttt{block}: a brace-delimited sequence of statements. Example:
  \texttt{\{\ log(error,\ "hi");\ return\ 12;\ \}}.
\item
  \texttt{item}: an
  \href{http://doc.rust-lang.org/reference.html\#items}{item}. Examples:
  \texttt{fn\ foo()\ \{\ \}}; \texttt{struct\ Bar;}.
\item
  \texttt{meta}: a ``meta item'', as found in attributes. Example:
  \texttt{cfg(target\_os\ =\ "windows")}.
\item
  \texttt{tt}: a single token tree.
\end{itemize}

There are additional rules regarding the next token after a
metavariable:

\begin{itemize}
\tightlist
\item
  \texttt{expr} variables may only be followed by one of:
  \texttt{=\textgreater{}\ ,\ ;}
\item
  \texttt{ty} and \texttt{path} variables may only be followed by one
  of: \texttt{=\textgreater{}\ ,\ :\ =\ \textgreater{}\ as}
\item
  \texttt{pat} variables may only be followed by one of:
  \texttt{=\textgreater{}\ ,\ =\ if\ in}
\item
  Other variables may be followed by any token.
\end{itemize}

These rules provide some flexibility for Rust's syntax to evolve without
breaking existing macros.

The macro system does not deal with parse ambiguity at all. For example,
the grammar \texttt{\$(\$t:ty)*\ \$e:expr} will always fail to parse,
because the parser would be forced to choose between parsing
\texttt{\$t} and parsing \texttt{\$e}. Changing the invocation syntax to
put a distinctive token in front can solve the problem. In this case,
you can write \texttt{\$(T\ \$t:ty)*\ E\ \$e:exp}.

\subsection{Scoping and macro
import/export}\label{scoping-and-macro-importexport}

Macros are expanded at an early stage in compilation, before name
resolution. One downside is that scoping works differently for macros,
compared to other constructs in the language.

Definition and expansion of macros both happen in a single depth-first,
lexical-order traversal of a crate's source. So a macro defined at
module scope is visible to any subsequent code in the same module, which
includes the body of any subsequent child \texttt{mod} items.

A macro defined within the body of a single \texttt{fn}, or anywhere
else not at module scope, is visible only within that item.

If a module has the \texttt{macro\_use} attribute, its macros are also
visible in its parent module after the child's \texttt{mod} item. If the
parent also has \texttt{macro\_use} then the macros will be visible in
the grandparent after the parent's \texttt{mod} item, and so forth.

The \texttt{macro\_use} attribute can also appear on
\texttt{extern\ crate}. In this context it controls which macros are
loaded from the external crate, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{macro_use}\AttributeTok{(}\NormalTok{foo}\AttributeTok{,} \NormalTok{bar}\AttributeTok{)]}
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{baz;}
\end{Highlighting}
\end{Shaded}

If the attribute is given simply as \texttt{\#{[}macro\_use{]}}, all
macros are loaded. If there is no \texttt{\#{[}macro\_use{]}} attribute
then no macros are loaded. Only macros defined with the
\texttt{\#{[}macro\_export{]}} attribute may be loaded.

To load a crate's macros without linking it into the output, use
\texttt{\#{[}no\_link{]}} as well.

An example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{m1 \{ () => (()) \}}

\CommentTok{// visible here: m1}

\KeywordTok{mod} \NormalTok{foo \{}
    \CommentTok{// visible here: m1}

    \AttributeTok{#[}\NormalTok{macro_export}\AttributeTok{]}
    \PreprocessorTok{macro_rules!} \NormalTok{m2 \{ () => (()) \}}

    \CommentTok{// visible here: m1, m2}
\NormalTok{\}}

\CommentTok{// visible here: m1}

\PreprocessorTok{macro_rules!} \NormalTok{m3 \{ () => (()) \}}

\CommentTok{// visible here: m1, m3}

\AttributeTok{#[}\NormalTok{macro_use}\AttributeTok{]}
\KeywordTok{mod} \NormalTok{bar \{}
    \CommentTok{// visible here: m1, m3}

    \PreprocessorTok{macro_rules!} \NormalTok{m4 \{ () => (()) \}}

    \CommentTok{// visible here: m1, m3, m4}
\NormalTok{\}}

\CommentTok{// visible here: m1, m3, m4}
\end{Highlighting}
\end{Shaded}

When this library is loaded with
\texttt{\#{[}macro\_use{]}\ extern\ crate}, only \texttt{m2} will be
imported.

The Rust Reference has a
\href{http://doc.rust-lang.org/reference.html\#macro-related-attributes}{listing
of macro-related attributes}.

\subsection{\texorpdfstring{The variable
\texttt{\$crate}}{The variable \$crate}}\label{the-variable-crate}

A further difficulty occurs when a macro is used in multiple crates. Say
that \texttt{mylib} defines

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pub} \KeywordTok{fn} \NormalTok{increment(x: }\DataTypeTok{u32}\NormalTok{) -> }\DataTypeTok{u32} \NormalTok{\{}
    \NormalTok{x + }\DecValTok{1}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{macro_export}\AttributeTok{]}
\PreprocessorTok{macro_rules!} \NormalTok{inc_a \{}
    \NormalTok{($x:expr) => ( ::increment($x) )}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{macro_export}\AttributeTok{]}
\PreprocessorTok{macro_rules!} \NormalTok{inc_b \{}
    \NormalTok{($x:expr) => ( ::mylib::increment($x) )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{inc\_a} only works within \texttt{mylib}, while \texttt{inc\_b}
only works outside the library. Furthermore, \texttt{inc\_b} will break
if the user imports \texttt{mylib} under another name.

Rust does not (yet) have a hygiene system for crate references, but it
does provide a simple workaround for this problem. Within a macro
imported from a crate named \texttt{foo}, the special macro variable
\texttt{\$crate} will expand to \texttt{::foo}. By contrast, when a
macro is defined and then used in the same crate, \texttt{\$crate} will
expand to nothing. This means we can write

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#[}\NormalTok{macro_export}\AttributeTok{]}
\PreprocessorTok{macro_rules!} \NormalTok{inc \{}
    \NormalTok{($x:expr) => ( $crate::increment($x) )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

to define a single macro that works both inside and outside our library.
The function name will expand to either \texttt{::increment} or
\texttt{::mylib::increment}.

To keep this system simple and correct,
\texttt{\#{[}macro\_use{]}\ extern\ crate\ ...} may only appear at the
root of your crate, not inside \texttt{mod}. This ensures that
\texttt{\$crate} is a single identifier.

\subsection{The deep end}\label{the-deep-end}

The introductory chapter mentioned recursive macros, but it did not give
the full story. Recursive macros are useful for another reason: Each
recursive invocation gives you another opportunity to pattern-match the
macro's arguments.

As an extreme example, it is possible, though hardly advisable, to
implement the
\href{https://esolangs.org/wiki/Bitwise_Cyclic_Tag}{Bitwise Cyclic Tag}
automaton within Rust's macro system.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{macro_rules!} \NormalTok{bct \{}
    \CommentTok{// cmd 0:  d ... => ...}
    \NormalTok{(}\DecValTok{0}\NormalTok{, $($ps:tt),* ; $_d:tt)}
        \NormalTok{=> (}\PreprocessorTok{bct!}\NormalTok{($($ps),*, }\DecValTok{0} \NormalTok{; ));}
    \NormalTok{(}\DecValTok{0}\NormalTok{, $($ps:tt),* ; $_d:tt, $($ds:tt),*)}
        \NormalTok{=> (}\PreprocessorTok{bct!}\NormalTok{($($ps),*, }\DecValTok{0} \NormalTok{; $($ds),*));}

    \CommentTok{// cmd 1p:  1 ... => 1 ... p}
    \NormalTok{(}\DecValTok{1}\NormalTok{, $p:tt, $($ps:tt),* ; }\DecValTok{1}\NormalTok{)}
        \NormalTok{=> (}\PreprocessorTok{bct!}\NormalTok{($($ps),*, }\DecValTok{1}\NormalTok{, $p ; }\DecValTok{1}\NormalTok{, $p));}
    \NormalTok{(}\DecValTok{1}\NormalTok{, $p:tt, $($ps:tt),* ; }\DecValTok{1}\NormalTok{, $($ds:tt),*)}
        \NormalTok{=> (}\PreprocessorTok{bct!}\NormalTok{($($ps),*, }\DecValTok{1}\NormalTok{, $p ; }\DecValTok{1}\NormalTok{, $($ds),*, $p));}

    \CommentTok{// cmd 1p:  0 ... => 0 ...}
    \NormalTok{(}\DecValTok{1}\NormalTok{, $p:tt, $($ps:tt),* ; $($ds:tt),*)}
        \NormalTok{=> (}\PreprocessorTok{bct!}\NormalTok{($($ps),*, }\DecValTok{1}\NormalTok{, $p ; $($ds),*));}

    \CommentTok{// halt on empty data string}
    \NormalTok{( $($ps:tt),* ; )}
        \NormalTok{=> (());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Exercise: use macros to reduce duplication in the above definition of
the \texttt{bct!} macro.

\subsection{Common macros}\label{common-macros}

Here are some common macros you'll see in Rust code.

\subsubsection{panic!}\label{panic}

This macro causes the current thread to panic. You can give it a message
to panic with:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{panic!}\NormalTok{(}\StringTok{"oh no!"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{vec!}\label{vec}

The \texttt{vec!} macro is used throughout the book, so you've probably
seen it already. It creates \texttt{Vec\textless{}T\textgreater{}}s with
ease:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

It also lets you make vectors with repeating values. For example, a
hundred zeroes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\DecValTok{0}\NormalTok{; }\DecValTok{100}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

\subsubsection{assert! and assert\_eq!}\label{assert-and-assertux5feq}

These two macros are used in tests. \texttt{assert!} takes a boolean.
\texttt{assert\_eq!} takes two values and checks them for equality.
\texttt{true} passes, \texttt{false} \texttt{panic!}s. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// A-ok!}

\PreprocessorTok{assert!}\NormalTok{(}\ConstantTok{true}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{3} \NormalTok{+ }\DecValTok{2}\NormalTok{);}

\CommentTok{// nope :(}

\PreprocessorTok{assert!}\NormalTok{(}\DecValTok{5} \NormalTok{< }\DecValTok{3}\NormalTok{);}
\PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{try!}\label{try}

\texttt{try!} is used for error handling. It takes something that can
return a \texttt{Result\textless{}T,\ E\textgreater{}}, and gives
\texttt{T} if it's a \texttt{Ok\textless{}T\textgreater{}}, and
\texttt{return}s with the \texttt{Err(E)} if it's that. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}

\KeywordTok{fn} \NormalTok{foo() -> std::io::}\DataTypeTok{Result}\NormalTok{<()> \{}
    \KeywordTok{let} \NormalTok{f = }\PreprocessorTok{try!}\NormalTok{(File::create(}\StringTok{"foo.txt"}\NormalTok{));}

    \ConstantTok{Ok}\NormalTok{(())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is cleaner than doing this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{use} \NormalTok{std::fs::File;}

\KeywordTok{fn} \NormalTok{foo() -> std::io::}\DataTypeTok{Result}\NormalTok{<()> \{}
    \KeywordTok{let} \NormalTok{f = File::create(}\StringTok{"foo.txt"}\NormalTok{);}

    \KeywordTok{let} \NormalTok{f = }\KeywordTok{match} \NormalTok{f \{}
        \ConstantTok{Ok}\NormalTok{(t) => t,}
        \ConstantTok{Err}\NormalTok{(e) => }\KeywordTok{return} \ConstantTok{Err}\NormalTok{(e),}
    \NormalTok{\};}

    \ConstantTok{Ok}\NormalTok{(())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{unreachable!}\label{unreachable}

This macro is used when you think some code should never execute:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \ConstantTok{false} \NormalTok{\{}
    \PreprocessorTok{unreachable!}\NormalTok{();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Sometimes, the compiler may make you have a different branch that you
know will never, ever run. In these cases, use this macro, so that if
you end up wrong, you'll get a \texttt{panic!} about it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: }\DataTypeTok{Option}\NormalTok{<}\DataTypeTok{i32}\NormalTok{> = }\ConstantTok{None}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \ConstantTok{Some}\NormalTok{(_) => }\PreprocessorTok{unreachable!}\NormalTok{(),}
    \ConstantTok{None} \NormalTok{=> }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"I know x is None!"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{unimplemented!}\label{unimplemented}

The \texttt{unimplemented!} macro can be used when you're trying to get
your functions to typecheck, and don't want to worry about writing out
the body of the function. One example of this situation is implementing
a trait with multiple required methods, where you want to tackle one at
a time. Define the others as \texttt{unimplemented!} until you're ready
to write them.

\subsection{Procedural macros}\label{procedural-macros}

If Rust's macro system can't do what you need, you may want to write a
\hyperref[sec--compiler-plugins]{compiler plugin} instead. Compared to
\texttt{macro\_rules!} macros, this is significantly more work, the
interfaces are much less stable, and bugs can be much harder to track
down. In exchange you get the flexibility of running arbitrary Rust code
within the compiler. Syntax extension plugins are sometimes called
`procedural macros' for this reason.

\hyperdef{}{sec--raw-pointers}{\section{Raw
Pointers}\label{sec--raw-pointers}}

Rust has a number of different smart pointer types in its standard
library, but there are two types that are extra-special. Much of Rust's
safety comes from compile-time checks, but raw pointers don't have such
guarantees, and are \hyperref[sec--unsafe]{unsafe} to use.

\texttt{*const\ T} and \texttt{*mut\ T} are called `raw pointers' in
Rust. Sometimes, when writing certain kinds of libraries, you'll need to
get around Rust's safety guarantees for some reason. In this case, you
can use raw pointers to implement your library, while exposing a safe
interface for your users. For example, \texttt{*} pointers are allowed
to alias, allowing them to be used to write shared-ownership types, and
even thread-safe shared memory types (the
\texttt{Rc\textless{}T\textgreater{}} and
\texttt{Arc\textless{}T\textgreater{}} types are both implemented
entirely in Rust).

Here are some things to remember about raw pointers that are different
than other pointer types. They:

\begin{itemize}
\tightlist
\item
  are not guaranteed to point to valid memory and are not even
  guaranteed to be non-null (unlike both \texttt{Box} and \texttt{\&});
\item
  do not have any automatic clean-up, unlike \texttt{Box}, and so
  require manual resource management;
\item
  are plain-old-data, that is, they don't move ownership, again unlike
  \texttt{Box}, hence the Rust compiler cannot protect against bugs like
  use-after-free;
\item
  lack any form of lifetimes, unlike \texttt{\&}, and so the compiler
  cannot reason about dangling pointers; and
\item
  have no guarantees about aliasing or mutability other than mutation
  not being allowed directly through a \texttt{*const\ T}.
\end{itemize}

\subsection{Basics}\label{basics}

Creating a raw pointer is perfectly safe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{raw = &x }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{i32}\NormalTok{;}

\KeywordTok{let} \KeywordTok{mut} \NormalTok{y = }\DecValTok{10}\NormalTok{;}
\KeywordTok{let} \NormalTok{raw_mut = &}\KeywordTok{mut} \NormalTok{y }\KeywordTok{as} \NormalTok{*}\KeywordTok{mut} \DataTypeTok{i32}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

However, dereferencing one is not. This won't work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{raw = &x }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{i32}\NormalTok{;}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"raw points at \{\}"}\NormalTok{, *raw);}
\end{Highlighting}
\end{Shaded}

It gives this error:

\begin{verbatim}
error: dereference of raw pointer requires unsafe function or block [E0133]
     println!("raw points at {}", *raw);
                                  ^~~~
\end{verbatim}

When you dereference a raw pointer, you're taking responsibility that
it's not pointing somewhere that would be incorrect. As such, you need
\texttt{unsafe}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5}\NormalTok{;}
\KeywordTok{let} \NormalTok{raw = &x }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{i32}\NormalTok{;}

\KeywordTok{let} \NormalTok{points_at = }\KeywordTok{unsafe} \NormalTok{\{ *raw \};}

\PreprocessorTok{println!}\NormalTok{(}\StringTok{"raw points at \{\}"}\NormalTok{, points_at);}
\end{Highlighting}
\end{Shaded}

For more operations on raw pointers, see
\href{http://doc.rust-lang.org/std/primitive.pointer.html}{their API
documentation}.

\subsection{FFI}\label{ffi}

Raw pointers are useful for FFI: Rust's \texttt{*const\ T} and
\texttt{*mut\ T} are similar to C's \texttt{const\ T*} and \texttt{T*},
respectively. For more about this use, consult the
\hyperref[sec--ffi]{FFI chapter}.

\subsection{References and raw
pointers}\label{references-and-raw-pointers}

At runtime, a raw pointer \texttt{*} and a reference pointing to the
same piece of data have an identical representation. In fact, an
\texttt{\&T} reference will implicitly coerce to an \texttt{*const\ T}
raw pointer in safe code and similarly for the \texttt{mut} variants
(both coercions can be performed explicitly with, respectively,
\texttt{value\ as\ *const\ T} and \texttt{value\ as\ *mut\ T}).

Going the opposite direction, from \texttt{*const} to a reference
\texttt{\&}, is not safe. A \texttt{\&T} is always valid, and so, at a
minimum, the raw pointer \texttt{*const\ T} has to point to a valid
instance of type \texttt{T}. Furthermore, the resulting pointer must
satisfy the aliasing and mutability laws of references. The compiler
assumes these properties are true for any references, no matter how they
are created, and so any conversion from raw pointers is asserting that
they hold. The programmer \emph{must} guarantee this.

The recommended method for the conversion is

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{i: }\DataTypeTok{u32} \NormalTok{= }\DecValTok{1}\NormalTok{;}

\CommentTok{// explicit cast}
\KeywordTok{let} \NormalTok{p_imm: *}\KeywordTok{const} \DataTypeTok{u32} \NormalTok{= &i }\KeywordTok{as} \NormalTok{*}\KeywordTok{const} \DataTypeTok{u32}\NormalTok{;}
\KeywordTok{let} \KeywordTok{mut} \NormalTok{m: }\DataTypeTok{u32} \NormalTok{= }\DecValTok{2}\NormalTok{;}

\CommentTok{// implicit coercion}
\KeywordTok{let} \NormalTok{p_mut: *}\KeywordTok{mut} \DataTypeTok{u32} \NormalTok{= &}\KeywordTok{mut} \NormalTok{m;}

\KeywordTok{unsafe} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{ref_imm: &}\DataTypeTok{u32} \NormalTok{= &*p_imm;}
    \KeywordTok{let} \NormalTok{ref_mut: &}\KeywordTok{mut} \DataTypeTok{u32} \NormalTok{= &}\KeywordTok{mut} \NormalTok{*p_mut;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{\&*x} dereferencing style is preferred to using a
\texttt{transmute}. The latter is far more powerful than necessary, and
the more restricted operation is harder to use incorrectly; for example,
it requires that \texttt{x} is a pointer (unlike \texttt{transmute}).

\hyperdef{}{sec--unsafe}{\section{\texorpdfstring{\texttt{unsafe}}{unsafe}}\label{sec--unsafe}}

Rust's main draw is its powerful static guarantees about behavior. But
safety checks are conservative by nature: there are some programs that
are actually safe, but the compiler is not able to verify this is true.
To write these kinds of programs, we need to tell the compiler to relax
its restrictions a bit. For this, Rust has a keyword, \texttt{unsafe}.
Code using \texttt{unsafe} has less restrictions than normal code does.

Let's go over the syntax, and then we'll talk semantics. \texttt{unsafe}
is used in four contexts. The first one is to mark a function as unsafe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unsafe} \KeywordTok{fn} \NormalTok{danger_will_robinson() \{}
    \CommentTok{// scary stuff}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All functions called from \hyperref[sec--ffi]{FFI} must be marked as
\texttt{unsafe}, for example. The second use of \texttt{unsafe} is an
unsafe block:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unsafe} \NormalTok{\{}
    \CommentTok{// scary stuff}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The third is for unsafe traits:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unsafe} \KeywordTok{trait} \NormalTok{Scary \{ \}}
\end{Highlighting}
\end{Shaded}

And the fourth is for \texttt{impl}ementing one of those traits:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unsafe} \KeywordTok{impl} \NormalTok{Scary }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{\}}
\end{Highlighting}
\end{Shaded}

It's important to be able to explicitly delineate code that may have
bugs that cause big problems. If a Rust program segfaults, you can be
sure it's somewhere in the sections marked \texttt{unsafe}.

\subsection{\texorpdfstring{What does `safe'
mean?}{What does safe mean?}}\label{what-does-safe-mean}

Safe, in the context of Rust, means `doesn't do anything unsafe'. It's
also important to know that there are certain behaviors that are
probably not desirable in your code, but are expressly \emph{not}
unsafe:

\begin{itemize}
\tightlist
\item
  Deadlocks
\item
  Leaks of memory or other resources
\item
  Exiting without calling destructors
\item
  Integer overflow
\end{itemize}

Rust cannot prevent all kinds of software problems. Buggy code can and
will be written in Rust. These things aren't great, but they don't
qualify as \texttt{unsafe} specifically.

In addition, the following are all undefined behaviors in Rust, and must
be avoided, even when writing \texttt{unsafe} code:

\begin{itemize}
\tightlist
\item
  Data races
\item
  Dereferencing a null/dangling raw pointer
\item
  Reads of
  \href{http://llvm.org/docs/LangRef.html\#undefined-values}{undef}
  (uninitialized) memory
\item
  Breaking the
  \href{http://llvm.org/docs/LangRef.html\#pointer-aliasing-rules}{pointer
  aliasing rules} with raw pointers.
\item
  \texttt{\&mut\ T} and \texttt{\&T} follow LLVM's scoped
  \href{http://llvm.org/docs/LangRef.html\#noalias}{noalias} model,
  except if the \texttt{\&T} contains an
  \texttt{UnsafeCell\textless{}U\textgreater{}}. Unsafe code must not
  violate these aliasing guarantees.
\item
  Mutating an immutable value/reference without
  \texttt{UnsafeCell\textless{}U\textgreater{}}
\item
  Invoking undefined behavior via compiler intrinsics:
\item
  Indexing outside of the bounds of an object with
  \texttt{std::ptr::offset} (\texttt{offset} intrinsic), with the
  exception of one byte past the end which is permitted.
\item
  Using \texttt{std::ptr::copy\_nonoverlapping\_memory}
  (\texttt{memcpy32}/\texttt{memcpy64} intrinsics) on overlapping
  buffers
\item
  Invalid values in primitive types, even in private fields/locals:
\item
  Null/dangling references or boxes
\item
  A value other than \texttt{false} (0) or \texttt{true} (1) in a
  \texttt{bool}
\item
  A discriminant in an \texttt{enum} not included in its type definition
\item
  A value in a \texttt{char} which is a surrogate or above
  \texttt{char::MAX}
\item
  Non-UTF-8 byte sequences in a \texttt{str}
\item
  Unwinding into Rust from foreign code or unwinding from Rust into
  foreign code.
\end{itemize}

\subsection{Unsafe Superpowers}\label{unsafe-superpowers}

In both unsafe functions and unsafe blocks, Rust will let you do three
things that you normally can not do. Just three. Here they are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Access or update a \hyperref[static]{static mutable variable}.
\item
  Dereference a raw pointer.
\item
  Call unsafe functions. This is the most powerful ability.
\end{enumerate}

That's it. It's important that \texttt{unsafe} does not, for example,
`turn off the borrow checker'. Adding \texttt{unsafe} to some random
Rust code doesn't change its semantics, it won't just start accepting
anything. But it will let you write things that \emph{do} break some of
the rules.

You will also encounter the \texttt{unsafe} keyword when writing
bindings to foreign (non-Rust) interfaces. You're encouraged to write a
safe, native Rust interface around the methods provided by the library.

Let's go over the basic three abilities listed, in order.

\subsubsection{\texorpdfstring{Access or update a
\texttt{static\ mut}}{Access or update a static mut}}\label{access-or-update-a-static-mut}

Rust has a feature called `\texttt{static\ mut}' which allows for
mutable global state. Doing so can cause a data race, and as such is
inherently not safe. For more details, see the \hyperref[static]{static}
section of the book.

\subsubsection{Dereference a raw
pointer}\label{dereference-a-raw-pointer}

Raw pointers let you do arbitrary pointer arithmetic, and can cause a
number of different memory safety and security issues. In some senses,
the ability to dereference an arbitrary pointer is one of the most
dangerous things you can do. For more on raw pointers, see
\hyperref[sec--raw-pointers]{their section of the book}.

\subsubsection{Call unsafe functions}\label{call-unsafe-functions}

This last ability works with both aspects of \texttt{unsafe}: you can
only call functions marked \texttt{unsafe} from inside an unsafe block.

This ability is powerful and varied. Rust exposes some
\hyperref[sec--intrinsics]{compiler intrinsics} as unsafe functions, and
some unsafe functions bypass safety checks, trading safety for speed.

I'll repeat again: even though you \emph{can} do arbitrary things in
unsafe blocks and functions doesn't mean you should. The compiler will
act as though you're upholding its invariants, so be careful!

\hyperdef{}{sec--nightly-rust}{\chapter{Nightly
Rust}\label{sec--nightly-rust}}

Rust provides three distribution channels for Rust: nightly, beta, and
stable. Unstable features are only available on nightly Rust. For more
details on this process, see
`\href{http://blog.rust-lang.org/2014/10/30/Stability.html}{Stability as
a deliverable}'.

To install nightly Rust, you can use \texttt{rustup.sh}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{curl} \NormalTok{-s https://static.rust-lang.org/rustup.sh }\KeywordTok{|} \KeywordTok{sh} \NormalTok{-s -- --channel=nightly}
\end{Highlighting}
\end{Shaded}

If you're concerned about the
\href{http://curlpipesh.tumblr.com}{potential insecurity} of using
\texttt{curl\ \textbar{}\ sh}, please keep reading and see our
disclaimer below. And feel free to use a two-step version of the
installation and examine our installation script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{curl} \NormalTok{-f -L https://static.rust-lang.org/rustup.sh -O}
\NormalTok{$ }\KeywordTok{sh} \NormalTok{rustup.sh --channel=nightly}
\end{Highlighting}
\end{Shaded}

If you're on Windows, please download either the
\href{https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.msi}{32-bit
installer} or the
\href{https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi}{64-bit
installer} and run it.

\subsubsection{Uninstalling}\label{uninstalling-1}

If you decide you don't want Rust anymore, we'll be a bit sad, but
that's okay. Not every programming language is great for everyone. Just
run the uninstall script:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{sudo} \NormalTok{/usr/local/lib/rustlib/uninstall.sh}
\end{Highlighting}
\end{Shaded}

If you used the Windows installer, just re-run the \texttt{.msi} and it
will give you an uninstall option.

Some people, and somewhat rightfully so, get very upset when we tell you
to \texttt{curl\ \textbar{}\ sh}. Basically, when you do this, you are
trusting that the good people who maintain Rust aren't going to hack
your computer and do bad things. That's a good instinct! If you're one
of those people, please check out the documentation on
\href{https://github.com/rust-lang/rust\#building-from-source}{building
Rust from Source}, or \href{https://www.rust-lang.org/install.html}{the
official binary downloads}.

Oh, we should also mention the officially supported platforms:

\begin{itemize}
\tightlist
\item
  Windows (7, 8, Server 2008 R2)
\item
  Linux (2.6.18 or later, various distributions), x86 and x86-64
\item
  OSX 10.7 (Lion) or greater, x86 and x86-64
\end{itemize}

We extensively test Rust on these platforms, and a few others, too, like
Android. But these are the ones most likely to work, as they have the
most testing.

Finally, a comment about Windows. Rust considers Windows to be a
first-class platform upon release, but if we're honest, the Windows
experience isn't as integrated as the Linux/OS X experience is. We're
working on it! If anything does not work, it is a bug. Please let us
know if that happens. Each and every commit is tested against Windows
just like any other platform.

If you've got Rust installed, you can open up a shell, and type this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{rustc} \NormalTok{--version}
\end{Highlighting}
\end{Shaded}

You should see the version number, commit hash, commit date and build
date:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rustc} \NormalTok{1.0.0-nightly (f11f3e7ba 2015-01-04) }\KeywordTok{(built} \NormalTok{2015-01-06}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

If you did, Rust has been installed successfully! Congrats!

This installer also installs a copy of the documentation locally, so you
can read it offline. On UNIX systems, \texttt{/usr/local/share/doc/rust}
is the location. On Windows, it's in a \texttt{share/doc} directory,
inside wherever you installed Rust to.

If not, there are a number of places where you can get help. The easiest
is \href{irc://irc.mozilla.org/\#rust}{the \#rust IRC channel on
irc.mozilla.org}, which you can access through
\href{http://chat.mibbit.com/?server=irc.mozilla.org\&channel=\%23rust}{Mibbit}.
Click that link, and you'll be chatting with other Rustaceans (a silly
nickname we call ourselves), and we can help you out. Other great
resources include \href{https://users.rust-lang.org/}{the user's forum},
and \href{http://stackoverflow.com/questions/tagged/rust}{Stack
Overflow}.

\hyperdef{}{sec--compiler-plugins}{\section{Compiler
Plugins}\label{sec--compiler-plugins}}

\subsection{Introduction}\label{introduction-2}

\texttt{rustc} can load compiler plugins, which are user-provided
libraries that extend the compiler's behavior with new syntax
extensions, lint checks, etc.

A plugin is a dynamic library crate with a designated \emph{registrar}
function that registers extensions with \texttt{rustc}. Other crates can
load these extensions using the crate attribute
\texttt{\#!{[}plugin(...){]}}. See the
\href{http://doc.rust-lang.org/rustc/plugin/index.html}{\texttt{rustc::plugin}}
documentation for more about the mechanics of defining and loading a
plugin.

If present, arguments passed as
\texttt{\#!{[}plugin(foo(...\ args\ ...)){]}} are not interpreted by
rustc itself. They are provided to the plugin through the
\texttt{Registry}'s
\href{http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html\#method.args}{\texttt{args}
method}.

In the vast majority of cases, a plugin should \emph{only} be used
through \texttt{\#!{[}plugin{]}} and not through an
\texttt{extern\ crate} item. Linking a plugin would pull in all of
libsyntax and librustc as dependencies of your crate. This is generally
unwanted unless you are building another plugin. The
\texttt{plugin\_as\_library} lint checks these guidelines.

The usual practice is to put compiler plugins in their own crate,
separate from any \texttt{macro\_rules!} macros or ordinary Rust code
meant to be used by consumers of a library.

\subsection{Syntax extensions}\label{syntax-extensions}

Plugins can extend Rust's syntax in various ways. One kind of syntax
extension is the procedural macro. These are invoked the same way as
\hyperref[sec--macros]{ordinary macros}, but the expansion is performed
by arbitrary Rust code that manipulates
\href{http://doc.rust-lang.org/syntax/ast/index.html}{syntax trees} at
compile time.

Let's write a plugin
\href{https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs}{\texttt{roman\_numerals.rs}}
that implements Roman numeral integer literals.

\begin{verbatim}
#![crate_type="dylib"]
#![feature(plugin_registrar, rustc_private)]

extern crate syntax;
extern crate rustc;

use syntax::codemap::Span;
use syntax::parse::token;
use syntax::ast::{TokenTree, TtToken};
use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
use syntax::ext::build::AstBuilder;  // trait for expr_usize
use rustc::plugin::Registry;

fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])
        -> Box<MacResult + 'static> {

    static NUMERALS: &'static [(&'static str, u32)] = &[
        ("M", 1000), ("CM", 900), ("D", 500), ("CD", 400),
        ("C",  100), ("XC",  90), ("L",  50), ("XL",  40),
        ("X",   10), ("IX",   9), ("V",   5), ("IV",   4),
        ("I",    1)];

    let text = match args {
        [TtToken(_, token::Ident(s, _))] => s.to_string(),
        _ => {
            cx.span_err(sp, "argument should be a single identifier");
            return DummyResult::any(sp);
        }
    };

    let mut text = &*text;
    let mut total = 0;
    while !text.is_empty() {
        match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {
            Some(&(rn, val)) => {
                total += val;
                text = &text[rn.len()..];
            }
            None => {
                cx.span_err(sp, "invalid Roman numeral");
                return DummyResult::any(sp);
            }
        }
    }

    MacEager::expr(cx.expr_u32(sp, total))
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &mut Registry) {
    reg.register_macro("rn", expand_rn);
}
\end{verbatim}

Then we can use \texttt{rn!()} like any other macro:

\begin{verbatim}
#![feature(plugin)]
#![plugin(roman_numerals)]

fn main() {
    assert_eq!(rn!(MMXV), 2015);
}
\end{verbatim}

The advantages over a simple \texttt{fn(\&str)\ -\textgreater{}\ u32}
are:

\begin{itemize}
\tightlist
\item
  The (arbitrarily complex) conversion is done at compile time.
\item
  Input validation is also performed at compile time.
\item
  It can be extended to allow use in patterns, which effectively gives a
  way to define new literal syntax for any data type.
\end{itemize}

In addition to procedural macros, you can define new
\href{http://doc.rust-lang.org/reference.html\#derive}{\texttt{derive}}-like
attributes and other kinds of extensions. See
\href{http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html\#method.register_syntax_extension}{\texttt{Registry::register\_syntax\_extension}}
and the
\href{https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html}{\texttt{SyntaxExtension}
enum}. For a more involved macro example, see
\href{https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs}{\texttt{regex\_macros}}.

\subsubsection{Tips and tricks}\label{tips-and-tricks}

Some of the \hyperref[debugging-macro-code]{macro debugging tips} are
applicable.

You can use
\href{http://doc.rust-lang.org/syntax/parse/index.html}{\texttt{syntax::parse}}
to turn token trees into higher-level syntax elements like expressions:

\begin{verbatim}
fn expand_foo(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])
        -> Box<MacResult+'static> {

    let mut parser = cx.new_parser_from_tts(args);

    let expr: P<Expr> = parser.parse_expr();
\end{verbatim}

Looking through
\href{https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs}{\texttt{libsyntax}
parser code} will give you a feel for how the parsing infrastructure
works.

Keep the
\href{http://doc.rust-lang.org/syntax/codemap/struct.Span.html}{\texttt{Span}s}
of everything you parse, for better error reporting. You can wrap
\href{http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html}{\texttt{Spanned}}
around your custom data structures.

Calling
\href{http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html\#method.span_fatal}{\texttt{ExtCtxt::span\_fatal}}
will immediately abort compilation. It's better to instead call
\href{http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html\#method.span_err}{\texttt{ExtCtxt::span\_err}}
and return
\href{http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html}{\texttt{DummyResult}},
so that the compiler can continue and find further errors.

To print syntax fragments for debugging, you can use
\href{http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html\#method.span_note}{\texttt{span\_note}}
together with
\href{https://doc.rust-lang.org/syntax/print/pprust/index.html\#functions}{\texttt{syntax::print::pprust::*\_to\_string}}.

The example above produced an integer literal using
\href{http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html\#tymethod.expr_usize}{\texttt{AstBuilder::expr\_usize}}.
As an alternative to the \texttt{AstBuilder} trait, \texttt{libsyntax}
provides a set of
\href{http://doc.rust-lang.org/syntax/ext/quote/index.html}{quasiquote
macros}. They are undocumented and very rough around the edges. However,
the implementation may be a good starting point for an improved
quasiquote as an ordinary plugin library.

\subsection{Lint plugins}\label{lint-plugins}

Plugins can extend
\href{http://doc.rust-lang.org/reference.html\#lint-check-attributes}{Rust's
lint infrastructure} with additional checks for code style, safety, etc.
You can see
\href{https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs}{\texttt{src/test/auxiliary/lint\_plugin\_test.rs}}
for a full example, the core of which is reproduced here:

\begin{verbatim}
declare_lint!(TEST_LINT, Warn,
              "Warn about items named 'lintme'");

struct Pass;

impl LintPass for Pass {
    fn get_lints(&self) -> LintArray {
        lint_array!(TEST_LINT)
    }

    fn check_item(&mut self, cx: &Context, it: &ast::Item) {
        if it.ident.name == "lintme" {
            cx.span_lint(TEST_LINT, it.span, "item is named 'lintme'");
        }
    }
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &mut Registry) {
    reg.register_lint_pass(box Pass as LintPassObject);
}
\end{verbatim}

Then code like

\begin{verbatim}
#![plugin(lint_plugin_test)]

fn lintme() { }
\end{verbatim}

will produce a compiler warning:

\begin{verbatim}
foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
\end{verbatim}

The components of a lint plugin are:

\begin{itemize}
\item
  one or more \texttt{declare\_lint!} invocations, which define static
  \href{http://doc.rust-lang.org/rustc/lint/struct.Lint.html}{\texttt{Lint}}
  structs;
\item
  a struct holding any state needed by the lint pass (here, none);
\item
  a
  \href{http://doc.rust-lang.org/rustc/lint/trait.LintPass.html}{\texttt{LintPass}}
  implementation defining how to check each syntax element. A single
  \texttt{LintPass} may call \texttt{span\_lint} for several different
  \texttt{Lint}s, but should register them all through the
  \texttt{get\_lints} method.
\end{itemize}

Lint passes are syntax traversals, but they run at a late stage of
compilation where type information is available. \texttt{rustc}'s
\href{https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs}{built-in
lints} mostly use the same infrastructure as lint plugins, and provide
examples of how to access type information.

Lints defined by plugins are controlled by the usual
\href{http://doc.rust-lang.org/reference.html\#lint-check-attributes}{attributes
and compiler flags}, e.g. \texttt{\#{[}allow(test\_lint){]}} or
\texttt{-A\ test-lint}. These identifiers are derived from the first
argument to \texttt{declare\_lint!}, with appropriate case and
punctuation conversion.

You can run \texttt{rustc\ -W\ help\ foo.rs} to see a list of lints
known to \texttt{rustc}, including those provided by plugins loaded by
\texttt{foo.rs}.

\section{Inline Assembly}\label{sec--inline-assembly}

For extremely low-level manipulations and performance reasons, one might
wish to control the CPU directly. Rust supports using inline assembly to
do this via the \texttt{asm!} macro. The syntax roughly matches that of
GCC \& Clang:

\begin{verbatim}
asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
\end{verbatim}

Any use of \texttt{asm} is feature gated (requires
\texttt{\#!{[}feature(asm){]}} on the crate to allow) and of course
requires an \texttt{unsafe} block.

\begin{quote}
\textbf{Note}: the examples here are given in x86/x86-64 assembly, but
all platforms are supported.
\end{quote}

\subsubsection{Assembly template}\label{assembly-template}

The \texttt{assembly\ template} is the only required parameter and must
be a literal string (i.e. \texttt{""})

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{asm}\AttributeTok{)]}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{any}\AttributeTok{(}\NormalTok{target_arch }\AttributeTok{=} \StringTok{"x86"}\AttributeTok{,} \NormalTok{target_arch }\AttributeTok{=} \StringTok{"x86_64"}\AttributeTok{))]}
\KeywordTok{fn} \NormalTok{foo() \{}
    \KeywordTok{unsafe} \NormalTok{\{}
        \PreprocessorTok{asm!}\NormalTok{(}\StringTok{"NOP"}\NormalTok{);}
    \NormalTok{\}}
\NormalTok{\}}

\CommentTok{// other platforms}
\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{not}\AttributeTok{(}\NormalTok{any}\AttributeTok{(}\NormalTok{target_arch }\AttributeTok{=} \StringTok{"x86"}\AttributeTok{,} \NormalTok{target_arch }\AttributeTok{=} \StringTok{"x86_64"}\AttributeTok{)))]}
\KeywordTok{fn} \NormalTok{foo() \{ }\CommentTok{/* ... */} \NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \CommentTok{// ...}
    \NormalTok{foo();}
    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(The \texttt{feature(asm)} and \texttt{\#{[}cfg{]}}s are omitted from
now on.)

Output operands, input operands, clobbers and options are all optional
but you must add the right number of \texttt{:} if you skip them:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{asm!}\NormalTok{(}\StringTok{"xor %eax, %eax"}
    \NormalTok{:}
    \NormalTok{:}
    \NormalTok{: }\StringTok{"\{eax\}"}
   \NormalTok{);}
\end{Highlighting}
\end{Shaded}

Whitespace also doesn't matter:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{asm!}\NormalTok{(}\StringTok{"xor %eax, %eax"} \NormalTok{::: }\StringTok{"\{eax\}"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Operands}\label{operands}

Input and output operands follow the same format:
\texttt{:\ "constraints1"(expr1),\ "constraints2"(expr2),\ ..."}. Output
operand expressions must be mutable lvalues, or not yet assigned:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{add(a: }\DataTypeTok{i32}\NormalTok{, b: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{c: }\DataTypeTok{i32}\NormalTok{;}
    \KeywordTok{unsafe} \NormalTok{\{}
        \PreprocessorTok{asm!}\NormalTok{(}\StringTok{"add $2, $0"}
             \NormalTok{: }\StringTok{"=r"}\NormalTok{(c)}
             \NormalTok{: }\StringTok{"0"}\NormalTok{(a), }\StringTok{"r"}\NormalTok{(b)}
             \NormalTok{);}
    \NormalTok{\}}
    \NormalTok{c}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(add(}\DecValTok{3}\NormalTok{, }\DecValTok{14159}\NormalTok{), }\DecValTok{14162}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you would like to use real operands in this position, however, you
are required to put curly braces \texttt{\{\}} around the register that
you want, and you are required to put the specific size of the operand.
This is useful for very low level programming, where which register you
use is important:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{result: }\DataTypeTok{u8}\NormalTok{;}
\PreprocessorTok{asm!}\NormalTok{(}\StringTok{"in %dx, %al"} \NormalTok{: }\StringTok{"=\{al\}"}\NormalTok{(result) : }\StringTok{"\{dx\}"}\NormalTok{(port));}
\NormalTok{result}
\end{Highlighting}
\end{Shaded}

\subsubsection{Clobbers}\label{clobbers}

Some instructions modify registers which might otherwise have held
different values so we use the clobbers list to indicate to the compiler
not to assume any values loaded into those registers will stay valid.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Put the value 0x200 in eax}
\PreprocessorTok{asm!}\NormalTok{(}\StringTok{"mov $$0x200, %eax"} \NormalTok{: }\CommentTok{/* no outputs */} \NormalTok{: }\CommentTok{/* no inputs */} \NormalTok{: }\StringTok{"\{eax\}"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

Input and output registers need not be listed since that information is
already communicated by the given constraints. Otherwise, any other
registers used either implicitly or explicitly should be listed.

If the assembly changes the condition code register \texttt{cc} should
be specified as one of the clobbers. Similarly, if the assembly modifies
memory, \texttt{memory} should also be specified.

\subsubsection{Options}\label{options}

The last section, \texttt{options} is specific to Rust. The format is
comma separated literal strings (i.e. \texttt{:"foo",\ "bar",\ "baz"}).
It's used to specify some extra info about the inline assembly:

Current valid options are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \emph{volatile} - specifying this is analogous to
  \texttt{\_\_asm\_\_\ \_\_volatile\_\_\ (...)} in gcc/clang.
\item
  \emph{alignstack} - certain instructions expect the stack to be
  aligned a certain way (i.e.~SSE) and specifying this indicates to the
  compiler to insert its usual stack alignment code
\item
  \emph{intel} - use intel syntax instead of the default AT\&T.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{result: }\DataTypeTok{i32}\NormalTok{;}
\KeywordTok{unsafe} \NormalTok{\{}
   \PreprocessorTok{asm!}\NormalTok{(}\StringTok{"mov eax, 2"} \NormalTok{: }\StringTok{"=\{eax\}"}\NormalTok{(result) : : : }\StringTok{"intel"}\NormalTok{)}
\NormalTok{\}}
\PreprocessorTok{println!}\NormalTok{(}\StringTok{"eax is currently \{\}"}\NormalTok{, result);}
\end{Highlighting}
\end{Shaded}

\subsubsection{More Information}\label{more-information}

The current implementation of the \texttt{asm!} macro is a direct
binding to
\href{http://llvm.org/docs/LangRef.html\#inline-assembler-expressions}{LLVM's
inline assembler expressions}, so be sure to check out
\href{http://llvm.org/docs/LangRef.html\#inline-assembler-expressions}{their
documentation as well} for more information about clobbers, constraints,
etc.

\section{No stdlib}\label{sec--no-stdlib}

By default, \texttt{std} is linked to every Rust crate. In some
contexts, this is undesirable, and can be avoided with the
\texttt{\#!{[}no\_std{]}} attribute attached to the crate.

\begin{verbatim}
// a minimal library
#![crate_type="lib"]
#![feature(no_std)]
#![no_std]
# // fn main() {} tricked you, rustdoc!
\end{verbatim}

Obviously there's more to life than just libraries: one can use
\texttt{\#{[}no\_std{]}} with an executable, controlling the entry point
is possible in two ways: the \texttt{\#{[}start{]}} attribute, or
overriding the default shim for the C \texttt{main} function with your
own.

The function marked \texttt{\#{[}start{]}} is passed the command line
parameters in the same format as C:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{lang_items}\AttributeTok{,} \NormalTok{start}\AttributeTok{,} \NormalTok{no_std}\AttributeTok{,} \NormalTok{libc}\AttributeTok{)]}
\AttributeTok{#![}\NormalTok{no_std}\AttributeTok{]}

\CommentTok{// Pull in the system libc library for what crt0.o likely requires}
\KeywordTok{extern} \KeywordTok{crate} \NormalTok{libc;}

\CommentTok{// Entry point for this program}
\AttributeTok{#[}\NormalTok{start}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{start(_argc: }\DataTypeTok{isize}\NormalTok{, _argv: *}\KeywordTok{const} \NormalTok{*}\KeywordTok{const} \DataTypeTok{u8}\NormalTok{) -> }\DataTypeTok{isize} \NormalTok{\{}
    \DecValTok{0}
\NormalTok{\}}

\CommentTok{// These functions and traits are used by the compiler, but not}
\CommentTok{// for a bare-bones hello world. These are normally}
\CommentTok{// provided by libstd.}
\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"eh_personality"}\AttributeTok{]} \KeywordTok{extern} \KeywordTok{fn} \NormalTok{eh_personality() \{\}}
\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"panic_fmt"}\AttributeTok{]} \KeywordTok{fn} \NormalTok{panic_fmt() -> ! \{ }\KeywordTok{loop} \NormalTok{\{\} \}}
\end{Highlighting}
\end{Shaded}

To override the compiler-inserted \texttt{main} shim, one has to disable
it with \texttt{\#!{[}no\_main{]}} and then create the appropriate
symbol with the correct ABI and the correct name, which requires
overriding the compiler's name mangling too:

\begin{verbatim}
#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // ensure that this symbol is called `main` in the output
pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {
    0
}

#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "panic_fmt"] fn panic_fmt() -> ! { loop {} }
# #[lang = "eh_unwind_resume"] extern fn rust_eh_unwind_resume() {}
# // fn main() {} tricked you, rustdoc!
\end{verbatim}

The compiler currently makes a few assumptions about symbols which are
available in the executable to call. Normally these functions are
provided by the standard library, but without it you must define your
own.

The first of these two functions, \texttt{eh\_personality}, is used by
the failure mechanisms of the compiler. This is often mapped to GCC's
personality function (see the
\href{http://doc.rust-lang.org/std/rt/unwind/index.html}{libstd
implementation} for more information), but crates which do not trigger a
panic can be assured that this function is never called. The second
function, \texttt{panic\_fmt}, is also used by the failure mechanisms of
the compiler.

\subsubsection{Using libcore}\label{using-libcore}

\begin{quote}
\textbf{Note}: the core library's structure is unstable, and it is
recommended to use the standard library instead wherever possible.
\end{quote}

With the above techniques, we've got a bare-metal executable running
some Rust code. There is a good deal of functionality provided by the
standard library, however, that is necessary to be productive in Rust.
If the standard library is not sufficient, then
\href{http://doc.rust-lang.org/core/index.html}{libcore} is designed to
be used instead.

The core library has very few dependencies and is much more portable
than the standard library itself. Additionally, the core library has
most of the necessary functionality for writing idiomatic and effective
Rust code.

As an example, here is a program that will calculate the dot product of
two vectors provided from C, using idiomatic Rust practices.

\begin{verbatim}
#![feature(lang_items, start, no_std, core, libc)]
#![no_std]

# extern crate libc;
extern crate core;

use core::prelude::*;

use core::mem;

#[no_mangle]
pub extern fn dot_product(a: *const u32, a_len: u32,
                          b: *const u32, b_len: u32) -> u32 {
    use core::raw::Slice;

    // Convert the provided arrays into Rust slices.
    // The core::raw module guarantees that the Slice
    // structure has the same memory layout as a &[T]
    // slice.
    //
    // This is an unsafe operation because the compiler
    // cannot tell the pointers are valid.
    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {
        mem::transmute((
            Slice { data: a, len: a_len as usize },
            Slice { data: b, len: b_len as usize },
        ))
    };

    // Iterate over the slices, collecting the result
    let mut ret = 0;
    for (i, j) in a_slice.iter().zip(b_slice.iter()) {
        ret += (*i) * (*j);
    }
    return ret;
}

#[lang = "panic_fmt"]
extern fn panic_fmt(args: &core::fmt::Arguments,
                    file: &str,
                    line: u32) -> ! {
    loop {}
}

#[lang = "eh_personality"] extern fn eh_personality() {}
# #[lang = "eh_unwind_resume"] extern fn rust_eh_unwind_resume() {}
# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }
# fn main() {}
\end{verbatim}

Note that there is one extra lang item here which differs from the
examples above, \texttt{panic\_fmt}. This must be defined by consumers
of libcore because the core library declares panics, but it does not
define it. The \texttt{panic\_fmt} lang item is this crate's definition
of panic, and it must be guaranteed to never return.

As can be seen in this example, the core library is intended to provide
the power of Rust in all circumstances, regardless of platform
requirements. Further libraries, such as liballoc, add functionality to
libcore which make other platform-specific assumptions, but continue to
be more portable than the standard library itself.

\hyperdef{}{sec--intrinsics}{\section{Intrinsics}\label{sec--intrinsics}}

\begin{quote}
\textbf{Note}: intrinsics will forever have an unstable interface, it is
recommended to use the stable interfaces of libcore rather than
intrinsics directly.
\end{quote}

These are imported as if they were FFI functions, with the special
\texttt{rust-intrinsic} ABI. For example, if one was in a freestanding
context, but wished to be able to \texttt{transmute} between types, and
perform efficient pointer arithmetic, one would import those functions
via a declaration like

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{intrinsics}\AttributeTok{)]}

\KeywordTok{extern} \StringTok{"rust-intrinsic"} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{transmute<T, U>(x: T) -> U;}

    \KeywordTok{fn} \NormalTok{offset<T>(dst: *}\KeywordTok{const} \NormalTok{T, offset: }\DataTypeTok{isize}\NormalTok{) -> *}\KeywordTok{const} \NormalTok{T;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As with any other FFI functions, these are always \texttt{unsafe} to
call.

\section{Lang items}\label{sec--lang-items}

\begin{quote}
\textbf{Note}: lang items are often provided by crates in the Rust
distribution, and lang items themselves have an unstable interface. It
is recommended to use officially distributed crates instead of defining
your own lang items.
\end{quote}

The \texttt{rustc} compiler has certain pluggable operations, that is,
functionality that isn't hard-coded into the language, but is
implemented in libraries, with a special marker to tell the compiler it
exists. The marker is the attribute \texttt{\#{[}lang\ =\ "..."{]}} and
there are various different values of \texttt{...}, i.e.~various
different `lang items'.

For example, \texttt{Box} pointers require two lang items, one for
allocation and one for deallocation. A freestanding program that uses
the \texttt{Box} sugar for dynamic allocations via \texttt{malloc} and
\texttt{free}:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{lang_items}\AttributeTok{,} \NormalTok{box_syntax}\AttributeTok{,} \NormalTok{start}\AttributeTok{,} \NormalTok{no_std}\AttributeTok{,} \NormalTok{libc}\AttributeTok{)]}
\AttributeTok{#![}\NormalTok{no_std}\AttributeTok{]}

\KeywordTok{extern} \KeywordTok{crate} \NormalTok{libc;}

\KeywordTok{extern} \NormalTok{\{}
    \KeywordTok{fn} \NormalTok{abort() -> !;}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"owned_box"}\AttributeTok{]}
\KeywordTok{pub} \KeywordTok{struct} \DataTypeTok{Box}\NormalTok{<T>(*}\KeywordTok{mut} \NormalTok{T);}

\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"exchange_malloc"}\AttributeTok{]}
\KeywordTok{unsafe} \KeywordTok{fn} \NormalTok{allocate(size: }\DataTypeTok{usize}\NormalTok{, _align: }\DataTypeTok{usize}\NormalTok{) -> *}\KeywordTok{mut} \DataTypeTok{u8} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{p = libc::malloc(size }\KeywordTok{as} \NormalTok{libc::}\DataTypeTok{size_t}\NormalTok{) }\KeywordTok{as} \NormalTok{*}\KeywordTok{mut} \DataTypeTok{u8}\NormalTok{;}

    \CommentTok{// malloc failed}
    \KeywordTok{if} \NormalTok{p }\KeywordTok{as} \DataTypeTok{usize} \NormalTok{== }\DecValTok{0} \NormalTok{\{}
        \NormalTok{abort();}
    \NormalTok{\}}

    \NormalTok{p}
\NormalTok{\}}
\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"exchange_free"}\AttributeTok{]}
\KeywordTok{unsafe} \KeywordTok{fn} \NormalTok{deallocate(ptr: *}\KeywordTok{mut} \DataTypeTok{u8}\NormalTok{, _size: }\DataTypeTok{usize}\NormalTok{, _align: }\DataTypeTok{usize}\NormalTok{) \{}
    \NormalTok{libc::free(ptr }\KeywordTok{as} \NormalTok{*}\KeywordTok{mut} \NormalTok{libc::}\DataTypeTok{c_void}\NormalTok{)}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{start}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{main(argc: }\DataTypeTok{isize}\NormalTok{, argv: *}\KeywordTok{const} \NormalTok{*}\KeywordTok{const} \DataTypeTok{u8}\NormalTok{) -> }\DataTypeTok{isize} \NormalTok{\{}
    \KeywordTok{let} \NormalTok{x = }\KeywordTok{box} \DecValTok{1}\NormalTok{;}

    \DecValTok{0}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"eh_personality"}\AttributeTok{]} \KeywordTok{extern} \KeywordTok{fn} \NormalTok{eh_personality() \{\}}
\AttributeTok{#[}\NormalTok{lang }\AttributeTok{=} \StringTok{"panic_fmt"}\AttributeTok{]} \KeywordTok{fn} \NormalTok{panic_fmt() -> ! \{ }\KeywordTok{loop} \NormalTok{\{\} \}}
\end{Highlighting}
\end{Shaded}

Note the use of \texttt{abort}: the \texttt{exchange\_malloc} lang item
is assumed to return a valid pointer, and so needs to do the check
internally.

Other features provided by lang items include:

\begin{itemize}
\tightlist
\item
  overloadable operators via traits: the traits corresponding to the
  \texttt{==}, \texttt{\textless{}}, dereferencing (\texttt{*}) and
  \texttt{+} (etc.) operators are all marked with lang items; those
  specific four are \texttt{eq}, \texttt{ord}, \texttt{deref}, and
  \texttt{add} respectively.
\item
  stack unwinding and general failure; the \texttt{eh\_personality},
  \texttt{fail} and \texttt{fail\_bounds\_checks} lang items.
\item
  the traits in \texttt{std::marker} used to indicate types of various
  kinds; lang items \texttt{send}, \texttt{sync} and \texttt{copy}.
\item
  the marker types and variance indicators found in
  \texttt{std::marker}; lang items \texttt{covariant\_type},
  \texttt{contravariant\_lifetime}, etc.
\end{itemize}

Lang items are loaded lazily by the compiler; e.g.~if one never uses
\texttt{Box} then there is no need to define functions for
\texttt{exchange\_malloc} and \texttt{exchange\_free}. \texttt{rustc}
will emit an error when an item is needed but not found in the current
crate or any that it depends on.

\section{Advanced linking}\label{sec--advanced-linking}

The common cases of linking with Rust have been covered earlier in this
book, but supporting the range of linking possibilities made available
by other languages is important for Rust to achieve seamless interaction
with native libraries.

\subsection{Link args}\label{link-args}

There is one other way to tell \texttt{rustc} how to customize linking,
and that is via the \texttt{link\_args} attribute. This attribute is
applied to \texttt{extern} blocks and specifies raw flags which need to
get passed to the linker when producing an artifact. An example usage
would be:

\begin{verbatim}
#![feature(link_args)]

#[link_args = "-foo -bar -baz"]
extern {}
# fn main() {}
\end{verbatim}

Note that this feature is currently hidden behind the
\texttt{feature(link\_args)} gate because this is not a sanctioned way
of performing linking. Right now \texttt{rustc} shells out to the system
linker (\texttt{gcc} on most systems, \texttt{link.exe} on MSVC), so it
makes sense to provide extra command line arguments, but this will not
always be the case. In the future \texttt{rustc} may use LLVM directly
to link native libraries, in which case \texttt{link\_args} will have no
meaning. You can achieve the same effect as the \texttt{link-args}
attribute with the \texttt{-C\ link-args} argument to \texttt{rustc}.

It is highly recommended to \emph{not} use this attribute, and rather
use the more formal \texttt{\#{[}link(...){]}} attribute on
\texttt{extern} blocks instead.

\subsection{Static linking}\label{static-linking}

Static linking refers to the process of creating output that contains
all required libraries and so doesn't need libraries installed on every
system where you want to use your compiled project. Pure-Rust
dependencies are statically linked by default so you can use created
binaries and libraries without installing Rust everywhere. By contrast,
native libraries (e.g. \texttt{libc} and \texttt{libm}) are usually
dynamically linked, but it is possible to change this and statically
link them as well.

Linking is a very platform-dependent topic, and static linking may not
even be possible on some platforms! This section assumes some basic
familiarity with linking on your platform of choice.

\subsubsection{Linux}\label{linux}

By default, all Rust programs on Linux will link to the system
\texttt{libc} along with a number of other libraries. Let's look at an
example on a 64-bit Linux machine with GCC and \texttt{glibc} (by far
the most common \texttt{libc} on Linux):

\begin{verbatim}
$ cat example.rs
fn main() {}
$ rustc example.rs
$ ldd example
        linux-vdso.so.1 =>  (0x00007ffd565fd000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)
\end{verbatim}

Dynamic linking on Linux can be undesirable if you wish to use new
library features on old systems or target systems which do not have the
required dependencies for your program to run.

Static linking is supported via an alternative \texttt{libc},
\texttt{musl}. You can compile your own version of Rust with
\texttt{musl} enabled and install it into a custom directory with the
instructions below:

\begin{verbatim}
$ mkdir musldist
$ PREFIX=$(pwd)/musldist
$
$ # Build musl
$ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
[...]
$ tar xf musl-1.1.10.tar.gz
$ cd musl-1.1.10/
musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
[...]
musl-1.1.10 $ make
[...]
musl-1.1.10 $ make install
[...]
musl-1.1.10 $ cd ..
$ du -h musldist/lib/libc.a
2.2M    musldist/lib/libc.a
$
$ # Build libunwind.a
$ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz
$ tar xf llvm-3.6.1.src.tar.xz
$ cd llvm-3.6.1.src/projects/
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ lib
‚Ü≥ cxxabi
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ lib
‚Ü≥ unwind
llvm-3.6.1.src/projects $ sed -i 's#^\(include_directories\).*$#\0\n\1(../libcxxabi/in
‚Ü≥ clude)#' libunwind/CMakeLists.txt
llvm-3.6.1.src/projects $ mkdir libunwind/build
llvm-3.6.1.src/projects $ cd libunwind/build
llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABL
‚Ü≥ E_SHARED=0 ..
llvm-3.6.1.src/projects/libunwind/build $ make
llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../
$ du -h musldist/lib/libunwind.a
164K    musldist/lib/libunwind.a
$
$ # Build musl-enabled rust
$ git clone https://github.com/rust-lang/rust.git muslrust
$ cd muslrust
muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix
‚Ü≥ =$PREFIX
muslrust $ make
muslrust $ make install
muslrust $ cd ..
$ du -h musldist/bin/rustc
12K     musldist/bin/rustc
\end{verbatim}

You now have a build of a \texttt{musl}-enabled Rust! Because we've
installed it to a custom prefix we need to make sure our system can find
the binaries and appropriate libraries when we try and run it:

\begin{verbatim}
$ export PATH=$PREFIX/bin:$PATH
$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH
\end{verbatim}

Let's try it out!

\begin{verbatim}
$ echo 'fn main() { println!("hi!"); panic!("failed"); }' > example.rs
$ rustc --target=x86_64-unknown-linux-musl example.rs
$ ldd example
        not a dynamic executable
$ ./example
hi!
thread '<main>' panicked at 'failed', example.rs:1
\end{verbatim}

Success! This binary can be copied to almost any Linux machine with the
same machine architecture and run without issues.

\texttt{cargo\ build} also permits the \texttt{-\/-target} option so you
should be able to build your crates as normal. However, you may need to
recompile your native libraries against \texttt{musl} before they can be
linked against.

\section{Benchmark Tests}\label{sec--benchmark-tests}

Rust supports benchmark tests, which can test the performance of your
code. Let's make our \texttt{src/lib.rs} look like this (comments
elided):

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}

\KeywordTok{extern} \KeywordTok{crate} \NormalTok{test;}

\KeywordTok{pub} \KeywordTok{fn} \NormalTok{add_two(a: }\DataTypeTok{i32}\NormalTok{) -> }\DataTypeTok{i32} \NormalTok{\{}
    \NormalTok{a + }\DecValTok{2}
\NormalTok{\}}

\AttributeTok{#[}\NormalTok{cfg}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}
\KeywordTok{mod} \NormalTok{tests \{}
    \KeywordTok{use} \KeywordTok{super}\NormalTok{::*;}
    \KeywordTok{use} \NormalTok{test::Bencher;}

    \AttributeTok{#[}\NormalTok{test}\AttributeTok{]}
    \KeywordTok{fn} \NormalTok{it_works() \{}
        \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{4}\NormalTok{, add_two(}\DecValTok{2}\NormalTok{));}
    \NormalTok{\}}

    \AttributeTok{#[}\NormalTok{bench}\AttributeTok{]}
    \KeywordTok{fn} \NormalTok{bench_add_two(b: &}\KeywordTok{mut} \NormalTok{Bencher) \{}
        \NormalTok{b.iter(|| add_two(}\DecValTok{2}\NormalTok{));}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note the \texttt{test} feature gate, which enables this unstable
feature.

We've imported the \texttt{test} crate, which contains our benchmarking
support. We have a new function as well, with the \texttt{bench}
attribute. Unlike regular tests, which take no arguments, benchmark
tests take a \texttt{\&mut\ Bencher}. This \texttt{Bencher} provides an
\texttt{iter} method, which takes a closure. This closure contains the
code we'd like to benchmark.

We can run benchmark tests with \texttt{cargo\ bench}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\KeywordTok{cargo} \NormalTok{bench}
   \KeywordTok{Compiling} \NormalTok{adder v0.0.1 (file:///home/steve/tmp/adder)}
     \KeywordTok{Running} \NormalTok{target/release/adder-91b3e234d4ed382a}

\KeywordTok{running} \NormalTok{2 tests}
\KeywordTok{test} \NormalTok{tests::it_works ... ignored}
\KeywordTok{test} \NormalTok{tests::bench_add_two ... bench:         1 ns/iter (+/- 0)}

\KeywordTok{test} \NormalTok{result: ok. 0 passed}\KeywordTok{;} \KeywordTok{0} \NormalTok{failed}\KeywordTok{;} \KeywordTok{1} \NormalTok{ignored}\KeywordTok{;} \KeywordTok{1} \NormalTok{measured}
\end{Highlighting}
\end{Shaded}

Our non-benchmark test was ignored. You may have noticed that
\texttt{cargo\ bench} takes a bit longer than \texttt{cargo\ test}. This
is because Rust runs our benchmark a number of times, and then takes the
average. Because we're doing so little work in this example, we have a
\texttt{1\ ns/iter\ (+/-\ 0)}, but this would show the variance if there
was one.

Advice on writing benchmarks:

\begin{itemize}
\tightlist
\item
  Move setup code outside the \texttt{iter} loop; only put the part you
  want to measure inside
\item
  Make the code do ``the same thing'' on each iteration; do not
  accumulate or change state
\item
  Make the outer function idempotent too; the benchmark runner is likely
  to run it many times
\item
  Make the inner \texttt{iter} loop short and fast so benchmark runs are
  fast and the calibrator can adjust the run-length at fine resolution
\item
  Make the code in the \texttt{iter} loop do something simple, to assist
  in pinpointing performance improvements (or regressions)
\end{itemize}

\subsubsection{Gotcha: optimizations}\label{gotcha-optimizations}

There's another tricky part to writing benchmarks: benchmarks compiled
with optimizations activated can be dramatically changed by the
optimizer so that the benchmark is no longer benchmarking what one
expects. For example, the compiler might recognize that some calculation
has no external effects and remove it entirely.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}

\KeywordTok{extern} \KeywordTok{crate} \NormalTok{test;}
\KeywordTok{use} \NormalTok{test::Bencher;}

\AttributeTok{#[}\NormalTok{bench}\AttributeTok{]}
\KeywordTok{fn} \NormalTok{bench_xor_1000_ints(b: &}\KeywordTok{mut} \NormalTok{Bencher) \{}
    \NormalTok{b.iter(|| \{}
        \NormalTok{(}\DecValTok{0.}\NormalTok{.}\DecValTok{1000}\NormalTok{).fold(}\DecValTok{0}\NormalTok{, |old, new| old ^ new);}
    \NormalTok{\});}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

gives the following results

\begin{verbatim}
running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
\end{verbatim}

The benchmarking runner offers two ways to avoid this. Either, the
closure that the \texttt{iter} method receives can return an arbitrary
value which forces the optimizer to consider the result used and ensures
it cannot remove the computation entirely. This could be done for the
example above by adjusting the \texttt{b.iter} call to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b.iter(|| \{}
    \CommentTok{// note lack of `;` (could also use an explicit `return`).}
    \NormalTok{(}\DecValTok{0.}\NormalTok{.}\DecValTok{1000}\NormalTok{).fold(}\DecValTok{0}\NormalTok{, |old, new| old ^ new)}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

Or, the other option is to call the generic \texttt{test::black\_box}
function, which is an opaque ``black box'' to the optimizer and so
forces it to consider any argument as used.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{test}\AttributeTok{)]}

\KeywordTok{extern} \KeywordTok{crate} \NormalTok{test;}

\NormalTok{b.iter(|| \{}
    \KeywordTok{let} \NormalTok{n = test::black_box(}\DecValTok{1000}\NormalTok{);}

    \NormalTok{(}\DecValTok{0.}\NormalTok{.n).fold(}\DecValTok{0}\NormalTok{, |a, b| a ^ b)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Neither of these read or modify the value, and are very cheap for small
values. Larger values can be passed indirectly to reduce overhead (e.g.
\texttt{black\_box(\&huge\_struct)}).

Performing either of the above changes gives the following benchmarking
results

\begin{verbatim}
running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
\end{verbatim}

However, the optimizer can still modify a testcase in an undesirable
manner even when using either of the above.

\section{Box Syntax and Patterns}\label{sec--box-syntax-and-patterns}

Currently the only stable way to create a \texttt{Box} is via the
\texttt{Box::new} method. Also it is not possible in stable Rust to
destructure a \texttt{Box} in a match pattern. The unstable \texttt{box}
keyword can be used to both create and destructure a \texttt{Box}. An
example usage would be:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{box_syntax}\AttributeTok{,} \NormalTok{box_patterns}\AttributeTok{)]}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{b = }\ConstantTok{Some}\NormalTok{(}\KeywordTok{box} \DecValTok{5}\NormalTok{);}
    \KeywordTok{match} \NormalTok{b \{}
        \ConstantTok{Some}\NormalTok{(}\KeywordTok{box} \NormalTok{n) }\KeywordTok{if} \NormalTok{n < }\DecValTok{0} \NormalTok{=> \{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Box contains negative number \{\}"}\NormalTok{, n);}
        \NormalTok{\},}
        \ConstantTok{Some}\NormalTok{(}\KeywordTok{box} \NormalTok{n) }\KeywordTok{if} \NormalTok{n >= }\DecValTok{0} \NormalTok{=> \{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Box contains non-negative number \{\}"}\NormalTok{, n);}
        \NormalTok{\},}
        \ConstantTok{None} \NormalTok{=> \{}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"No box"}\NormalTok{);}
        \NormalTok{\},}
        \NormalTok{_ => }\PreprocessorTok{unreachable!}\NormalTok{()}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that these features are currently hidden behind the
\texttt{box\_syntax} (box creation) and \texttt{box\_patterns}
(destructuring and pattern matching) gates because the syntax may still
change in the future.

\subsection{Returning Pointers}\label{returning-pointers}

In many languages with pointers, you'd return a pointer from a function
so as to avoid copying a large data structure. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{BigStruct \{}
    \NormalTok{one: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{two: }\DataTypeTok{i32}\NormalTok{,}
    \CommentTok{// etc}
    \NormalTok{one_hundred: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{Box}\NormalTok{<BigStruct>) -> }\DataTypeTok{Box}\NormalTok{<BigStruct> \{}
    \DataTypeTok{Box}\NormalTok{::new(*x)}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DataTypeTok{Box}\NormalTok{::new(BigStruct \{}
        \NormalTok{one: }\DecValTok{1}\NormalTok{,}
        \NormalTok{two: }\DecValTok{2}\NormalTok{,}
        \NormalTok{one_hundred: }\DecValTok{100}\NormalTok{,}
    \NormalTok{\});}

    \KeywordTok{let} \NormalTok{y = foo(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The idea is that by passing around a box, you're only copying a pointer,
rather than the hundred \texttt{i32}s that make up the
\texttt{BigStruct}.

This is an antipattern in Rust. Instead, write this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{box_syntax}\AttributeTok{)]}

\KeywordTok{struct} \NormalTok{BigStruct \{}
    \NormalTok{one: }\DataTypeTok{i32}\NormalTok{,}
    \NormalTok{two: }\DataTypeTok{i32}\NormalTok{,}
    \CommentTok{// etc}
    \NormalTok{one_hundred: }\DataTypeTok{i32}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{foo(x: }\DataTypeTok{Box}\NormalTok{<BigStruct>) -> BigStruct \{}
    \NormalTok{*x}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DataTypeTok{Box}\NormalTok{::new(BigStruct \{}
        \NormalTok{one: }\DecValTok{1}\NormalTok{,}
        \NormalTok{two: }\DecValTok{2}\NormalTok{,}
        \NormalTok{one_hundred: }\DecValTok{100}\NormalTok{,}
    \NormalTok{\});}

    \KeywordTok{let} \NormalTok{y: }\DataTypeTok{Box}\NormalTok{<BigStruct> = }\KeywordTok{box} \NormalTok{foo(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This gives you flexibility without sacrificing performance.

You may think that this gives us terrible performance: return a value
and then immediately box it up ?! Isn't this pattern the worst of both
worlds? Rust is smarter than that. There is no copy in this code.
\texttt{main} allocates enough room for the \texttt{box}, passes a
pointer to that memory into \texttt{foo} as \texttt{x}, and then
\texttt{foo} writes the value straight into the
\texttt{Box\textless{}T\textgreater{}}.

This is important enough that it bears repeating: pointers are not for
optimizing returning values from your code. Allow the caller to choose
how they want to use your output.

\section{Slice Patterns}\label{sec--slice-patterns}

If you want to match against a slice or array, you can use \texttt{\&}
with the \texttt{slice\_patterns} feature:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{slice_patterns}\AttributeTok{)]}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{v = }\PreprocessorTok{vec!}\NormalTok{[}\StringTok{"match_this"}\NormalTok{, }\StringTok{"1"}\NormalTok{];}

    \KeywordTok{match} \NormalTok{&v[..] \{}
        \NormalTok{[}\StringTok{"match_this"}\NormalTok{, second] => }\PreprocessorTok{println!}\NormalTok{(}\StringTok{"The second element is \{\}"}\NormalTok{, second),}
        \NormalTok{_ => \{\},}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{advanced\_slice\_patterns} gate lets you use \texttt{..} to
indicate any number of elements inside a pattern matching a slice. This
wildcard can only be used once for a given array. If there's an
identifier before the \texttt{..}, the result of the slice will be bound
to that name. For example:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{advanced_slice_patterns}\AttributeTok{,} \NormalTok{slice_patterns}\AttributeTok{)]}

\KeywordTok{fn} \NormalTok{is_symmetric(list: &[}\DataTypeTok{u32}\NormalTok{]) -> }\DataTypeTok{bool} \NormalTok{\{}
    \KeywordTok{match} \NormalTok{list \{}
        \NormalTok{[] | [_] => }\ConstantTok{true}\NormalTok{,}
        \NormalTok{[x, inside.., y] }\KeywordTok{if} \NormalTok{x == y => is_symmetric(inside),}
        \NormalTok{_ => }\ConstantTok{false}
    \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{sym = &[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{];}
    \PreprocessorTok{assert!}\NormalTok{(is_symmetric(sym));}

    \KeywordTok{let} \NormalTok{not_sym = &[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{];}
    \PreprocessorTok{assert!}\NormalTok{(!is_symmetric(not_sym));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Associated Constants}\label{sec--associated-constants}

With the \texttt{associated\_consts} feature, you can define constants
like this:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{associated_consts}\AttributeTok{)]}

\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{const} \NormalTok{ID: }\DataTypeTok{i32}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{}
    \KeywordTok{const} \NormalTok{ID: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{i32}\NormalTok{::ID);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Any implementor of \texttt{Foo} will have to define \texttt{ID}. Without
the definition:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{associated_consts}\AttributeTok{)]}

\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{const} \NormalTok{ID: }\DataTypeTok{i32}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

gives

\begin{verbatim}
error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
\end{verbatim}

A default value can be implemented as well:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{associated_consts}\AttributeTok{)]}

\KeywordTok{trait} \NormalTok{Foo \{}
    \KeywordTok{const} \NormalTok{ID: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{i32} \NormalTok{\{}
\NormalTok{\}}

\KeywordTok{impl} \NormalTok{Foo }\KeywordTok{for} \DataTypeTok{i64} \NormalTok{\{}
    \KeywordTok{const} \NormalTok{ID: }\DataTypeTok{i32} \NormalTok{= }\DecValTok{5}\NormalTok{;}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{i32}\NormalTok{::ID);}
    \PreprocessorTok{assert_eq!}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DataTypeTok{i64}\NormalTok{::ID);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As you can see, when implementing \texttt{Foo}, you can leave it
unimplemented, as with \texttt{i32}. It will then use the default value.
But, as in \texttt{i64}, we can also add our own definition.

Associated constants don't have to be associated with a trait. An
\texttt{impl} block for a \texttt{struct} works fine too:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{#![}\NormalTok{feature}\AttributeTok{(}\NormalTok{associated_consts}\AttributeTok{)]}

\KeywordTok{struct} \NormalTok{Foo;}

\KeywordTok{impl} \NormalTok{Foo \{}
    \KeywordTok{pub} \KeywordTok{const} \NormalTok{FOO: }\DataTypeTok{u32} \NormalTok{= }\DecValTok{3}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec--glossary}{\chapter{Glossary}\label{sec--glossary}}

Not every Rustacean has a background in systems programming, nor in
computer science, so we've added explanations of terms that might be
unfamiliar.

\hyperdef{}{abstract-syntax-tree}{\paragraph{Abstract Syntax
Tree}\label{abstract-syntax-tree}}

When a compiler is compiling your program, it does a number of different
things. One of the things that it does is turn the text of your program
into an `abstract syntax tree', or `AST'. This tree is a representation
of the structure of your program. For example, \texttt{2\ +\ 3} can be
turned into a tree:

\begin{verbatim}
  +
 / \
2   3
\end{verbatim}

And \texttt{2\ +\ (3\ *\ 4)} would look like this:

\begin{verbatim}
  +
 / \
2   *
   / \
  3   4
\end{verbatim}

\hyperdef{}{arity}{\paragraph{Arity}\label{arity}}

Arity refers to the number of arguments a function or operation takes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = (}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}
\KeywordTok{let} \NormalTok{y = (}\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{);}
\KeywordTok{let} \NormalTok{z = (}\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

In the example above \texttt{x} and \texttt{y} have arity 2. \texttt{z}
has arity 3.

\paragraph{DST (Dynamically Sized
Type)}\label{dst-dynamically-sized-type}

A type without a statically known size or alignment.
(\href{../nomicon/exotic-sizes.html\#dynamically-sized-types-(dsts)}{more
info})

\hyperdef{}{expression}{\paragraph{Expression}\label{expression}}

In computer programming, an expression is a combination of values,
constants, variables, operators and functions that evaluate to a single
value. For example, \texttt{2\ +\ (3\ *\ 4)} is an expression that
returns the value 14. It is worth noting that expressions can have
side-effects. For example, a function included in an expression might
perform actions other than simply returning a value.

\hyperdef{}{expression-oriented-language}{\paragraph{Expression-Oriented
Language}\label{expression-oriented-language}}

In early programming languages, \hyperref[expression]{expressions} and
\hyperref[statement]{statements} were two separate syntactic categories:
expressions had a value and statements did things. However, later
languages blurred this distinction, allowing expressions to do things
and statements to have a value. In an expression-oriented language,
(nearly) every statement is an expression and therefore returns a value.
Consequently, these expression statements can themselves form part of
larger expressions.

\hyperdef{}{statement}{\paragraph{Statement}\label{statement}}

In computer programming, a statement is the smallest standalone element
of a programming language that commands a computer to perform an action.

\hyperdef{}{sec--bibliography}{\chapter{Bibliography}\label{sec--bibliography}}

This is a reading list of material relevant to Rust. It includes prior
research that has - at one time or another - influenced the design of
Rust, as well as publications about Rust.

\paragraph{Type system}\label{type-system}

\begin{itemize}
\tightlist
\item
  \href{http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf}{Region
  based memory management in Cyclone}
\item
  \href{http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf}{Safe manual
  memory management in Cyclone}
\item
  \href{http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz}{Typeclasses:
  making ad-hoc polymorphism less ad hoc}
\item
  \href{https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf}{Macros
  that work together}
\item
  \href{http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf}{Traits:
  composable units of behavior}
\item
  \href{http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps}{Alias
  burying} - We tried something similar and abandoned it.
\item
  \href{http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html}{External
  uniqueness is unique enough}
\item
  \href{https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf}{Uniqueness
  and Reference Immutability for Safe Parallelism}
\item
  \href{http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf}{Region
  Based Memory Management}
\end{itemize}

\paragraph{Concurrency}\label{concurrency}

\begin{itemize}
\tightlist
\item
  \href{https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf}{Singularity:
  rethinking the software stack}
\item
  \href{https://research.microsoft.com/pubs/67482/singsharp.pdf}{Language
  support for fast and reliable message passing in singularity OS}
\item
  \href{http://supertech.csail.mit.edu/papers/steal.pdf}{Scheduling
  multithreaded computations by work stealing}
\item
  \href{http://www.eecis.udel.edu/\%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf}{Thread
  scheduling for multiprogramming multiprocessors}
\item
  \href{http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf}{The
  data locality of work stealing}
\item
  \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097\&rep=rep1\&type=pdf}{Dynamic
  circular work stealing deque} - The Chase/Lev deque
\item
  \href{http://www.cs.rice.edu/\%7Eyguo/pubs/PID824943.pdf}{Work-first
  and help-first scheduling policies for async-finish task parallelism}
  - More general than fully-strict work stealing
\item
  \href{http://www.coopsoft.com/ar/CalamityArticle.html}{A Java
  fork/join calamity} - critique of Java's fork/join library,
  particularly its application of work stealing to non-strict
  computation
\item
  \href{http://www.stanford.edu/~ouster/cgi-bin/papers/coscheduling.pdf}{Scheduling
  techniques for concurrent systems}
\item
  \href{http://www.blagodurov.net/files/a8-blagodurov.pdf}{Contention
  aware scheduling}
\item
  \href{http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf}{Balanced
  work stealing for time-sharing multicores}
\item
  \href{http://dl.acm.org/citation.cfm?id=1953616\&dl=ACM\&coll=DL\&CFID=524387192\&CFTOKEN=44362705}{Three
  layer cake for shared-memory programming}
\item
  \href{http://www.cs.bgu.ac.il/\%7Ehendlerd/papers/p280-hendler.pdf}{Non-blocking
  steal-half work queues}
\item
  \href{http://www.mpi-sws.org/~turon/reagents.pdf}{Reagents: expressing
  and composing fine-grained concurrency}
\item
  \href{https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf}{Algorithms
  for scalable synchronization of shared-memory multiprocessors}
\item
  \href{https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf}{Epoc-based
  reclamation}.
\end{itemize}

\paragraph{Others}\label{others}

\begin{itemize}
\tightlist
\item
  \href{https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf}{Crash-only
  software}
\item
  \href{http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf}{Composing
  High-Performance Memory Allocators}
\item
  \href{http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf}{Reconsidering
  Custom Memory Allocation}
\end{itemize}

\paragraph{\texorpdfstring{Papers \emph{about}
Rust}{Papers about Rust}}\label{papers-about-rust}

\begin{itemize}
\tightlist
\item
  \href{http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf}{GPU
  Programming in Rust: Implementing High Level Abstractions in a Systems
  Level Language}. Early GPU work by Eric Holk.
\item
  \href{https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea}{Parallel
  closures: a new twist on an old idea}
\item
  not exactly about rust, but by nmatsakis
\item
  \href{ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf}{Patina:
  A Formalization of the Rust Programming Language}. Early formalization
  of a subset of the type system, by Eric Reed.
\item
  \href{http://arxiv.org/abs/1505.07383}{Experience Report: Developing
  the Servo Web Browser Engine using Rust}. By Lars Bergstrom.
\item
  \href{https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf}{Implementing
  a Generic Radix Trie in Rust}. Undergrad paper by Michael Sproul.
\item
  \href{http://scialex.github.io/reenix.pdf}{Reenix: Implementing a
  Unix-Like Operating System in Rust}. Undergrad paper by Alex Light.
\item
  \href{}{Evaluation of performance and productivity metrics of
  potential programming languages in the HPC environment}. Bachelor's
  thesis by Florian Wilkens. Compares C, Go and Rust.
\item
  \href{http://spw15.langsec.org/papers/couprie-nom.pdf}{Nom, a byte
  oriented, streaming, zero copy, parser combinators library in Rust}.
  By Geoffroy Couprie, research for VLC.
\item
  \href{http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf}{Graph-Based
  Higher-Order Intermediate Representation}. An experimental IR
  implemented in Impala, a Rust-like language.
\item
  \href{http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf}{Code
  Refinement of Stencil Codes}. Another paper using Impala.
\item
  \href{http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf}{Parallelization
  in Rust with fork-join and friends}. Linus Farnstrand's master's
  thesis.
\item
  \href{http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf}{Session
  Types for Rust}. Philip Munksgaard's master's thesis. Research for
  Servo.
\end{itemize}



\end{document}
