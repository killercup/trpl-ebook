<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="The Rust Team">
  <meta name="dcterms.date" content="2015-09-26">
  <title>The Rust Programming Language</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,%0A%0Abody%20%7B%0Afont%2Dfamily%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%27Times%20New%20Roman%27%2C%20serif%3B%0Afont%2Dsize%3A%2012px%3B%0Aline%2Dheight%3A%201%2E7%3B%0Amax%2Dwidth%3A%2042em%3B%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20480px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2014px%3B%0A%7D%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20768px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2016px%3B%0A%7D%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Aline%2Dheight%3A%20125%25%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%20%7B%0Afont%2Dweight%3A%20normal%3B%0A%7D%0Ah4%2C%20h5%2C%20h6%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Ah1%20%7B%0Afont%2Dsize%3A%202em%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%201%2E8em%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%201%2E5em%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ah6%20%7B%0Afont%2Dsize%3A%200%2E9em%3B%0A%7D%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0Afont%2Dfamily%3A%20monospace%3B%0Afont%2Dsize%3A%200%2E98em%3B%0A%7D%0A%0Ahtml%20%7B%0Afont%2Dsize%3A%20100%25%3B%0Aoverflow%2Dy%3A%20scroll%3B%0A%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%2Dms%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%7D%0Abody%20%7B%0Acolor%3A%20%23444%3B%0Apadding%3A%201em%3B%0Amargin%3A%20auto%3B%0Abackground%3A%20%23fefefe%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230645ad%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%230b0080%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%2306e%3B%0A%7D%0Aa%3Aactive%20%7B%0Acolor%3A%20%23faa700%3B%0A%7D%0Aa%3Afocus%20%7B%0Aoutline%3A%20thin%20dotted%3B%0A%7D%0A%2A%3A%3A%2Dmoz%2Dselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%23000%3B%0A%7D%0A%2A%3A%3Aselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%23000%3B%0A%7D%0Aa%3A%3A%2Dmoz%2Dselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%230645ad%3B%0A%7D%0Aa%3A%3Aselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%230645ad%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Acolor%3A%20%23111%3B%0Amargin%2Dtop%3A%202em%3B%0A%7D%0Ap%20%7B%0Amargin%3A%201em%200%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Aq%20%7B%20quotes%3A%20%22%5C201C%22%20%22%5C201D%22%20%22%5C2018%22%20%22%5C2019%22%3B%20%7D%0A%5Blang%3Dde%5D%20q%20%7B%0Aquotes%3A%20%22%5C00bb%22%20%22%5C00ab%22%20%22%5C203A%22%20%22%5C2039%22%3B%0A%7D%0Ablockquote%2C%0Aaside%2Enotes%20%7B%0Acolor%3A%20%23666%3B%0Amargin%3A%200%3B%0Apadding%2Dleft%3A%203em%3B%0Aborder%2Dleft%3A%200%2E5em%20%23EEE%20solid%3B%0A%7D%0Aaside%2Enotes%20%7B%0Acolor%3A%20%23999%3B%0Aborder%2Dleft%2Dcolor%3A%20%23ffa%3B%0A%7D%0Ahr%20%7B%0Adisplay%3A%20block%3B%0Aheight%3A%202px%3B%0Aborder%3A%200%3B%0Aborder%2Dtop%3A%201px%20solid%20%23aaa%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23eee%3B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%3B%0A%7D%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0Acolor%3A%20%23000%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%0Aword%2Dwrap%3A%20break%2Dword%3B%0Apadding%3A%200%2E1em%200%2E4em%3B%0Atext%2Dindent%3A%201em%3B%0A%7D%0Ab%2C%20strong%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adfn%20%7B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Ains%20%7B%0Abackground%3A%20%23ff9%3B%0Acolor%3A%20%23000%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Amark%20%7B%0Abackground%3A%20%23ff0%3B%0Acolor%3A%20%23000%3B%0Afont%2Dstyle%3A%20italic%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Asub%2C%20sup%20%7B%0Afont%2Dsize%3A%2075%25%3B%0Aline%2Dheight%3A%200%3B%0Aposition%3A%20relative%3B%0Avertical%2Dalign%3A%20baseline%3B%0A%7D%0Asup%20%7B%0Atop%3A%20%2D0%2E5em%3B%0A%7D%0Asub%20%7B%0Abottom%3A%20%2D0%2E25em%3B%0A%7D%0Aul%2C%20ol%20%7B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%200%200%202em%3B%0A%7D%0Ali%20p%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aul%20ul%2C%20ol%20ol%20%7B%0Amargin%3A%20%2E3em%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dbottom%3A%201em%3B%0A%7D%0Adt%20%7B%0Afont%2Dweight%3A%20bold%3B%0Amargin%2Dbottom%3A%20%2E8em%3B%0A%7D%0Add%20%7B%0Amargin%3A%200%200%20%2E8em%202em%3B%0A%7D%0Add%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aimg%20%7B%0Aborder%3A%200%3B%0A%2Dms%2Dinterpolation%2Dmode%3A%20bicubic%3B%0Avertical%2Dalign%3A%20middle%3B%0A%7D%0Afigure%20%7B%0Adisplay%3A%20block%3B%0Atext%2Dalign%3A%20center%3B%0Amargin%3A%202em%200%3B%0A%7D%0Afigure%20img%20%7B%0Aborder%3A%20none%3B%0Amargin%3A%200%20auto%201em%3B%0A%7D%0Afigcaption%20%7B%0Afont%2Dsize%3A%200%2E8em%3B%0Afont%2Dstyle%3A%20italic%3B%0Amargin%3A%200%200%20%2E8em%3B%0A%7D%0Atable%20%7B%0Amargin%2Dbottom%3A%202em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dspacing%3A%200%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Abackground%2Dcolor%3A%20%23eee%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0Atable%20td%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0Avertical%2Dalign%3A%20top%3B%0A%7D%0A%2Ebyline%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%2Ereferences%20a%2Euri%20%7Bword%2Dbreak%3A%20break%2Dall%3B%7D%0Anav%2Etoc%20ul%20%7B%0Alist%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0Anav%2Etoc%2Ealready%2Dnumbered%20ul%20%7B%0Alist%2Dstyle%2Dtype%3A%20none%3B%0A%7D%0Anav%2Etoc%2Ealready%2Dnumbered%20%3E%20ul%20%7B%0Apadding%3A%200%3B%0A%7D%0A%0A%40media%20print%20%7B%0A%2A%20%7B%0Abackground%3A%20transparent%20%21important%3B%0Acolor%3A%20black%20%21important%3B%0Afilter%3A%20none%20%21important%3B%0A%2Dms%2Dfilter%3A%20none%20%21important%3B%0A%7D%0Abody%20%7B%0Afont%2Dsize%3A%209pt%3B%0Aline%2Dheight%3A%201%2E2%3B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Aa%2C%20a%3Avisited%20%7B%0Atext%2Ddecoration%3A%20underline%3B%0A%7D%0Ahr%20%7B%0Aheight%3A%201px%3B%0Aborder%3A%200%3B%0Aborder%2Dbottom%3A%201px%20solid%20black%3B%0A%7D%0A%0Aabbr%5Btitle%5D%3Aafter%20%7B%0Acontent%3A%20%22%20%28%22%20attr%28title%29%20%22%29%22%3B%0A%7D%0A%2Eir%20a%3Aafter%2C%20a%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2C%20a%5Bhref%5E%3D%22%23%22%5D%3Aafter%20%7B%0Acontent%3A%20%22%22%3B%0A%7D%0Apre%2C%20blockquote%20%7B%0Aborder%3A%201px%20solid%20%23999%3B%0Apadding%2Dright%3A%201em%3B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Atr%2C%20img%20%7B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%20%21important%3B%0A%7D%0A%40page%20%3Aleft%20%7B%0Amargin%3A%2025mm%2030mm%2025mm%2020mm%3B%0A%7D%0A%40page%20%3Aright%20%7B%0Amargin%3A%2025mm%2020mm%2025mm%2030mm%3B%0A%7D%0Ap%2C%20h2%2C%20h3%20%7B%0Aorphans%3A%203%3B%0Awidows%3A%203%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%20%7B%0Apage%2Dbreak%2Dafter%3A%20avoid%3B%0A%7D%0A%7D%0A" rel="stylesheet">
</head>
<body role="document">


<header>
  <h1 class="title">The Rust Programming Language</h1>

  
  <div class="byline vcard">
    <address>
          <p class="author">The Rust Team</p>
        </address>
      <time pubdate="pubdate" date="2015-09-26" class="date">2015-09-26</time>
    </div>
</header>


<nav class="toc" id="TOC">
  <h2>Table of Contents</h2>
  <ul>
  <li><a href="#introduction">Introduction</a><ul>
  <li><a href="#contributing">Contributing</a></li>
  <li><a href="#a-brief-introduction-to-rust">A brief introduction to Rust</a></li>
  </ul></li>
  <li><a href="#sec--getting-started">Getting Started</a><ul>
  <li><a href="#sec--installing-rust">Installing Rust</a></li>
  <li><a href="#sec--hello-world">Hello, world!</a></li>
  <li><a href="#sec--hello-cargo">Hello, Cargo!</a></li>
  </ul></li>
  <li><a href="#sec--learn-rust">Learn Rust</a><ul>
  <li><a href="#sec--guessing-game">Guessing Game</a><ul>
  <li><a href="#set-up">Set up</a></li>
  <li><a href="#processing-a-guess">Processing a Guess</a></li>
  <li><a href="#generating-a-secret-number">Generating a secret number</a></li>
  <li><a href="#comparing-guesses">Comparing guesses</a></li>
  <li><a href="#looping">Looping</a></li>
  <li><a href="#complete">Complete!</a></li>
  </ul></li>
  <li><a href="#sec--dining-philosophers">Dining Philosophers</a></li>
  <li><a href="#sec--rust-inside-other-languages">Rust Inside Other Languages</a><ul>
  <li><a href="#the-problem">The problem</a></li>
  <li><a href="#a-rust-library">A Rust library</a></li>
  <li><a href="#ruby">Ruby</a></li>
  <li><a href="#python">Python</a></li>
  <li><a href="#node.js">Node.js</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--effective-rust">Effective Rust</a><ul>
  <li><a href="#sec--the-stack-and-the-heap">The Stack and the Heap</a><ul>
  <li><a href="#memory-management">Memory management</a></li>
  <li><a href="#the-stack">The Stack</a></li>
  <li><a href="#the-heap">The Heap</a></li>
  <li><a href="#arguments-and-borrowing">Arguments and borrowing</a></li>
  <li><a href="#a-complex-example">A complex example</a></li>
  <li><a href="#what-do-other-languages-do">What do other languages do?</a></li>
  <li><a href="#which-to-use">Which to use?</a></li>
  </ul></li>
  <li><a href="#sec--testing">Testing</a><ul>
  <li><a href="#the-test-attribute">The <code>test</code> attribute</a></li>
  <li><a href="#the-ignore-attribute">The <code>ignore</code> attribute</a></li>
  <li><a href="#the-tests-module">The <code>tests</code> module</a></li>
  <li><a href="#the-tests-directory">The <code>tests</code> directory</a></li>
  <li><a href="#documentation-tests">Documentation tests</a></li>
  </ul></li>
  <li><a href="#sec--conditional-compilation">Conditional Compilation</a><ul>
  <li><a href="#cfg_attr">cfg_attr</a></li>
  <li><a href="#cfg">cfg!</a></li>
  </ul></li>
  <li><a href="#sec--documentation">Documentation</a></li>
  <li><a href="#sec--iterators">Iterators</a></li>
  <li><a href="#sec--concurrency">Concurrency</a></li>
  <li><a href="#sec--error-handling">Error Handling</a><ul>
  <li><a href="#table-of-contents">Table of Contents</a></li>
  <li><a href="#the-basics">The Basics</a></li>
  <li><a href="#working-with-multiple-error-types">Working with multiple error types</a></li>
  <li><a href="#standard-library-traits-used-for-error-handling">Standard library traits used for error handling</a></li>
  <li><a href="#case-study-a-program-to-read-population-data">Case study: A program to read population data</a></li>
  <li><a href="#the-short-story">The Short Story</a></li>
  </ul></li>
  <li><a href="#sec--choosing-your-guarantees">Choosing your Guarantees</a><ul>
  <li><a href="#basic-pointer-types">Basic pointer types</a></li>
  <li><a href="#cell-types">Cell types</a></li>
  <li><a href="#synchronous-types">Synchronous types</a></li>
  <li><a href="#composition">Composition</a></li>
  </ul></li>
  <li><a href="#sec--ffi">FFI</a><ul>
  <li><a href="#introduction-1">Introduction</a></li>
  <li><a href="#creating-a-safe-interface">Creating a safe interface</a></li>
  <li><a href="#destructors">Destructors</a></li>
  <li><a href="#callbacks-from-c-code-to-rust-functions">Callbacks from C code to Rust functions</a></li>
  <li><a href="#linking">Linking</a></li>
  <li><a href="#unsafe-blocks">Unsafe blocks</a></li>
  <li><a href="#accessing-foreign-globals">Accessing foreign globals</a></li>
  <li><a href="#foreign-calling-conventions">Foreign calling conventions</a></li>
  <li><a href="#interoperability-with-foreign-code">Interoperability with foreign code</a></li>
  <li><a href="#the-nullable-pointer-optimization">The ‚Äúnullable pointer optimization‚Äù</a></li>
  <li><a href="#calling-rust-code-from-c">Calling Rust code from C</a></li>
  <li><a href="#ffi-and-panics">FFI and panics</a></li>
  <li><a href="#representing-opaque-structs">Representing opaque structs</a></li>
  </ul></li>
  <li><a href="#sec--borrow-and-asref">Borrow and AsRef</a><ul>
  <li><a href="#borrow">Borrow</a></li>
  <li><a href="#asref">AsRef</a></li>
  <li><a href="#which-should-i-use">Which should I use?</a></li>
  </ul></li>
  <li><a href="#sec--release-channels">Release Channels</a><ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#choosing-a-version">Choosing a version</a></li>
  <li><a href="#helping-the-ecosystem-through-ci">Helping the ecosystem through CI</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--syntax-and-semantics">Syntax and Semantics</a><ul>
  <li><a href="#sec--variable-bindings">Variable Bindings</a></li>
  <li><a href="#sec--functions">Functions</a></li>
  <li><a href="#sec--primitive-types">Primitive Types</a><ul>
  <li><a href="#booleans">Booleans</a></li>
  <li><a href="#char"><code>char</code></a></li>
  <li><a href="#numeric-types">Numeric types</a></li>
  <li><a href="#arrays">Arrays</a></li>
  <li><a href="#slices">Slices</a></li>
  <li><a href="#str"><code>str</code></a></li>
  <li><a href="#tuples">Tuples</a></li>
  <li><a href="#functions">Functions</a></li>
  </ul></li>
  <li><a href="#sec--comments">Comments</a></li>
  <li><a href="#sec--if">if</a></li>
  <li><a href="#sec--loops">Loops</a></li>
  <li><a href="#sec--ownership">Ownership</a><ul>
  <li><a href="#meta">Meta</a></li>
  <li><a href="#ownership">Ownership</a></li>
  <li><a href="#move-semantics">Move semantics</a></li>
  <li><a href="#more-than-ownership">More than ownership</a></li>
  </ul></li>
  <li><a href="#sec--references-and-borrowing">References and Borrowing</a><ul>
  <li><a href="#meta-1">Meta</a></li>
  <li><a href="#borrowing">Borrowing</a></li>
  <li><a href="#mut-references">&amp;mut references</a></li>
  <li><a href="#the-rules">The Rules</a></li>
  </ul></li>
  <li><a href="#sec--lifetimes">Lifetimes</a><ul>
  <li><a href="#meta-2">Meta</a></li>
  <li><a href="#lifetimes">Lifetimes</a></li>
  <li><a href="#in-structs">In <code>struct</code>s</a></li>
  </ul></li>
  <li><a href="#sec--mutability">Mutability</a><ul>
  <li><a href="#interior-vs.exterior-mutability">Interior vs.¬†Exterior Mutability</a></li>
  </ul></li>
  <li><a href="#sec--structs">Structs</a><ul>
  <li><a href="#update-syntax">Update syntax</a></li>
  <li><a href="#tuple-structs">Tuple structs</a></li>
  <li><a href="#unit-like-structs">Unit-like structs</a></li>
  </ul></li>
  <li><a href="#sec--enums">Enums</a><ul>
  <li><a href="#constructors-as-functions">Constructors as functions</a></li>
  </ul></li>
  <li><a href="#sec--match">Match</a><ul>
  <li><a href="#matching-on-enums">Matching on enums</a></li>
  </ul></li>
  <li><a href="#sec--patterns">Patterns</a><ul>
  <li><a href="#multiple-patterns">Multiple patterns</a></li>
  <li><a href="#destructuring">Destructuring</a></li>
  <li><a href="#ignoring-bindings">Ignoring bindings</a></li>
  <li><a href="#ref-and-ref-mut">ref and ref mut</a></li>
  <li><a href="#ranges">Ranges</a></li>
  <li><a href="#bindings">Bindings</a></li>
  <li><a href="#guards">Guards</a></li>
  <li><a href="#mix-and-match">Mix and Match</a></li>
  </ul></li>
  <li><a href="#sec--method-syntax">Method Syntax</a><ul>
  <li><a href="#method-calls">Method calls</a></li>
  <li><a href="#chaining-method-calls">Chaining method calls</a></li>
  <li><a href="#associated-functions">Associated functions</a></li>
  <li><a href="#builder-pattern">Builder Pattern</a></li>
  </ul></li>
  <li><a href="#sec--vectors">Vectors</a></li>
  <li><a href="#sec--strings">Strings</a></li>
  <li><a href="#sec--generics">Generics</a></li>
  <li><a href="#sec--traits">Traits</a><ul>
  <li><a href="#rules-for-implementing-traits">Rules for implementing traits</a></li>
  <li><a href="#multiple-trait-bounds">Multiple trait bounds</a></li>
  <li><a href="#where-clause">Where clause</a></li>
  <li><a href="#default-methods">Default methods</a></li>
  <li><a href="#inheritance">Inheritance</a></li>
  </ul></li>
  <li><a href="#sec--drop">Drop</a></li>
  <li><a href="#sec--if-let">if let</a></li>
  <li><a href="#sec--trait-objects">Trait Objects</a></li>
  <li><a href="#sec--closures">Closures</a><ul>
  <li><a href="#syntax">Syntax</a></li>
  <li><a href="#closures-and-their-environment">Closures and their environment</a></li>
  <li><a href="#closure-implementation">Closure implementation</a></li>
  <li><a href="#taking-closures-as-arguments">Taking closures as arguments</a></li>
  <li><a href="#function-pointers-and-closures">Function pointers and closures</a></li>
  <li><a href="#returning-closures">Returning closures</a></li>
  </ul></li>
  <li><a href="#sec--ufcs">Universal Function Call Syntax</a><ul>
  <li><a href="#angle-bracket-form">Angle-bracket Form</a></li>
  </ul></li>
  <li><a href="#sec--crates-and-modules">Crates and Modules</a><ul>
  <li><a href="#basic-terminology-crates-and-modules">Basic terminology: Crates and Modules</a></li>
  <li><a href="#defining-modules">Defining Modules</a></li>
  <li><a href="#multiple-file-crates">Multiple file crates</a></li>
  <li><a href="#importing-external-crates">Importing External Crates</a></li>
  <li><a href="#exporting-a-public-interface">Exporting a Public Interface</a></li>
  <li><a href="#importing-modules-with-use">Importing Modules with <code>use</code></a></li>
  </ul></li>
  <li><a href="#sec--const-and-static"><code>const</code> and <code>static</code></a><ul>
  <li><a href="#static-1"><code>static</code></a></li>
  <li><a href="#initializing">Initializing</a></li>
  <li><a href="#which-construct-should-i-use">Which construct should I use?</a></li>
  </ul></li>
  <li><a href="#sec--attributes">Attributes</a></li>
  <li><a href="#sec--type-aliases"><code>type</code> aliases</a></li>
  <li><a href="#sec--casting-between-types">Casting between types</a><ul>
  <li><a href="#as"><code>as</code></a></li>
  <li><a href="#transmute"><code>transmute</code></a></li>
  </ul></li>
  <li><a href="#sec--associated-types">Associated Types</a></li>
  <li><a href="#sec--unsized-types">Unsized Types</a><ul>
  <li><a href="#sized">?Sized</a></li>
  </ul></li>
  <li><a href="#sec--operators-and-overloading">Operators and Overloading</a><ul>
  <li><a href="#using-operator-traits-in-generic-structs">Using operator traits in generic structs</a></li>
  </ul></li>
  <li><a href="#sec--deref-coercions">Deref coercions</a></li>
  <li><a href="#sec--macros">Macros</a><ul>
  <li><a href="#defining-a-macro">Defining a macro</a></li>
  <li><a href="#hygiene">Hygiene</a></li>
  <li><a href="#recursive-macros">Recursive macros</a></li>
  <li><a href="#debugging-macro-code">Debugging macro code</a></li>
  <li><a href="#syntactic-requirements">Syntactic requirements</a></li>
  <li><a href="#scoping-and-macro-importexport">Scoping and macro import/export</a></li>
  <li><a href="#the-variable-crate">The variable <code>$crate</code></a></li>
  <li><a href="#the-deep-end">The deep end</a></li>
  <li><a href="#common-macros">Common macros</a></li>
  <li><a href="#procedural-macros">Procedural macros</a></li>
  </ul></li>
  <li><a href="#sec--raw-pointers">Raw Pointers</a><ul>
  <li><a href="#basics">Basics</a></li>
  <li><a href="#ffi">FFI</a></li>
  <li><a href="#references-and-raw-pointers">References and raw pointers</a></li>
  </ul></li>
  <li><a href="#sec--unsafe"><code>unsafe</code></a><ul>
  <li><a href="#what-does-safe-mean">What does ‚Äòsafe‚Äô mean?</a></li>
  <li><a href="#unsafe-superpowers">Unsafe Superpowers</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--nightly-rust">Nightly Rust</a><ul>
  <li><a href="#sec--compiler-plugins">Compiler Plugins</a><ul>
  <li><a href="#introduction-2">Introduction</a></li>
  <li><a href="#syntax-extensions">Syntax extensions</a></li>
  <li><a href="#lint-plugins">Lint plugins</a></li>
  </ul></li>
  <li><a href="#sec--inline-assembly">Inline Assembly</a></li>
  <li><a href="#sec--no-stdlib">No stdlib</a></li>
  <li><a href="#sec--intrinsics">Intrinsics</a></li>
  <li><a href="#sec--lang-items">Lang items</a></li>
  <li><a href="#sec--advanced-linking">Advanced linking</a><ul>
  <li><a href="#link-args">Link args</a></li>
  <li><a href="#static-linking">Static linking</a></li>
  </ul></li>
  <li><a href="#sec--benchmark-tests">Benchmark Tests</a></li>
  <li><a href="#sec--box-syntax-and-patterns">Box Syntax and Patterns</a><ul>
  <li><a href="#returning-pointers">Returning Pointers</a></li>
  </ul></li>
  <li><a href="#sec--slice-patterns">Slice Patterns</a></li>
  <li><a href="#sec--associated-constants">Associated Constants</a></li>
  </ul></li>
  <li><a href="#sec--glossary">Glossary</a></li>
  <li><a href="#sec--bibliography">Bibliography</a></li>
  </ul>
</nav>

<article role="main">
  <section id="introduction" class="level1">
  <h1>Introduction</h1>
  <p>Welcome! This book will teach you about the <a href="https://www.rust-lang.org">Rust Programming Language</a>. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. It maintains these goals without having a garbage collector, making it a useful language for a number of use cases other languages aren‚Äôt good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‚Äòzero-cost abstractions‚Äô even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.</p>
  <p>‚ÄúThe Rust Programming Language‚Äù is split into eight sections. This introduction is the first. After this:</p>
  <ul>
  <li><a href="#sec--getting-started">Getting started</a> - Set up your computer for Rust development.</li>
  <li><a href="#sec--learn-rust">Learn Rust</a> - Learn Rust programming through small projects.</li>
  <li><a href="#sec--effective-rust">Effective Rust</a> - Higher-level concepts for writing excellent Rust code.</li>
  <li><a href="#sec--syntax-and-semantics">Syntax and Semantics</a> - Each bit of Rust, broken down into small chunks.</li>
  <li><a href="#sec--nightly-rust">Nightly Rust</a> - Cutting-edge features that aren‚Äôt in stable builds yet.</li>
  <li><a href="#sec--glossary">Glossary</a> - A reference of terms used in the book.</li>
  <li><a href="#sec--bibliography">Bibliography</a> - Background on Rust‚Äôs influences, papers about Rust.</li>
  </ul>
  <p>After reading this introduction, you‚Äôll want to dive into either ‚ÄòLearn Rust‚Äô or ‚ÄòSyntax and Semantics‚Äô, depending on your preference: ‚ÄòLearn Rust‚Äô if you want to dive in with a project, or ‚ÄòSyntax and Semantics‚Äô if you prefer to start small, and learn a single concept thoroughly before moving onto the next. Copious cross-linking connects these parts together.</p>
  <section id="contributing" class="level3">
  <h3>Contributing</h3>
  <p>The source files from which this book is generated can be found on Github: <a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  </section>
  <section id="a-brief-introduction-to-rust" class="level2">
  <h2>A brief introduction to Rust</h2>
  <p>Is Rust a language you might be interested in? Let‚Äôs examine a few small code samples to show off a few of its strengths.</p>
  <p>The main concept that makes Rust unique is called ‚Äòownership‚Äô. Consider this small example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  }</code></pre></div>
  <p>This program makes a <a href="#sec--variable-bindings">variable binding</a> named <code>x</code>. The value of this binding is a <code>Vec&lt;T&gt;</code>, a ‚Äòvector‚Äô, that we create through a <a href="#sec--macros">macro</a> defined in the standard library. This macro is called <code>vec</code>, and we invoke macros with a <code>!</code>. This follows a general principle of Rust: make things explicit. Macros can do significantly more complicated things than function calls, and so they‚Äôre visually distinct. The <code>!</code> also helps with parsing, making tooling easier to write, which is also important.</p>
  <p>We used <code>mut</code> to make <code>x</code> mutable: bindings are immutable by default in Rust. We‚Äôll be mutating this vector later in the example.</p>
  <p>It‚Äôs also worth noting that we didn‚Äôt need a type annotation here: while Rust is statically typed, we didn‚Äôt need to explicitly annotate the type. Rust has type inference to balance out the power of static typing with the verbosity of annotating types.</p>
  <p>Rust prefers stack allocation to heap allocation: <code>x</code> is placed directly on the stack. However, the <code>Vec&lt;T&gt;</code> type allocates space for the elements of the vector on the heap. If you‚Äôre not familiar with this distinction, you can ignore it for now, or check out <a href="#sec--the-stack-and-the-heap">‚ÄòThe Stack and the Heap‚Äô</a>. As a systems programming language, Rust gives you the ability to control how your memory is allocated, but when we‚Äôre getting started, it‚Äôs less of a big deal.</p>
  <p>Earlier, we mentioned that ‚Äòownership‚Äô is the key new concept in Rust. In Rust parlance, <code>x</code> is said to ‚Äòown‚Äô the vector. This means that when <code>x</code> goes out of scope, the vector‚Äôs memory will be de-allocated. This is done deterministically by the Rust compiler, rather than through a mechanism such as a garbage collector. In other words, in Rust, you don‚Äôt call functions like <code>malloc</code> and <code>free</code> yourself: the compiler statically determines when you need to allocate or deallocate memory, and inserts those calls itself. To err is to be human, but compilers never forget.</p>
  <p>Let‚Äôs add another line to our example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  }</code></pre></div>
  <p>We‚Äôve introduced another binding, <code>y</code>. In this case, <code>y</code> is a ‚Äòreference‚Äô to the first element of the vector. Rust‚Äôs references are similar to pointers in other languages, but with additional compile-time safety checks. References interact with the ownership system by <a href="#sec--references-and-borrowing">‚Äòborrowing‚Äô</a> what they point to, rather than owning it. The difference is, when the reference goes out of scope, it will not deallocate the underlying memory. If it did, we‚Äôd de-allocate twice, which is bad!</p>
  <p>Let‚Äôs add a third line. It looks innocent enough, but causes a compiler error:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p><code>push</code> is a method on vectors that appends another element to the end of the vector. When we try to compile this program, we get an error:</p>
  <pre class="text"><code>error: cannot borrow `x` as mutable because it is also borrowed as immutable
      x.push(&quot;foo&quot;);
      ^
  note: previous borrow of `x` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `x` until the borrow ends
      let y = &amp;x[0];
               ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Whew! The Rust compiler gives quite detailed errors at times, and this is one of those times. As the error explains, while we made our binding mutable, we still cannot call <code>push</code>. This is because we already have a reference to an element of the vector, <code>y</code>. Mutating something while another reference exists is dangerous, because we may invalidate the reference. In this specific case, when we create the vector, we may have only allocated space for two elements. Adding a third would mean allocating a new chunk of memory for all those elements, copying the old values over, and updating the internal pointer to that memory. That all works just fine. The problem is that <code>y</code> wouldn‚Äôt get updated, and so we‚Äôd have a ‚Äòdangling pointer‚Äô. That‚Äôs bad. Any use of <code>y</code> would be an error in this case, and so the compiler has caught this for us.</p>
  <p>So how do we solve this problem? There are two approaches we can take. The first is making a copy rather than using a reference:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = x[<span class="dv">0</span>].clone();
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p>Rust has <a href="#move-semantics">move semantics</a> by default, so if we want to make a copy of some data, we call the <code>clone()</code> method. In this example, <code>y</code> is no longer a reference to the vector stored in <code>x</code>, but a copy of its first element, <code>&quot;Hello&quot;</code>. Now that we don‚Äôt have a reference, our <code>push()</code> works just fine.</p>
  <p>If we truly want a reference, we need the other option: ensure that our reference goes out of scope before we try to do the mutation. That looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      {
          <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
      }
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre></div>
  <p>We created an inner scope with an additional set of curly braces. <code>y</code> will go out of scope before we call <code>push()</code>, and so we‚Äôre all good.</p>
  <p>This concept of ownership isn‚Äôt just good for preventing dangling pointers, but an entire set of related problems, like iterator invalidation, concurrency, and more.</p>
  </section>
  </section>
  <section id="sec--getting-started" class="level1">
  <h1>Getting Started</h1>
  <p>This first section of the book will get you going with Rust and its tooling. First, we‚Äôll install Rust. Then, the classic ‚ÄòHello World‚Äô program. Finally, we‚Äôll talk about Cargo, Rust‚Äôs build system and package manager.</p>
  <section id="sec--installing-rust" class="level2">
  <h2>Installing Rust</h2>
  <p>The first step to using Rust is to install it! There are a number of ways to install Rust, but the easiest is to use the <code>rustup</code> script. If you‚Äôre on Linux or a Mac, all you need to do is this:</p>
  <blockquote>
  <p>Note: you don‚Äôt need to type in the <code>$</code>s, they just indicate the start of each command. You‚Äôll see many tutorials and examples around the web that follow this convention: <code>$</code> for commands run as your regular user, and <code>#</code> for commands you should be running as an administrator.</p>
  </blockquote>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -sf -L https://static.rust-lang.org/rustup.sh <span class="kw">|</span> <span class="kw">sh</span></code></pre></div>
  <p>If you‚Äôre concerned about the <a href="http://curlpipesh.tumblr.com">potential insecurity</a> of using <code>curl | sh</code>, please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -f -L https://static.rust-lang.org/rustup.sh -O
  $ <span class="kw">sh</span> rustup.sh</code></pre></div>
  <p>If you‚Äôre on Windows, please download the appropriate <a href="https://www.rust-lang.org/install.html">installer</a>. <strong>NOTE:</strong> By default, the Windows installer will not add Rust to the %PATH% system variable. If this is the only version of Rust you are installing and you want to be able to run it from the command line, click on ‚ÄúAdvanced‚Äù on the install dialog and on the ‚ÄúProduct Features‚Äù page ensure ‚ÄúAdd to PATH‚Äù is installed on the local hard drive.</p>
  <section id="uninstalling" class="level4">
  <h4>Uninstalling</h4>
  <p>If you decide you don‚Äôt want Rust anymore, we‚Äôll be a bit sad, but that‚Äôs okay. Not every programming language is great for everyone. Just run the uninstall script:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> /usr/local/lib/rustlib/uninstall.sh</code></pre></div>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> and it will give you an uninstall option.</p>
  </section>
  <section id="that-disclaimer-we-promised" class="level4">
  <h4>That disclaimer we promised</h4>
  <p>Some people, and somewhat rightfully so, get very upset when we tell you to <code>curl | sh</code>. Basically, when you do this, you are trusting that the good people who maintain Rust aren‚Äôt going to hack your computer and do bad things. That‚Äôs a good instinct! If you‚Äôre one of those people, please check out the documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building Rust from Source</a>, or <a href="https://www.rust-lang.org/install.html">the official binary downloads</a>.</p>
  </section>
  <section id="platform-support" class="level4">
  <h4>Platform support</h4>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or later, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, like Android. But these are the ones most likely to work, as they have the most testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first-class platform upon release, but if we‚Äôre honest, the Windows experience isn‚Äôt as integrated as the Linux/OS X experience is. We‚Äôre working on it! If anything does not work, it is a bug. Please let us know if that happens. Each and every commit is tested against Windows just like any other platform.</p>
  </section>
  <section id="after-installation" class="level4">
  <h4>After installation</h4>
  <p>If you‚Äôve got Rust installed, you can open up a shell, and type this:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> --version</code></pre></div>
  <p>You should see the version number, commit hash, and commit date. If you just installed version 1.2.0, you should see:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">rustc</span> 1.2.0 (082e47636 2015-08-03)</code></pre></div>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>If you didn‚Äôt and you‚Äôre on Windows, check that Rust is in your %PATH% system variable. If it isn‚Äôt, run the installer again, select ‚ÄúChange‚Äù on the ‚ÄúChange, repair, or remove installation‚Äù page and ensure ‚ÄúAdd to PATH‚Äù is installed on the local hard drive.</p>
  <p>This installer also installs a copy of the documentation locally, so you can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</code> is the location. On Windows, it‚Äôs in a <code>share/doc</code> directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easiest is <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which you can access through <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click that link, and you‚Äôll be chatting with other Rustaceans (a silly nickname we call ourselves), and we can help you out. Other great resources include <a href="https://users.rust-lang.org/">the user‚Äôs forum</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
  </section>
  </section>
  <section id="sec--hello-world" class="level2">
  <h2>Hello, world!</h2>
  <p>Now that you have Rust installed, let‚Äôs write your first Rust program. It‚Äôs traditional to make your first program in any new language one that prints the text ‚ÄúHello, world!‚Äù to the screen. The nice thing about starting with such a simple program is that you can verify that your compiler isn‚Äôt just installed, but also working properly. And printing information to the screen is a pretty common thing to do.</p>
  <p>The first thing that we need to do is make a file to put our code in. I like to make a <code>projects</code> directory in my home directory, and keep all my projects there. Rust does not care where your code lives.</p>
  <p>This actually leads to one other concern we should address: this guide will assume that you have basic familiarity with the command line. Rust itself makes no specific demands on your editing tooling, or where your code lives. If you prefer an IDE to the command line, you may want to check out <a href="https://github.com/oakes/SolidOak">SolidOak</a>, or wherever plugins are for your favorite IDE. There are a number of extensions of varying quality in development by the community. The Rust team also ships <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">plugins for various editors</a>. Configuring your editor or IDE is out of the scope of this tutorial, so check the documentation for your setup, specifically.</p>
  <p>With that said, let‚Äôs make a directory in our projects directory.</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> ~/projects
  $ <span class="kw">cd</span> ~/projects
  $ <span class="kw">mkdir</span> hello_world
  $ <span class="kw">cd</span> hello_world</code></pre></div>
  <p>If you‚Äôre on Windows and not using PowerShell, the <code>~</code> may not work. Consult the documentation for your shell for more details.</p>
  <p>Let‚Äôs make a new source file next. We‚Äôll call our file <code>main.rs</code>. Rust files always end in a <code>.rs</code> extension. If you‚Äôre using more than one word in your filename, use an underscore: <code>hello_world.rs</code> rather than <code>helloworld.rs</code>.</p>
  <p>Now that you‚Äôve got your file open, type this in:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre></div>
  <p>Save the file, and then type this into your terminal window:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> main.rs
  $ <span class="kw">./main</span> <span class="co"># or main.exe on Windows</span>
  <span class="kw">Hello</span>, world!</code></pre></div>
  <p>Success! Let‚Äôs go over what just happened in detail.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  
  }</code></pre></div>
  <p>These lines define a <em>function</em> in Rust. The <code>main</code> function is special: it‚Äôs the beginning of every Rust program. The first line says ‚ÄúI‚Äôm declaring a function named <code>main</code> which takes no arguments and returns nothing.‚Äù If there were arguments, they would go inside the parentheses (<code>(</code> and <code>)</code>), and because we aren‚Äôt returning anything from this function, we can omit the return type entirely. We‚Äôll get to it later.</p>
  <p>You‚Äôll also note that the function is wrapped in curly braces (<code>{</code> and <code>}</code>). Rust requires these around all function bodies. It is also considered good style to put the opening curly brace on the same line as the function declaration, with one space in between.</p>
  <p>Next up is this line:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);</code></pre></div>
  <p>This line does all of the work in our little program. There are a number of details that are important here. The first is that it‚Äôs indented with four spaces, not tabs. Please configure your editor of choice to insert four spaces with the tab key. We provide some <a href="https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">sample configurations for various editors</a>.</p>
  <p>The second point is the <code>println!()</code> part. This is calling a Rust <a href="#sec--macros">macro</a>, which is how metaprogramming is done in Rust. If it were a function instead, it would look like this: <code>println()</code>. For our purposes, we don‚Äôt need to worry about this difference. Just know that sometimes, you‚Äôll see a <code>!</code>, and that means that you‚Äôre calling a macro instead of a normal function. Rust implements <code>println!</code> as a macro rather than a function for good reasons, but that‚Äôs an advanced topic. One last thing to mention: Rust‚Äôs macros are significantly different from C macros, if you‚Äôve used those. Don‚Äôt be scared of using macros. We‚Äôll get to the details eventually, you‚Äôll just have to trust us for now.</p>
  <p>Next, <code>&quot;Hello, world!&quot;</code> is a ‚Äòstring‚Äô. Strings are a surprisingly complicated topic in a systems programming language, and this is a ‚Äòstatically allocated‚Äô string. If you want to read further about allocation, check out <a href="#sec--the-stack-and-the-heap">the stack and the heap</a>, but you don‚Äôt need to right now if you don‚Äôt want to. We pass this string as an argument to <code>println!</code>, which prints the string to the screen. Easy enough!</p>
  <p>Finally, the line ends with a semicolon (<code>;</code>). Rust is an <a href="#expression-oriented-language">‚Äòexpression oriented‚Äô language</a>, which means that most things are expressions, rather than statements. The <code>;</code> is used to indicate that this expression is over, and the next one is ready to begin. Most lines of Rust code end with a <code>;</code>.</p>
  <p>Finally, actually compiling and running our program. We can compile with our compiler, <code>rustc</code>, by passing it the name of our source file:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> main.rs</code></pre></div>
  <p>This is similar to <code>gcc</code> or <code>clang</code>, if you come from a C or C++ background. Rust will output a binary executable. You can see it with <code>ls</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span>
  <span class="kw">main</span>  main.rs</code></pre></div>
  <p>Or on Windows:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">dir</span>
  <span class="kw">main.exe</span>  main.rs</code></pre></div>
  <p>There are now two files: our source code, with the <code>.rs</code> extension, and the executable (<code>main.exe</code> on Windows, <code>main</code> everywhere else)</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./main</span>  <span class="co"># or main.exe on Windows</span></code></pre></div>
  <p>This prints out our <code>Hello, world!</code> text to our terminal.</p>
  <p>If you come from a dynamic language like Ruby, Python, or JavaScript, you may not be used to these two steps being separate. Rust is an ‚Äòahead-of-time compiled language‚Äô, which means that you can compile a program, give it to someone else, and they don‚Äôt need to have Rust installed. If you give someone a <code>.rb</code> or <code>.py</code> or <code>.js</code> file, they need to have a Ruby/Python/JavaScript implementation installed, but you just need one command to both compile and run your program. Everything is a tradeoff in language design, and Rust has made its choice.</p>
  <p>Congratulations! You have officially written a Rust program. That makes you a Rust programmer! Welcome. üéäüéâüëç</p>
  <p>Next, I‚Äôd like to introduce you to another tool, Cargo, which is used to write real-world Rust programs. Just using <code>rustc</code> is nice for simple things, but as your project grows, you‚Äôll want something to help you manage all of the options that it has, and to make it easy to share your code with other people and projects.</p>
  </section>
  <section id="sec--hello-cargo" class="level2">
  <h2>Hello, Cargo!</h2>
  <p><a href="http://doc.crates.io">Cargo</a> is a tool that Rustaceans use to help manage their Rust projects. Cargo is currently in a pre-1.0 state, and so it is still a work in progress. However, it is already good enough to use for many Rust projects, and so it is assumed that Rust projects will use Cargo from the beginning.</p>
  <p>Cargo manages three things: building your code, downloading the dependencies your code needs, and building those dependencies. At first, your program doesn‚Äôt have any dependencies, so we‚Äôll only be using the first part of its functionality. Eventually, we‚Äôll add more. Since we started off by using Cargo, it‚Äôll be easy to add later.</p>
  <p>If we installed Rust via the official installers we will also have Cargo. If we installed Rust some other way, we may want to <a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">check the Cargo README</a> for specific instructions about installing it.</p>
  <section id="converting-to-cargo" class="level4">
  <h4>Converting to Cargo</h4>
  <p>Let‚Äôs convert Hello World to Cargo.</p>
  <p>To Cargo-ify our project, we need to do three things: Make a <code>Cargo.toml</code> configuration file, put our source file in the right place, and get rid of the old executable (<code>main.exe</code> on Windows, <code>main</code> everywhere else). Let‚Äôs do that part first:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> src
  $ <span class="kw">mv</span> main.rs src/main.rs
  $ <span class="kw">rm</span> main  <span class="co"># or main.exe on Windows</span></code></pre></div>
  <p>Note that since we‚Äôre creating an executable, we retain <code>main.rs</code> as the source filename. If we want to make a library instead, we should use <code>lib.rs</code>. This convention is used by Cargo to successfully compile our projects, but it can be overridden if we wish. Custom file locations for the entry point can be specified with a <a href="http://doc.crates.io/manifest.html#configuring-a-target"><code>[lib]</code> or <code>[[bin]]</code></a> key in the TOML file.</p>
  <p>Cargo expects your source files to live inside a <code>src</code> directory. That leaves the top level for other things, like READMEs, license information, and anything not related to your code. Cargo helps us keep our projects nice and tidy. A place for everything, and everything in its place.</p>
  <p>Next, our configuration file:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">editor</span> Cargo.toml</code></pre></div>
  <p>Make sure to get this name right: you need the capital <code>C</code>!</p>
  <p>Put this inside:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;
  authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]</code></pre>
  <p>This file is in the <a href="https://github.com/toml-lang/toml">TOML</a> format. TOML is similar to INI, but has some extra goodies. According to the TOML docs,</p>
  <blockquote>
  <p>TOML aims to be a minimal configuration file format that‚Äôs easy to read due to obvious semantics. TOML is designed to map unambiguously to a hash table. TOML should be easy to parse into data structures in a wide variety of languages.</p>
  </blockquote>
  <p>Once we have this file in place in our project‚Äôs root directory, we should be ready to build! To do so, run:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
  $ <span class="kw">./target/debug/hello_world</span>
  <span class="kw">Hello</span>, world!</code></pre></div>
  <p>Bam! We built our project with <code>cargo build</code>, and ran it with <code>./target/debug/hello_world</code>. We can do both in one step with <code>cargo run</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
       <span class="kw">Running</span> <span class="kw">`target/debug/hello_world`</span>
  <span class="kw">Hello</span>, world!</code></pre></div>
  <p>Notice that we didn‚Äôt re-build the project this time. Cargo figured out that we hadn‚Äôt changed the source file, and so it just ran the binary. If we had made a modification, we would have seen it do both:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
       <span class="kw">Running</span> <span class="kw">`target/debug/hello_world`</span>
  <span class="kw">Hello</span>, world!</code></pre></div>
  <p>This hasn‚Äôt bought us a whole lot over our simple use of <code>rustc</code>, but think about the future: when our project gets more complex, we need to do more things to get all of the parts to properly compile. With Cargo, as our project grows, we can just run <code>cargo build</code>, and it‚Äôll work the right way.</p>
  <p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile your project with optimizations.</p>
  <p>You‚Äôll also notice that Cargo has created a new file: <code>Cargo.lock</code>.</p>
  <pre class="toml"><code>[root]
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;</code></pre>
  <p>The <code>Cargo.lock</code> file is used by Cargo to keep track of dependencies in your application. Right now, we don‚Äôt have any, so it‚Äôs a bit sparse. You won‚Äôt ever need to touch this file yourself, just let Cargo handle it.</p>
  <p>That‚Äôs it! We‚Äôve successfully built <code>hello_world</code> with Cargo. Even though our program is simple, it‚Äôs using much of the real tooling that you‚Äôll use for the rest of your Rust career. You can expect to do this to get started with virtually all Rust projects:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone someurl.com/foo
  $ <span class="kw">cd</span> foo
  $ <span class="kw">cargo</span> build</code></pre></div>
  </section>
  <section id="a-new-project" class="level4">
  <h4>A New Project</h4>
  <p>You don‚Äôt have to go through this whole process every time you want to start a new project! Cargo has the ability to make a bare-bones project directory in which you can start developing right away.</p>
  <p>To start a new project with Cargo, use <code>cargo new</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new hello_world --bin</code></pre></div>
  <p>We‚Äôre passing <code>--bin</code> because our goal is to get straight to making an executable application, as opposed to a library. Executables are often called ‚Äòbinaries.‚Äô (as in <code>/usr/bin</code>, if you‚Äôre on a Unix system)</p>
  <p>Let‚Äôs check out what Cargo has generated for us:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cd</span> hello_world
  $ <span class="kw">tree</span> .
  <span class="kw">.</span>
  ‚îú‚îÄ‚îÄ <span class="kw">Cargo.toml</span>
  ‚îî‚îÄ‚îÄ <span class="kw">src</span>
      ‚îî‚îÄ‚îÄ <span class="kw">main.rs</span>
  
  <span class="kw">1</span> directory, 2 files</code></pre></div>
  <p>If you don‚Äôt have the <code>tree</code> command, you can probably get it from your distribution‚Äôs package manager. It‚Äôs not necessary, but it‚Äôs certainly useful.</p>
  <p>This is all we need to get started. First, let‚Äôs check out <code>Cargo.toml</code>:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.1.0&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo has populated this file with reasonable defaults based off the arguments you gave it and your <code>git</code> global configuration. You may notice that Cargo has also initialized the <code>hello_world</code> directory as a <code>git</code> repository.</p>
  <p>Here‚Äôs what‚Äôs in <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre></div>
  <p>Cargo has generated a ‚ÄúHello World!‚Äù for us, and you‚Äôre ready to start coding! Cargo has its own <a href="http://doc.crates.io/guide.html">guide</a> which covers Cargo‚Äôs features in much more depth.</p>
  <p>Now that you‚Äôve got the tools down, let‚Äôs actually learn more about the Rust language itself. These are the basics that will serve you well through the rest of your time with Rust.</p>
  <p>You have two options: Dive into a project with ‚Äò<a href="#sec--learn-rust">Learn Rust</a>‚Äô, or start from the bottom and work your way up with ‚Äò<a href="#sec--syntax-and-semantics">Syntax and Semantics</a>‚Äô. More experienced systems programmers will probably prefer ‚ÄòLearn Rust‚Äô, while those from dynamic backgrounds may enjoy either. Different people learn differently! Choose whatever‚Äôs right for you.</p>
  </section>
  </section>
  </section>
  <section id="sec--learn-rust" class="level1">
  <h1>Learn Rust</h1>
  <p>Welcome! This section has a few tutorials that teach you Rust through building projects. You‚Äôll get a high-level overview, but we‚Äôll skim over the details.</p>
  <p>If you‚Äôd prefer a more ‚Äòfrom the ground up‚Äô-style experience, check out <a href="#sec--syntax-and-semantics">Syntax and Semantics</a>.</p>
  <section id="sec--guessing-game" class="level2">
  <h2>Guessing Game</h2>
  <p>For our first project, we‚Äôll implement a classic beginner programming problem: the guessing game. Here‚Äôs how it works: Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we‚Äôre too low or too high. Once we guess correctly, it will congratulate us. Sounds good?</p>
  <section id="set-up" class="level3">
  <h3>Set up</h3>
  <p>Let‚Äôs set up a new project. Go to your projects directory. Remember how we had to create our directory structure and a <code>Cargo.toml</code> for <code>hello_world</code>? Cargo has a command that does that for us. Let‚Äôs give it a shot:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cd</span> ~/projects
  $ <span class="kw">cargo</span> new guessing_game --bin
  $ <span class="kw">cd</span> guessing_game</code></pre></div>
  <p>We pass the name of our project to <code>cargo new</code>, and then the <code>--bin</code> flag, since we‚Äôre making a binary, rather than a library.</p>
  <p>Check out the generated <code>Cargo.toml</code>:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;guessing_game&quot;
  version = &quot;0.1.0&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo gets this information from your environment. If it‚Äôs not correct, go ahead and fix that.</p>
  <p>Finally, Cargo generated a ‚ÄòHello, world!‚Äô for us. Check out <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre></div>
  <p>Let‚Äôs try compiling what Cargo gave us:</p>
  <pre class="{bash}"><code>$ cargo build
     Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>Excellent! Open up your <code>src/main.rs</code> again. We‚Äôll be writing all of our code in this file.</p>
  <p>Before we move on, let me show you one more Cargo command: <code>run</code>. <code>cargo run</code> is kind of like <code>cargo build</code>, but it also then runs the produced executable. Try it out:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  <span class="kw">Hello</span>, world!</code></pre></div>
  <p>Great! The <code>run</code> command comes in handy when you need to rapidly iterate on a project. Our game is just such a project, we need to quickly test each iteration before moving on to the next one.</p>
  </section>
  <section id="processing-a-guess" class="level3">
  <h3>Processing a Guess</h3>
  <p>Let‚Äôs get to it! The first thing we need to do for our guessing game is allow our player to input a guess. Put this in your <code>src/main.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>There‚Äôs a lot here! Let‚Äôs go over it, bit by bit.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;</code></pre></div>
  <p>We‚Äôll need to take user input, and then print the result as output. As such, we need the <code>io</code> library from the standard library. Rust only imports a few things by default into every program, <a href="http://doc.rust-lang.org/std/prelude/index.html">the ‚Äòprelude‚Äô</a>. If it‚Äôs not in the prelude, you‚Äôll have to <code>use</code> it directly.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {</code></pre></div>
  <p>As you‚Äôve seen before, the <code>main()</code> function is the entry point into your program. The <code>fn</code> syntax declares a new function, the <code>()</code>s indicate that there are no arguments, and <code>{</code> starts the body of the function. Because we didn‚Äôt include a return type, it‚Äôs assumed to be <code>()</code>, an empty <a href="#tuples">tuple</a>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);</code></pre></div>
  <p>We previously learned that <code>println!()</code> is a <a href="#sec--macros">macro</a> that prints a <a href="#sec--strings">string</a> to the screen.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();</code></pre></div>
  <p>Now we‚Äôre getting interesting! There‚Äôs a lot going on in this little line. The first thing to notice is that this is a <a href="#sec--variable-bindings">let statement</a>, which is used to create ‚Äòvariable bindings‚Äô. They take this form:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> foo = bar;</code></pre></div>
  <p>This will create a new binding named <code>foo</code>, and bind it to the value <code>bar</code>. In many languages, this is called a ‚Äòvariable‚Äô, but Rust‚Äôs variable bindings have a few tricks up their sleeves.</p>
  <p>For example, they‚Äôre <a href="#sec--mutability">immutable</a> by default. That‚Äôs why our example uses <code>mut</code>: it makes a binding mutable, rather than immutable. <code>let</code> doesn‚Äôt take a name on the left hand side of the assignment, it actually accepts a ‚Äò<a href="#sec--patterns">pattern</a>‚Äô. We‚Äôll use patterns later. It‚Äôs easy enough to use for now:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> foo = <span class="dv">5</span>; <span class="co">// immutable.</span>
  <span class="kw">let</span> <span class="kw">mut</span> bar = <span class="dv">5</span>; <span class="co">// mutable</span></code></pre></div>
  <p>Oh, and <code>//</code> will start a comment, until the end of the line. Rust ignores everything in <a href="#sec--comments">comments</a>.</p>
  <p>So now we know that <code>let mut guess</code> will introduce a mutable binding named <code>guess</code>, but we have to look at the other side of the <code>=</code> for what it‚Äôs bound to: <code>String::new()</code>.</p>
  <p><code>String</code> is a string type, provided by the standard library. A <a href="http://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a growable, UTF-8 encoded bit of text.</p>
  <p>The <code>::new()</code> syntax uses <code>::</code> because this is an ‚Äòassociated function‚Äô of a particular type. That is to say, it‚Äôs associated with <code>String</code> itself, rather than a particular instance of a <code>String</code>. Some languages call this a ‚Äòstatic method‚Äô.</p>
  <p>This function is named <code>new()</code>, because it creates a new, empty <code>String</code>. You‚Äôll find a <code>new()</code> function on many types, as it‚Äôs a common name for making a new value of some kind.</p>
  <p>Let‚Äôs move forward:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);</code></pre></div>
  <p>That‚Äôs a lot more! Let‚Äôs go bit-by-bit. The first line has two parts. Here‚Äôs the first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">io::stdin()</code></pre></div>
  <p>Remember how we <code>use</code>d <code>std::io</code> on the first line of the program? We‚Äôre now calling an associated function on it. If we didn‚Äôt <code>use std::io</code>, we could have written this line as <code>std::io::stdin()</code>.</p>
  <p>This particular function returns a handle to the standard input for your terminal. More specifically, a <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
  <p>The next part will use this handle to get input from the user:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">.read_line(&amp;<span class="kw">mut</span> guess)</code></pre></div>
  <p>Here, we call the <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> method on our handle. <a href="#sec--method-syntax">Methods</a> are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We‚Äôre also passing one argument to <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
  <p>Remember how we bound <code>guess</code> above? We said it was mutable. However, <code>read_line</code> doesn‚Äôt take a <code>String</code> as an argument: it takes a <code>&amp;mut String</code>. Rust has a feature called ‚Äò<a href="#sec--references-and-borrowing">references</a>‚Äô, which allows you to have multiple references to one piece of data, which can reduce copying. References are a complex feature, as one of Rust‚Äôs major selling points is how safe and easy it is to use references. We don‚Äôt need to know a lot of those details to finish our program right now, though. For now, all we need to know is that like <code>let</code> bindings, references are immutable by default. Hence, we need to write <code>&amp;mut guess</code>, rather than <code>&amp;guess</code>.</p>
  <p>Why does <code>read_line()</code> take a mutable reference to a string? Its job is to take what the user types into standard input, and place that into a string. So it takes that string as an argument, and in order to add the input, it needs to be mutable.</p>
  <p>But we‚Äôre not quite done with this line of code, though. While it‚Äôs a single line of text, it‚Äôs only the first part of the single logical line of code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">        .ok()
          .expect(<span class="st">&quot;Failed to read line&quot;</span>);</code></pre></div>
  <p>When you call a method with the <code>.foo()</code> syntax, you may introduce a newline and other whitespace. This helps you split up long lines. We <em>could</em> have done:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess).ok().expect(<span class="st">&quot;failed to read line&quot;</span>);</code></pre></div>
  <p>But that gets hard to read. So we‚Äôve split it up, three lines for three method calls. We already talked about <code>read_line()</code>, but what about <code>ok()</code> and <code>expect()</code>? Well, we already mentioned that <code>read_line()</code> puts what the user types into the <code>&amp;mut String</code> we pass it. But it also returns a value: in this case, an <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Rust has a number of types named <code>Result</code> in its standard library: a generic <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, and then specific versions for sub-libraries, like <code>io::Result</code>.</p>
  <p>The purpose of these <code>Result</code> types is to encode error handling information. Values of the <code>Result</code> type, like any type, have methods defined on them. In this case, <code>io::Result</code> has an <code>ok()</code> method, which says ‚Äòwe want to assume this value is a successful one. If not, just throw away the error information‚Äô. Why throw it away? Well, for a basic program, we just want to print a generic error, as basically any issue means we can‚Äôt continue. The <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.ok"><code>ok()</code> method</a> returns a value which has another method defined on it: <code>expect()</code>. The <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code> method</a> takes a value it‚Äôs called on, and if it isn‚Äôt a successful one, <a href="#sec--error-handling"><code>panic!</code></a>s with a message you passed it. A <code>panic!</code> like this will cause our program to crash, displaying the message.</p>
  <p>If we leave off calling these two methods, our program will compile, but we‚Äôll get a warning:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  <span class="kw">src</span>/main.rs:<span class="kw">10</span>:5: 10:39 warning: unused result which must be used,
  <span class="co">#[warn(unused_must_use)] on by default</span>
  <span class="kw">src</span>/main.rs:<span class="kw">10</span>     io::stdin()<span class="kw">.read_line</span>(<span class="kw">&amp;mut</span> guess);
                     ^<span class="kw">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></code></pre></div>
  <p>Rust warns us that we haven‚Äôt used the <code>Result</code> value. This warning comes from a special annotation that <code>io::Result</code> has. Rust is trying to tell you that you haven‚Äôt handled a possible error. The right way to suppress the error is to actually write error handling. Luckily, if we just want to crash if there‚Äôs a problem, we can use these two little methods. If we can recover from the error somehow, we‚Äôd do something else, but we‚Äôll save that for a future project.</p>
  <p>There‚Äôs just one line of this first example left:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>This prints out the string we saved our input in. The <code>{}</code>s are a placeholder, and so we pass it <code>guess</code> as an argument. If we had multiple <code>{}</code>s, we would pass multiple arguments:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = <span class="dv">10</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;x and y: {} and {}&quot;</span>, x, y);</code></pre></div>
  <p>Easy.</p>
  <p>Anyway, that‚Äôs the tour. We can run what we have with <code>cargo run</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">Please</span> input your guess.
  <span class="kw">6</span>
  <span class="kw">You</span> guessed: 6</code></pre></div>
  <p>All right! Our first part is done: we can get input from the keyboard, and then print it back out.</p>
  </section>
  <section id="generating-a-secret-number" class="level3">
  <h3>Generating a secret number</h3>
  <p>Next, we need to generate a secret number. Rust does not yet include random number functionality in its standard library. The Rust team does, however, provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>. A ‚Äòcrate‚Äô is a package of Rust code. We‚Äôve been building a ‚Äòbinary crate‚Äô, which is an executable. <code>rand</code> is a ‚Äòlibrary crate‚Äô, which contains code that‚Äôs intended to be used with other programs.</p>
  <p>Using external crates is where Cargo really shines. Before we can write the code using <code>rand</code>, we need to modify our <code>Cargo.toml</code>. Open it up, and add these few lines at the bottom:</p>
  <pre class="toml"><code>[dependencies]
  
  rand=&quot;0.3.0&quot;</code></pre>
  <p>The <code>[dependencies]</code> section of <code>Cargo.toml</code> is like the <code>[package]</code> section: everything that follows it is part of it, until the next section starts. Cargo uses the dependencies section to know what dependencies on external crates you have, and what versions you require. In this case, we‚Äôve specified version <code>0.3.0</code>, which Cargo understands to be any release that‚Äôs compatible with this specific version. Cargo understands <a href="http://semver.org">Semantic Versioning</a>, which is a standard for writing version numbers. If we wanted to use only <code>0.3.0</code> exactly, we could use <code>=0.3.0</code>. If we wanted to use the latest version we could use <code>*</code>; We could use a range of versions. <a href="http://doc.crates.io/crates-io.html">Cargo‚Äôs documentation</a> contains more details.</p>
  <p>Now, without changing any of our code, let‚Äôs build our project:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
      <span class="kw">Updating</span> registry <span class="kw">`https</span>://github.com/rust-lang/crates.io-index<span class="kw">`</span>
   <span class="kw">Downloading</span> rand v0.3.8
   <span class="kw">Downloading</span> libc v0.1.6
     <span class="kw">Compiling</span> libc v0.1.6
     <span class="kw">Compiling</span> rand v0.3.8
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre></div>
  <p>(You may see different versions, of course.)</p>
  <p>Lots of new output! Now that we have an external dependency, Cargo fetches the latest versions of everything from the registry, which is a copy of data from <a href="https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</p>
  <p>After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads any we don‚Äôt have yet. In this case, while we only said we wanted to depend on <code>rand</code>, we‚Äôve also grabbed a copy of <code>libc</code>. This is because <code>rand</code> depends on <code>libc</code> to work. After downloading them, it compiles them, and then compiles our project.</p>
  <p>If we run <code>cargo build</code> again, we‚Äôll get different output:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build</code></pre></div>
  <p>That‚Äôs right, no output! Cargo knows that our project has been built, and that all of its dependencies are built, and so there‚Äôs no reason to do all that stuff. With nothing to do, it simply exits. If we open up <code>src/main.rs</code> again, make a trivial change, and then save it again, we‚Äôll just see one line:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre></div>
  <p>So, we told Cargo we wanted any <code>0.3.x</code> version of <code>rand</code>, and so it fetched the latest version at the time this was written, <code>v0.3.8</code>. But what happens when next week, version <code>v0.3.9</code> comes out, with an important bugfix? While getting bugfixes is important, what if <code>0.3.9</code> contains a regression that breaks our code?</p>
  <p>The answer to this problem is the <code>Cargo.lock</code> file you‚Äôll now find in your project directory. When you build your project for the first time, Cargo figures out all of the versions that fit your criteria, and then writes them to the <code>Cargo.lock</code> file. When you build your project in the future, Cargo will see that the <code>Cargo.lock</code> file exists, and then use that specific version rather than do all the work of figuring out versions again. This lets you have a repeatable build automatically. In other words, we‚Äôll stay at <code>0.3.8</code> until we explicitly upgrade, and so will anyone who we share our code with, thanks to the lock file.</p>
  <p>What about when we <em>do</em> want to use <code>v0.3.9</code>? Cargo has another command, <code>update</code>, which says ‚Äòignore the lock, figure out all the latest versions that fit what we‚Äôve specified. If that works, write those versions out to the lock file‚Äô. But, by default, Cargo will only look for versions larger than <code>0.3.0</code> and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</code>, we‚Äôd have to update the <code>Cargo.toml</code> directly. When we do, the next time we <code>cargo build</code>, Cargo will update the index and re-evaluate our <code>rand</code> requirements.</p>
  <p>There‚Äôs a lot more to say about <a href="http://doc.crates.io">Cargo</a> and <a href="http://doc.crates.io/crates-io.html">its ecosystem</a>, but for now, that‚Äôs all we need to know. Cargo makes it really easy to re-use libraries, and so Rustaceans tend to write smaller projects which are assembled out of a number of sub-packages.</p>
  <p>Let‚Äôs get on to actually <em>using</em> <code>rand</code>. Here‚Äôs our next step:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  }</code></pre></div>
  <p>The first thing we‚Äôve done is change the first line. It now says <code>extern crate rand</code>. Because we declared <code>rand</code> in our <code>[dependencies]</code>, we can use <code>extern crate</code> to let Rust know we‚Äôll be making use of it. This also does the equivalent of a <code>use rand;</code> as well, so we can make use of anything in the <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>
  <p>Next, we added another <code>use</code> line: <code>use rand::Rng</code>. We‚Äôre going to use a method in a moment, and it requires that <code>Rng</code> be in scope to work. The basic idea is this: methods are defined on something called ‚Äòtraits‚Äô, and for the method to work, it needs the trait to be in scope. For more about the details, read the <a href="#sec--traits">traits</a> section.</p>
  <p>There are two other lines we added, in the middle:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);</code></pre></div>
  <p>We use the <code>rand::thread_rng()</code> function to get a copy of the random number generator, which is local to the particular <a href="#sec--concurrency">thread</a> of execution we‚Äôre in. Because we <code>use rand::Rng</code>‚Äôd above, it has a <code>gen_range()</code> method available. This method takes two arguments, and generates a number between them. It‚Äôs inclusive on the lower bound, but exclusive on the upper bound, so we need <code>1</code> and <code>101</code> to get a number ranging from one to a hundred.</p>
  <p>The second line just prints out the secret number. This is useful while we‚Äôre developing our program, so we can easily test it out. But we‚Äôll be deleting it for the final version. It‚Äôs not much of a game if it prints out the answer when you start it up!</p>
  <p>Try running our new program a few times:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">The</span> secret number is: 7
  <span class="kw">Please</span> input your guess.
  <span class="kw">4</span>
  <span class="kw">You</span> guessed: 4
  $ <span class="kw">cargo</span> run
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">The</span> secret number is: 83
  <span class="kw">Please</span> input your guess.
  <span class="kw">5</span>
  <span class="kw">You</span> guessed: 5</code></pre></div>
  <p>Great! Next up: let‚Äôs compare our guess to the secret guess.</p>
  </section>
  <section id="comparing-guesses" class="level3">
  <h3>Comparing guesses</h3>
  <p>Now that we‚Äôve got user input, let‚Äôs compare our guess to the random guess. Here‚Äôs our next step, though it doesn‚Äôt quite compile yet:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
          Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
          Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
      }
  }</code></pre></div>
  <p>A few new bits here. The first is another <code>use</code>. We bring a type called <code>std::cmp::Ordering</code> into scope. Then, five new lines at the bottom that use it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
      Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
      Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
  }</code></pre></div>
  <p>The <code>cmp()</code> method can be called on anything that can be compared, and it takes a reference to the thing you want to compare it to. It returns the <code>Ordering</code> type we <code>use</code>d earlier. We use a <a href="#sec--match"><code>match</code></a> statement to determine exactly what kind of <code>Ordering</code> it is. <code>Ordering</code> is an <a href="#sec--enums"><code>enum</code></a>, short for ‚Äòenumeration‚Äô, which looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Foo {
      Bar,
      Baz,
  }</code></pre></div>
  <p>With this definition, anything of type <code>Foo</code> can be either a <code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</code> to indicate the namespace for a particular <code>enum</code> variant.</p>
  <p>The <a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> <code>enum</code> has three possible variants: <code>Less</code>, <code>Equal</code>, and <code>Greater</code>. The <code>match</code> statement takes a value of a type, and lets you create an ‚Äòarm‚Äô for each possible value. Since we have three types of <code>Ordering</code>, we have three arms:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
      Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
      Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
  }</code></pre></div>
  <p>If it‚Äôs <code>Less</code>, we print <code>Too small!</code>, if it‚Äôs <code>Greater</code>, <code>Too big!</code>, and if <code>Equal</code>, <code>You win!</code>. <code>match</code> is really useful, and is used often in Rust.</p>
  <p>I did mention that this won‚Äôt quite compile yet, though. Let‚Äôs try it:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  <span class="kw">src</span>/main.rs:<span class="kw">28</span>:21: 28:35 error: mismatched types:
   <span class="kw">expected</span> <span class="kw">`&amp;collections</span>::string::String<span class="kw">`</span>,
      <span class="kw">found</span> <span class="kw">`&amp;_`</span>
  <span class="kw">(expected</span> struct <span class="kw">`collections</span>::string::String<span class="kw">`</span>,
      <span class="kw">found</span> integral variable<span class="kw">)</span> [<span class="kw">E0308</span>]
  <span class="kw">src</span>/main.rs:<span class="kw">28</span>     match guess.cmp(<span class="kw">&amp;secret_number</span>) <span class="kw">{</span>
                                     ^<span class="kw">~~~~~~~~~~~~~</span>
  <span class="kw">error</span>: aborting due to previous error
  <span class="kw">Could</span> not compile <span class="kw">`guessing_game`</span>.</code></pre></div>
  <p>Whew! This is a big error. The core of it is that we have ‚Äòmismatched types‚Äô. Rust has a strong, static type system. However, it also has type inference. When we wrote <code>let guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be a <code>String</code>, and so it doesn‚Äôt make us write out the type. And with our <code>secret_number</code>, there are a number of types which can have a value between one and a hundred: <code>i32</code>, a thirty-two-bit number, or <code>u32</code>, an unsigned thirty-two-bit number, or <code>i64</code>, a sixty-four-bit number or others. So far, that hasn‚Äôt mattered, and so Rust defaults to an <code>i32</code>. However, here, Rust doesn‚Äôt know how to compare the <code>guess</code> and the <code>secret_number</code>. They need to be the same type. Ultimately, we want to convert the <code>String</code> we read as input into a real number type, for comparison. We can do that with three more lines. Here‚Äôs our new program:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
      <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
          Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
          Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
      }
  }</code></pre></div>
  <p>The new three lines:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Please type a number!&quot;</span>);</code></pre></div>
  <p>Wait a minute, I thought we already had a <code>guess</code>? We do, but Rust allows us to ‚Äòshadow‚Äô the previous <code>guess</code> with a new one. This is often used in this exact situation, where <code>guess</code> starts as a <code>String</code>, but we want to convert it to an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, rather than forcing us to come up with two unique names like <code>guess_str</code> and <code>guess</code>, or something else.</p>
  <p>We bind <code>guess</code> to an expression that looks like something we wrote earlier:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">guess.trim().parse()</code></pre></div>
  <p>Followed by an <code>ok().expect()</code> invocation. Here, <code>guess</code> refers to the old <code>guess</code>, the one that was a <code>String</code> with our input in it. The <code>trim()</code> method on <code>String</code>s will eliminate any white space at the beginning and end of our string. This is important, as we had to press the ‚Äòreturn‚Äô key to satisfy <code>read_line()</code>. This means that if we type <code>5</code> and hit return, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents ‚Äònewline‚Äô, the enter key. <code>trim()</code> gets rid of this, leaving our string with just the <code>5</code>. The <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code> method on strings</a> parses a string into some kind of number. Since it can parse a variety of numbers, we need to give Rust a hint as to the exact type of number we want. Hence, <code>let guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> tells Rust we‚Äôre going to annotate its type. <code>u32</code> is an unsigned, thirty-two bit integer. Rust has <a href="#numeric-types">a number of built-in number types</a>, but we‚Äôve chosen <code>u32</code>. It‚Äôs a good default choice for a small positive number.</p>
  <p>Just like <code>read_line()</code>, our call to <code>parse()</code> could cause an error. What if our string contained <code>Aüëç%</code>? There‚Äôd be no way to convert that to a number. As such, we‚Äôll do the same thing we did with <code>read_line()</code>: use the <code>ok()</code> and <code>expect()</code> methods to crash if there‚Äôs an error.</p>
  <p>Let‚Äôs try our program out!</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">The</span> secret number is: 58
  <span class="kw">Please</span> input your guess.
    <span class="kw">76</span>
  <span class="kw">You</span> guessed: 76
  <span class="kw">Too</span> big!</code></pre></div>
  <p>Nice! You can see I even added spaces before my guess, and it still figured out that I guessed 76. Run the program a few times, and verify that guessing the number works, as well as guessing a number too small.</p>
  <p>Now we‚Äôve got most of the game working, but we can only make one guess. Let‚Äôs change that by adding loops!</p>
  </section>
  <section id="looping" class="level3">
  <h3>Looping</h3>
  <p>The <code>loop</code> keyword gives us an infinite loop. Let‚Äôs add that in:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>),
          }
      }
  }</code></pre></div>
  <p>And try it out. But wait, didn‚Äôt we just add an infinite loop? Yup. Remember our discussion about <code>parse()</code>? If we give a non-number answer, we‚Äôll <code>return</code> and quit. Observe:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">The</span> secret number is: 59
  <span class="kw">Please</span> input your guess.
  <span class="kw">45</span>
  <span class="kw">You</span> guessed: 45
  <span class="kw">Too</span> small!
  <span class="kw">Please</span> input your guess.
  <span class="kw">60</span>
  <span class="kw">You</span> guessed: 60
  <span class="kw">Too</span> big!
  <span class="kw">Please</span> input your guess.
  <span class="kw">59</span>
  <span class="kw">You</span> guessed: 59
  <span class="kw">You</span> win!
  <span class="kw">Please</span> input your guess.
  <span class="kw">quit</span>
  <span class="kw">thread</span> <span class="st">'&lt;main&gt;'</span> panicked at <span class="st">'Please type a number!'</span></code></pre></div>
  <p>Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is suboptimal to say the least. First, let‚Äôs actually quit when you win the game:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Please type a number!&quot;</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>By adding the <code>break</code> line after the <code>You win!</code>, we‚Äôll exit the loop when we win. Exiting the loop also means exiting the program, since it‚Äôs the last thing in <code>main()</code>. We have just one more tweak to make: when someone inputs a non-number, we don‚Äôt want to quit, we just want to ignore it. We can do that like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;The secret number is: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="cn">Ok</span>(num) =&gt; num,
              <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  <p>These are the lines that changed:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
      <span class="cn">Ok</span>(num) =&gt; num,
      <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
  };</code></pre></div>
  <p>This is how you generally move from ‚Äòcrash on error‚Äô to ‚Äòactually handle the error‚Äô, by switching from <code>ok().expect()</code> to a <code>match</code> statement. The <code>Result</code> returned by <code>parse()</code> is an <code>enum</code> just like <code>Ordering</code>, but in this case, each variant has some data associated with it: <code>Ok</code> is a success, and <code>Err</code> is a failure. Each contains more information: the successfully parsed integer, or an error type. In this case, we <code>match</code> on <code>Ok(num)</code>, which sets the inner value of the <code>Ok</code> to the name <code>num</code>, and then we just return it on the right-hand side. In the <code>Err</code> case, we don‚Äôt care what kind of error it is, so we just use <code>_</code> instead of a name. This ignores the error, and <code>continue</code> causes us to go to the next iteration of the <code>loop</code>.</p>
  <p>Now we should be good! Let‚Äôs try:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  <span class="kw">Guess</span> the number!
  <span class="kw">The</span> secret number is: 61
  <span class="kw">Please</span> input your guess.
  <span class="kw">10</span>
  <span class="kw">You</span> guessed: 10
  <span class="kw">Too</span> small!
  <span class="kw">Please</span> input your guess.
  <span class="kw">99</span>
  <span class="kw">You</span> guessed: 99
  <span class="kw">Too</span> big!
  <span class="kw">Please</span> input your guess.
  <span class="kw">foo</span>
  <span class="kw">Please</span> input your guess.
  <span class="kw">61</span>
  <span class="kw">You</span> guessed: 61
  <span class="kw">You</span> win!</code></pre></div>
  <p>Awesome! With one tiny last tweak, we have finished the guessing game. Can you think of what it is? That‚Äôs right, we don‚Äôt want to print out the secret number. It was good for testing, but it kind of ruins the game. Here‚Äôs our final source:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Guess the number!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="kw">loop</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Please input your guess.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = <span class="dt">String</span>::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;failed to read line&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="dt">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="cn">Ok</span>(num) =&gt; num,
              <span class="cn">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="pp">println!</span>(<span class="st">&quot;You guessed: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
              Ordering::Greater =&gt; <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="pp">println!</span>(<span class="st">&quot;You win!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre></div>
  </section>
  <section id="complete" class="level3">
  <h3>Complete!</h3>
  <p>At this point, you have successfully built the Guessing Game! Congratulations!</p>
  <p>This first project showed you a lot: <code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more. Our next project will show off even more.</p>
  </section>
  </section>
  <section id="sec--dining-philosophers" class="level2">
  <h2>Dining Philosophers</h2>
  <p>For our second project, let‚Äôs look at a classic concurrency problem. It‚Äôs called ‚Äòthe dining philosophers‚Äô. It was originally conceived by Dijkstra in 1965, but we‚Äôll use a lightly adapted version from <a href="http://www.usingcsp.com/cspbook.pdf">this paper</a> by Tony Hoare in 1985.</p>
  <blockquote>
  <p>In ancient times, a wealthy philanthropist endowed a College to accommodate five eminent philosophers. Each philosopher had a room in which they could engage in their professional activity of thinking; there was also a common dining room, furnished with a circular table, surrounded by five chairs, each labelled by the name of the philosopher who was to sit in it. They sat anticlockwise around the table. To the left of each philosopher there was laid a golden fork, and in the centre stood a large bowl of spaghetti, which was constantly replenished. A philosopher was expected to spend most of their time thinking; but when they felt hungry, they went to the dining room, sat down in their own chair, picked up their own fork on their left, and plunged it into the spaghetti. But such is the tangled nature of spaghetti that a second fork is required to carry it to the mouth. The philosopher therefore had also to pick up the fork on their right. When they were finished they would put down both their forks, get up from their chair, and continue thinking. Of course, a fork can be used by only one philosopher at a time. If the other philosopher wants it, they just have to wait until the fork is available again.</p>
  </blockquote>
  <p>This classic problem shows off a few different elements of concurrency. The reason is that it‚Äôs actually slightly tricky to implement: a simple implementation can deadlock. For example, let‚Äôs consider a simple algorithm that would solve this problem:</p>
  <ol type="1">
  <li>A philosopher picks up the fork on their left.</li>
  <li>They then pick up the fork on their right.</li>
  <li>They eat.</li>
  <li>They return the forks.</li>
  </ol>
  <p>Now, let‚Äôs imagine this sequence of events:</p>
  <ol type="1">
  <li>Philosopher 1 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 2 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 3 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 4 begins the algorithm, picking up the fork on their left.</li>
  <li>Philosopher 5 begins the algorithm, picking up the fork on their left.</li>
  <li>‚Ä¶ ? All the forks are taken, but nobody can eat!</li>
  </ol>
  <p>There are different ways to solve this problem. We‚Äôll get to our solution in the tutorial itself. For now, let‚Äôs get started modelling the problem itself. We‚Äôll start with the philosophers:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>);
  }</code></pre></div>
  <p>Here, we make a <a href="#sec--structs"><code>struct</code></a> to represent a philosopher. For now, a name is all we need. We choose the <a href="#sec--strings"><code>String</code></a> type for the name, rather than <code>&amp;str</code>. Generally speaking, working with a type which owns its data is easier than working with one that uses references.</p>
  <p>Let‚Äôs continue:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }</code></pre></div>
  <p>This <code>impl</code> block lets us define things on <code>Philosopher</code> structs. In this case, we define an ‚Äòassociated function‚Äô called <code>new</code>. The first line looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {</code></pre></div>
  <p>We take one argument, a <code>name</code>, of type <code>&amp;str</code>. This is a reference to another string. It returns an instance of our <code>Philosopher</code> struct.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Philosopher {
      name: name.to_string(),
  }</code></pre></div>
  <p>This creates a new <code>Philosopher</code>, and sets its <code>name</code> to our <code>name</code> argument. Not just the argument itself, though, as we call <code>.to_string()</code> on it. This will create a copy of the string that our <code>&amp;str</code> points to, and give us a new <code>String</code>, which is the type of the <code>name</code> field of <code>Philosopher</code>.</p>
  <p>Why not accept a <code>String</code> directly? It‚Äôs nicer to call. If we took a <code>String</code>, but our caller had a <code>&amp;str</code>, they‚Äôd have to call this method themselves. The downside of this flexibility is that we <em>always</em> make a copy. For this small program, that‚Äôs not particularly important, as we know we‚Äôll just be using short strings anyway.</p>
  <p>One last thing you‚Äôll notice: we just define a <code>Philosopher</code>, and seemingly don‚Äôt do anything with it. Rust is an ‚Äòexpression based‚Äô language, which means that almost everything in Rust is an expression which returns a value. This is true of functions as well, the last expression is automatically returned. Since we create a new <code>Philosopher</code> as the last expression of this function, we end up returning it.</p>
  <p>This name, <code>new()</code>, isn‚Äôt anything special to Rust, but it is a convention for functions that create new instances of structs. Before we talk about why, let‚Äôs look at <code>main()</code> again:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>);
  }</code></pre></div>
  <p>Here, we create five variable bindings with five new philosophers. These are my favorite five, but you can substitute anyone you want. If we <em>didn‚Äôt</em> define that <code>new()</code> function, it would look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher { name: <span class="st">&quot;Judith Butler&quot;</span>.to_string() };
      <span class="kw">let</span> p2 = Philosopher { name: <span class="st">&quot;Gilles Deleuze&quot;</span>.to_string() };
      <span class="kw">let</span> p3 = Philosopher { name: <span class="st">&quot;Karl Marx&quot;</span>.to_string() };
      <span class="kw">let</span> p4 = Philosopher { name: <span class="st">&quot;Emma Goldman&quot;</span>.to_string() };
      <span class="kw">let</span> p5 = Philosopher { name: <span class="st">&quot;Michel Foucault&quot;</span>.to_string() };
  }</code></pre></div>
  <p>That‚Äôs much noisier. Using <code>new</code> has other advantages too, but even in this simple case, it ends up being nicer to use.</p>
  <p>Now that we‚Äôve got the basics in place, there‚Äôs a number of ways that we can tackle the broader problem here. I like to start from the end first: let‚Äôs set up a way for each philosopher to finish eating. As a tiny step, let‚Äôs make a method, and then loop through all the philosophers, calling it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">for</span> p <span class="kw">in</span> &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Let‚Äôs look at <code>main()</code> first. Rather than have five individual variable bindings for our philosophers, we make a <code>Vec&lt;T&gt;</code> of them instead. <code>Vec&lt;T&gt;</code> is also called a ‚Äòvector‚Äô, and it‚Äôs a growable array type. We then use a <a href="#sec--for-loops"><code>for</code></a> loop to iterate through the vector, getting a reference to each philosopher in turn.</p>
  <p>In the body of the loop, we call <code>p.eat()</code>, which is defined above:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre></div>
  <p>In Rust, methods take an explicit <code>self</code> parameter. That‚Äôs why <code>eat()</code> is a method, but <code>new</code> is an associated function: <code>new()</code> has no <code>self</code>. For our first version of <code>eat()</code>, we just print out the name of the philosopher, and mention they‚Äôre done eating. Running this program should give you the following output:</p>
  <pre class="text"><code>Judith Butler is done eating.
  Gilles Deleuze is done eating.
  Karl Marx is done eating.
  Emma Goldman is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Easy enough, they‚Äôre all done! We haven‚Äôt actually implemented the real problem yet, though, so we‚Äôre not done yet!</p>
  <p>Next, we want to make our philosophers not just finish eating, but actually eat. Here‚Äôs the next version:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">for</span> p <span class="kw">in</span> &amp;philosophers {
          p.eat();
      }
  }</code></pre></div>
  <p>Just a few changes. Let‚Äôs break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;</code></pre></div>
  <p><code>use</code> brings names into scope. We‚Äôre going to start using the <code>thread</code> module from the standard library, and so we need to <code>use</code> it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }</code></pre></div>
  <p>We now print out two messages, with a <code>sleep_ms()</code> in the middle. This will simulate the time it takes a philosopher to eat.</p>
  <p>If you run this program, you should see each philosopher eat in turn:</p>
  <pre class="text"><code>Judith Butler is eating.
  Judith Butler is done eating.
  Gilles Deleuze is eating.
  Gilles Deleuze is done eating.
  Karl Marx is eating.
  Karl Marx is done eating.
  Emma Goldman is eating.
  Emma Goldman is done eating.
  Michel Foucault is eating.
  Michel Foucault is done eating.</code></pre>
  <p>Excellent! We‚Äôre getting there. There‚Äôs just one problem: we aren‚Äôt actually operating in a concurrent fashion, which is a core part of the problem!</p>
  <p>To make our philosophers eat concurrently, we need to make a small change. Here‚Äôs the next iteration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>),
          Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>),
      ];
  
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
          thread::spawn(<span class="kw">move</span> || {
              p.eat();
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>All we‚Äôve done is change the loop in <code>main()</code>, and added a second one! Here‚Äôs the first change:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
      thread::spawn(<span class="kw">move</span> || {
          p.eat();
      })
  }).collect();</code></pre></div>
  <p>While this is only five lines, they‚Äôre a dense five. Let‚Äôs break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; =</code></pre></div>
  <p>We introduce a new binding, called <code>handles</code>. We‚Äôve given it this name because we are going to make some new threads, and that will return some handles to those threads that let us control their operation. We need to explicitly annotate the type here, though, due to an issue we‚Äôll talk about later. The <code>_</code> is a type placeholder. We‚Äôre saying ‚Äú<code>handles</code> is a vector of something, but you can figure out what that something is, Rust.‚Äù</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">philosophers.into_iter().map(|p| {</code></pre></div>
  <p>We take our list of philosophers and call <code>into_iter()</code> on it. This creates an iterator that takes ownership of each philosopher. We need to do this to pass them to our threads. We take that iterator and call <code>map</code> on it, which takes a closure as an argument and calls that closure on each element in turn.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    thread::spawn(<span class="kw">move</span> || {
          p.eat();
      })</code></pre></div>
  <p>Here‚Äôs where the concurrency happens. The <code>thread::spawn</code> function takes a closure as an argument and executes that closure in a new thread. This closure needs an extra annotation, <code>move</code>, to indicate that the closure is going to take ownership of the values it‚Äôs capturing. Primarily, the <code>p</code> variable of the <code>map</code> function.</p>
  <p>Inside the thread, all we do is call <code>eat()</code> on <code>p</code>. Also note that the call to <code>thread::spawn</code> lacks a trailing semicolon, making this an expression. This distinction is important, yielding the correct return value. For more details, read <a href="functions.html#expressions-vs.-statements">Expressions vs.¬†Statements</a>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">}).collect();</code></pre></div>
  <p>Finally, we take the result of all those <code>map</code> calls and collect them up. <code>collect()</code> will make them into a collection of some kind, which is why we needed to annotate the return type: we want a <code>Vec&lt;T&gt;</code>. The elements are the return values of the <code>thread::spawn</code> calls, which are handles to those threads. Whew!</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> h <span class="kw">in</span> handles {
      h.join().unwrap();
  }</code></pre></div>
  <p>At the end of <code>main()</code>, we loop through the handles and call <code>join()</code> on them, which blocks execution until the thread has completed execution. This ensures that the threads complete their work before the program exits.</p>
  <p>If you run this program, you‚Äôll see that the philosophers eat out of order! We have multi-threading!</p>
  <pre class="text"><code>Judith Butler is eating.
  Gilles Deleuze is eating.
  Karl Marx is eating.
  Emma Goldman is eating.
  Michel Foucault is eating.
  Judith Butler is done eating.
  Gilles Deleuze is done eating.
  Karl Marx is done eating.
  Emma Goldman is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>But what about the forks? We haven‚Äôt modeled them at all yet.</p>
  <p>To do that, let‚Äôs make a new <code>struct</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Mutex;
  
  <span class="kw">struct</span> Table {
      forks: <span class="dt">Vec</span>&lt;Mutex&lt;()&gt;&gt;,
  }</code></pre></div>
  <p>This <code>Table</code> has a vector of <code>Mutex</code>es. A mutex is a way to control concurrency: only one thread can access the contents at once. This is exactly the property we need with our forks. We use an empty tuple, <code>()</code>, inside the mutex, since we‚Äôre not actually going to use the value, just hold onto it.</p>
  <p>Let‚Äôs modify the program to use the <code>Table</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::{Mutex, Arc};
  
  <span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
      left: <span class="dt">usize</span>,
      right: <span class="dt">usize</span>,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>, left: <span class="dt">usize</span>, right: <span class="dt">usize</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
              left: left,
              right: right,
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
          <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
          <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">struct</span> Table {
      forks: <span class="dt">Vec</span>&lt;Mutex&lt;()&gt;&gt;,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> table = Arc::new(Table { forks: <span class="pp">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});
  
      <span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
          Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
          Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
          Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
          Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
          Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
      ];
  
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
          <span class="kw">let</span> table = table.clone();
  
          thread::spawn(<span class="kw">move</span> || {
              p.eat(&amp;table);
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          h.join().unwrap();
      }
  }</code></pre></div>
  <p>Lots of changes! However, with this iteration, we‚Äôve got a working program. Let‚Äôs go over the details:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Mutex, Arc};</code></pre></div>
  <p>We‚Äôre going to use another structure from the <code>std::sync</code> package: <code>Arc&lt;T&gt;</code>. We‚Äôll talk more about it when we use it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: <span class="dt">String</span>,
      left: <span class="dt">usize</span>,
      right: <span class="dt">usize</span>,
  }</code></pre></div>
  <p>We need to add two more fields to our <code>Philosopher</code>. Each philosopher is going to have two forks: the one on their left, and the one on their right. We‚Äôll use the <code>usize</code> type to indicate them, as it‚Äôs the type that you index vectors with. These two values will be the indexes into the <code>forks</code> our <code>Table</code> has.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="dt">str</span>, left: <span class="dt">usize</span>, right: <span class="dt">usize</span>) -&gt; Philosopher {
      Philosopher {
          name: name.to_string(),
          left: left,
          right: right,
      }
  }</code></pre></div>
  <p>We now need to construct those <code>left</code> and <code>right</code> values, so we add them to <code>new()</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
      <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
      <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
      <span class="pp">println!</span>(<span class="st">&quot;{} is eating.&quot;</span>, <span class="kw">self</span>.name);
  
      thread::sleep_ms(<span class="dv">1000</span>);
  
      <span class="pp">println!</span>(<span class="st">&quot;{} is done eating.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre></div>
  <p>We have two new lines. We‚Äôve also added an argument, <code>table</code>. We access the <code>Table</code>‚Äôs list of forks, and then use <code>self.left</code> and <code>self.right</code> to access the fork at that particular index. That gives us access to the <code>Mutex</code> at that index, and we call <code>lock()</code> on it. If the mutex is currently being accessed by someone else, we‚Äôll block until it becomes available.</p>
  <p>The call to <code>lock()</code> might fail, and if it does, we want to crash. In this case, the error that could happen is that the mutex is <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning">‚Äòpoisoned‚Äô</a>, which is what happens when the thread panics while the lock is held. Since this shouldn‚Äôt happen, we just use <code>unwrap()</code>.</p>
  <p>One other odd thing about these lines: we‚Äôve named the results <code>_left</code> and <code>_right</code>. What‚Äôs up with that underscore? Well, we aren‚Äôt planning on <em>using</em> the value inside the lock. We just want to acquire it. As such, Rust will warn us that we never use the value. By using the underscore, we tell Rust that this is what we intended, and it won‚Äôt throw a warning.</p>
  <p>What about releasing the lock? Well, that will happen when <code>_left</code> and <code>_right</code> go out of scope, automatically.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> table = Arc::new(Table { forks: <span class="pp">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});</code></pre></div>
  <p>Next, in <code>main()</code>, we make a new <code>Table</code> and wrap it in an <code>Arc&lt;T&gt;</code>. ‚Äòarc‚Äô stands for ‚Äòatomic reference count‚Äô, and we need that to share our <code>Table</code> across multiple threads. As we share it, the reference count will go up, and when each thread ends, it will go back down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> philosophers = <span class="pp">vec!</span>[
      Philosopher::new(<span class="st">&quot;Judith Butler&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
      Philosopher::new(<span class="st">&quot;Gilles Deleuze&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
      Philosopher::new(<span class="st">&quot;Karl Marx&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
      Philosopher::new(<span class="st">&quot;Emma Goldman&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
      Philosopher::new(<span class="st">&quot;Michel Foucault&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
  ];</code></pre></div>
  <p>We need to pass in our <code>left</code> and <code>right</code> values to the constructors for our <code>Philosopher</code>s. But there‚Äôs one more detail here, and it‚Äôs <em>very</em> important. If you look at the pattern, it‚Äôs all consistent until the very end. Monsieur Foucault should have <code>4, 0</code> as arguments, but instead, has <code>0, 4</code>. This is what prevents deadlock, actually: one of our philosophers is left handed! This is one way to solve the problem, and in my opinion, it‚Äôs the simplest.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = philosophers.into_iter().map(|p| {
      <span class="kw">let</span> table = table.clone();
  
      thread::spawn(<span class="kw">move</span> || {
          p.eat(&amp;table);
      })
  }).collect();</code></pre></div>
  <p>Finally, inside of our <code>map()</code>/<code>collect()</code> loop, we call <code>table.clone()</code>. The <code>clone()</code> method on <code>Arc&lt;T&gt;</code> is what bumps up the reference count, and when it goes out of scope, it decrements the count. This is needed so that we know how many references to <code>table</code> exist across our threads. If we didn‚Äôt have a count, we wouldn‚Äôt know how to deallocate it.</p>
  <p>You‚Äôll notice we can introduce a new binding to <code>table</code> here, and it will shadow the old one. This is often used so that you don‚Äôt need to come up with two unique names.</p>
  <p>With this, our program works! Only two philosophers can eat at any one time, and so you‚Äôll get some output like this:</p>
  <pre class="text"><code>Gilles Deleuze is eating.
  Emma Goldman is eating.
  Emma Goldman is done eating.
  Gilles Deleuze is done eating.
  Judith Butler is eating.
  Karl Marx is eating.
  Judith Butler is done eating.
  Michel Foucault is eating.
  Karl Marx is done eating.
  Michel Foucault is done eating.</code></pre>
  <p>Congrats! You‚Äôve implemented a classic concurrency problem in Rust.</p>
  </section>
  <section id="sec--rust-inside-other-languages" class="level2">
  <h2>Rust Inside Other Languages</h2>
  <p>For our third project, we‚Äôre going to choose something that shows off one of Rust‚Äôs greatest strengths: a lack of a substantial runtime.</p>
  <p>As organizations grow, they increasingly rely on a multitude of programming languages. Different programming languages have different strengths and weaknesses, and a polyglot stack lets you use a particular language where its strengths make sense and a different one where it‚Äôs weak.</p>
  <p>A very common area where many programming languages are weak is in runtime performance of programs. Often, using a language that is slower, but offers greater programmer productivity, is a worthwhile trade-off. To help mitigate this, they provide a way to write some of your system in C and then call that C code as though it were written in the higher-level language. This is called a ‚Äòforeign function interface‚Äô, often shortened to ‚ÄòFFI‚Äô.</p>
  <p>Rust has support for FFI in both directions: it can call into C code easily, but crucially, it can also be called <em>into</em> as easily as C. Combined with Rust‚Äôs lack of a garbage collector and low runtime requirements, this makes Rust a great candidate to embed inside of other languages when you need that extra oomph.</p>
  <p>There is a whole <a href="#sec--ffi">chapter devoted to FFI</a> and its specifics elsewhere in the book, but in this chapter, we‚Äôll examine this particular use-case of FFI, with examples in Ruby, Python, and JavaScript.</p>
  <section id="the-problem" class="level3">
  <h3>The problem</h3>
  <p>There are many different projects we could choose here, but we‚Äôre going to pick an example where Rust has a clear advantage over many other languages: numeric computing and threading.</p>
  <p>Many languages, for the sake of consistency, place numbers on the heap, rather than on the stack. Especially in languages that focus on object-oriented programming and use garbage collection, heap allocation is the default. Sometimes optimizations can stack allocate particular numbers, but rather than relying on an optimizer to do its job, we may want to ensure that we‚Äôre always using primitive number types rather than some sort of object type.</p>
  <p>Second, many languages have a ‚Äòglobal interpreter lock‚Äô (GIL), which limits concurrency in many situations. This is done in the name of safety, which is a positive effect, but it limits the amount of work that can be done at the same time, which is a big negative.</p>
  <p>To emphasize these two aspects, we‚Äôre going to create a little project that uses these two aspects heavily. Since the focus of the example is to embed Rust into other languages, rather than the problem itself, we‚Äôll just use a toy example:</p>
  <blockquote>
  <p>Start ten threads. Inside each thread, count from one to five million. After all ten threads are finished, print out ‚Äòdone!‚Äô.</p>
  </blockquote>
  <p>I chose five million based on my particular computer. Here‚Äôs an example of this code in Ruby:</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">threads = []
  
  <span class="dv">10</span>.times <span class="kw">do</span>
    threads &lt;&lt; <span class="dt">Thread</span>.new <span class="kw">do</span>
      count = <span class="dv">0</span>
  
      <span class="dv">5_000_000</span>.times <span class="kw">do</span>
        count += <span class="dv">1</span>
      <span class="kw">end</span>
  
      count
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  threads.each <span class="kw">do</span> |t|
    puts <span class="st">&quot;Thread finished with count=</span><span class="ot">#{</span>t.value<span class="ot">}</span><span class="st">&quot;</span>
  <span class="kw">end</span>
  puts <span class="st">&quot;done!&quot;</span></code></pre></div>
  <p>Try running this example, and choose a number that runs for a few seconds. Depending on your computer‚Äôs hardware, you may have to increase or decrease the number.</p>
  <p>On my system, running this program takes <code>2.156</code> seconds. And, if I use some sort of process monitoring tool, like <code>top</code>, I can see that it only uses one core on my machine. That‚Äôs the GIL kicking in.</p>
  <p>While it‚Äôs true that this is a synthetic program, one can imagine many problems that are similar to this in the real world. For our purposes, spinning up a few busy threads represents some sort of parallel, expensive computation.</p>
  </section>
  <section id="a-rust-library" class="level3">
  <h3>A Rust library</h3>
  <p>Let‚Äôs rewrite this problem in Rust. First, let‚Äôs make a new project with Cargo:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new embed
  $ <span class="kw">cd</span> embed</code></pre></div>
  <p>This program is fairly easy to write in Rust:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> process() {
      <span class="kw">let</span> handles: <span class="dt">Vec</span>&lt;_&gt; = (<span class="dv">0.</span>.<span class="dv">10</span>).map(|_| {
          thread::spawn(|| {
              <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">0</span>;
              <span class="kw">for</span> _ <span class="kw">in</span> (<span class="dv">0.</span>.<span class="dv">5_000_000</span>) {
                  x += <span class="dv">1</span>
              }
              x
          })
      }).collect();
  
      <span class="kw">for</span> h <span class="kw">in</span> handles {
          <span class="pp">println!</span>(<span class="st">&quot;Thread finished with count={}&quot;</span>,
          h.join().map_err(|_| <span class="st">&quot;Could not join a thread!&quot;</span>).unwrap());
      }
      <span class="pp">println!</span>(<span class="st">&quot;done!&quot;</span>);
  }</code></pre></div>
  <p>Some of this should look familiar from previous examples. We spin up ten threads, collecting them into a <code>handles</code> vector. Inside of each thread, we loop five million times, and add one to <code>x</code> each time. Finally, we join on each thread.</p>
  <p>Right now, however, this is a Rust library, and it doesn‚Äôt expose anything that‚Äôs callable from C. If we tried to hook this up to another language right now, it wouldn‚Äôt work. We only need to make two small changes to fix this, though. The first is to modify the beginning of our code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>no_mangle<span class="at">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> process() {</code></pre></div>
  <p>We have to add a new attribute, <code>no_mangle</code>. When you create a Rust library, it changes the name of the function in the compiled output. The reasons for this are outside the scope of this tutorial, but in order for other languages to know how to call the function, we can‚Äôt do that. This attribute turns that behavior off.</p>
  <p>The other change is the <code>pub extern</code>. The <code>pub</code> means that this function should be callable from outside of this module, and the <code>extern</code> says that it should be able to be called from C. That‚Äôs it! Not a whole lot of change.</p>
  <p>The second thing we need to do is to change a setting in our <code>Cargo.toml</code>. Add this at the bottom:</p>
  <pre class="toml"><code>[lib]
  name = &quot;embed&quot;
  crate-type = [&quot;dylib&quot;]</code></pre>
  <p>This tells Rust that we want to compile our library into a standard dynamic library. By default, Rust compiles an ‚Äòrlib‚Äô, a Rust-specific format.</p>
  <p>Let‚Äôs build the project now:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build --release
     <span class="kw">Compiling</span> embed v0.1.0 (file:///home/steve/src/embed)</code></pre></div>
  <p>We‚Äôve chosen <code>cargo build --release</code>, which builds with optimizations on. We want this to be as fast as possible! You can find the output of the library in <code>target/release</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span> target/release/
  <span class="kw">build</span>  deps  examples  libembed.so  native</code></pre></div>
  <p>That <code>libembed.so</code> is our ‚Äòshared object‚Äô library. We can use this file just like any shared object library written in C! As an aside, this may be <code>embed.dll</code> or <code>libembed.dylib</code>, depending on the platform.</p>
  <p>Now that we‚Äôve got our Rust library built, let‚Äôs use it from our Ruby.</p>
  </section>
  <section id="ruby" class="level3">
  <h3>Ruby</h3>
  <p>Open up an <code>embed.rb</code> file inside of our project, and do this:</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">'ffi'</span>
  
  <span class="kw">module</span> <span class="dt">Hello</span>
    extend <span class="dt">FFI</span>::<span class="dt">Library</span>
    ffi_lib <span class="st">'target/release/libembed.so'</span>
    attach_function <span class="st">:process</span>, [], <span class="st">:void</span>
  <span class="kw">end</span>
  
  <span class="dt">Hello</span>.process
  
  puts <span class="st">'done!'</span></code></pre></div>
  <p>Before we can run this, we need to install the <code>ffi</code> gem:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gem</span> install ffi <span class="co"># this may need sudo</span>
  <span class="kw">Fetching</span>: ffi-1.9.8.gem (100%)
  <span class="kw">Building</span> native extensions.  This could take a while...
  <span class="kw">Successfully</span> installed ffi-1.9.8
  <span class="kw">Parsing</span> documentation for ffi-1.9.8
  <span class="kw">Installing</span> ri documentation for ffi-1.9.8
  <span class="kw">Done</span> installing documentation for ffi after 0 seconds
  <span class="kw">1</span> gem installed</code></pre></div>
  <p>And finally, we can try running it:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ruby</span> embed.rb
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">Thread</span> finished with count=5000000
  <span class="kw">done</span>!
  <span class="kw">done</span>!
  $</code></pre></div>
  <p>Whoa, that was fast! On my system, this took <code>0.086</code> seconds, rather than the two seconds the pure Ruby version took. Let‚Äôs break down this Ruby code:</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">'ffi'</span></code></pre></div>
  <p>We first need to require the <code>ffi</code> gem. This lets us interface with our Rust library like a C library.</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Hello</span>
    extend <span class="dt">FFI</span>::<span class="dt">Library</span>
    ffi_lib <span class="st">'target/release/libembed.so'</span></code></pre></div>
  <p>The <code>Hello</code> module is used to attach the native functions from the shared library. Inside, we <code>extend</code> the necessary <code>FFI::Library</code> module and then call <code>ffi_lib</code> to load up our shared object library. We just pass it the path that our library is stored, which, as we saw before, is <code>target/release/libembed.so</code>.</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">attach_function <span class="st">:process</span>, [], <span class="st">:void</span></code></pre></div>
  <p>The <code>attach_function</code> method is provided by the FFI gem. It‚Äôs what connects our <code>process()</code> function in Rust to a Ruby function of the same name. Since <code>process()</code> takes no arguments, the second parameter is an empty array, and since it returns nothing, we pass <code>:void</code> as the final argument.</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Hello</span>.process</code></pre></div>
  <p>This is the actual call into Rust. The combination of our <code>module</code> and the call to <code>attach_function</code> sets this all up. It looks like a Ruby function but is actually Rust!</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">puts <span class="st">'done!'</span></code></pre></div>
  <p>Finally, as per our project‚Äôs requirements, we print out <code>done!</code>.</p>
  <p>That‚Äôs it! As we‚Äôve seen, bridging between the two languages is really easy, and buys us a lot of performance.</p>
  <p>Next, let‚Äôs try Python!</p>
  </section>
  <section id="python" class="level3">
  <h3>Python</h3>
  <p>Create an <code>embed.py</code> file in this directory, and put this in it:</p>
  <div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> ctypes <span class="im">import</span> cdll
  
  lib <span class="op">=</span> cdll.LoadLibrary(<span class="st">&quot;target/release/libembed.so&quot;</span>)
  
  lib.process()
  
  <span class="bu">print</span>(<span class="st">&quot;done!&quot;</span>)</code></pre></div>
  <p>Even easier! We use <code>cdll</code> from the <code>ctypes</code> module. A quick call to <code>LoadLibrary</code> later, and we can call <code>process()</code>.</p>
  <p>On my system, this takes <code>0.017</code> seconds. Speedy!</p>
  </section>
  <section id="node.js" class="level3">
  <h3>Node.js</h3>
  <p>Node isn‚Äôt a language, but it‚Äôs currently the dominant implementation of server-side JavaScript.</p>
  <p>In order to do FFI with Node, we first need to install the library:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">npm</span> install ffi</code></pre></div>
  <p>After that installs, we can use it:</p>
  <div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ffi <span class="op">=</span> <span class="at">require</span>(<span class="st">'ffi'</span>)<span class="op">;</span>
  
  <span class="kw">var</span> lib <span class="op">=</span> <span class="va">ffi</span>.<span class="at">Library</span>(<span class="st">'target/release/libembed'</span><span class="op">,</span> <span class="op">{</span>
    <span class="st">'process'</span><span class="op">:</span> [<span class="st">'void'</span><span class="op">,</span> []]
  <span class="op">}</span>)<span class="op">;</span>
  
  <span class="va">lib</span>.<span class="at">process</span>()<span class="op">;</span>
  
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;done!&quot;</span>)<span class="op">;</span></code></pre></div>
  <p>It looks more like the Ruby example than the Python example. We use the <code>ffi</code> module to get access to <code>ffi.Library()</code>, which loads up our shared object. We need to annotate the return type and argument types of the function, which are <code>void</code> for return and an empty array to signify no arguments. From there, we just call it and print the result.</p>
  <p>On my system, this takes a quick <code>0.092</code> seconds.</p>
  </section>
  <section id="conclusion" class="level3">
  <h3>Conclusion</h3>
  <p>As you can see, the basics of doing this are <em>very</em> easy. Of course, there‚Äôs a lot more that we could do here. Check out the <a href="#sec--ffi">FFI</a> chapter for more details.</p>
  </section>
  </section>
  </section>
  <section id="sec--effective-rust" class="level1">
  <h1>Effective Rust</h1>
  <p>So you‚Äôve learned how to write some Rust code. But there‚Äôs a difference between writing <em>any</em> Rust code and writing <em>good</em> Rust code.</p>
  <p>This section consists of relatively independent tutorials which show you how to take your Rust to the next level. Common patterns and standard library features will be introduced. Read these sections in any order of your choosing.</p>
  <section id="sec--the-stack-and-the-heap" class="level2">
  <h2>The Stack and the Heap</h2>
  <p>As a systems language, Rust operates at a low level. If you‚Äôre coming from a high-level language, there are some aspects of systems programming that you may not be familiar with. The most important one is how memory works, with a stack and a heap. If you‚Äôre familiar with how C-like languages use stack allocation, this chapter will be a refresher. If you‚Äôre not, you‚Äôll learn about this more general concept, but with a Rust-y focus.</p>
  <section id="memory-management" class="level3">
  <h3>Memory management</h3>
  <p>These two terms are about memory management. The stack and the heap are abstractions that help you determine when to allocate and deallocate memory.</p>
  <p>Here‚Äôs a high-level comparison:</p>
  <p>The stack is very fast, and is where memory is allocated in Rust by default. But the allocation is local to a function call, and is limited in size. The heap, on the other hand, is slower, and is explicitly allocated by your program. But it‚Äôs effectively unlimited in size, and is globally accessible.</p>
  </section>
  <section id="the-stack" class="level3">
  <h3>The Stack</h3>
  <p>Let‚Äôs talk about this Rust program:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  }</code></pre></div>
  <p>This program has one variable binding, <code>x</code>. This memory needs to be allocated from somewhere. Rust ‚Äòstack allocates‚Äô by default, which means that basic values ‚Äògo on the stack‚Äô. What does that mean?</p>
  <p>Well, when a function gets called, some memory gets allocated for all of its local variables and some other information. This is called a ‚Äòstack frame‚Äô, and for the purpose of this tutorial, we‚Äôre going to ignore the extra information and just consider the local variables we‚Äôre allocating. So in this case, when <code>main()</code> is run, we‚Äôll allocate a single 32-bit integer for our stack frame. This is automatically handled for you, as you can see; we didn‚Äôt have to write any special Rust code or anything.</p>
  <p>When the function is over, its stack frame gets deallocated. This happens automatically, we didn‚Äôt have to do anything special here.</p>
  <p>That‚Äôs all there is for this simple program. The key thing to understand here is that stack allocation is very, very fast. Since we know all the local variables we have ahead of time, we can grab the memory all at once. And since we‚Äôll throw them all away at the same time as well, we can get rid of it very fast too.</p>
  <p>The downside is that we can‚Äôt keep values around if we need them for longer than a single function. We also haven‚Äôt talked about what the word, ‚Äòstack‚Äô, means. To do that, we need a slightly more complicated example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> y = <span class="dv">5</span>;
      <span class="kw">let</span> z = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre></div>
  <p>This program has three variables total: two in <code>foo()</code>, one in <code>main()</code>. Just as before, when <code>main()</code> is called, a single integer is allocated for its stack frame. But before we can show what happens when <code>foo()</code> is called, we need to visualize what‚Äôs going on with memory. Your operating system presents a view of memory to your program that‚Äôs pretty simple: a huge list of addresses, from 0 to a large number, representing how much RAM your computer has. For example, if you have a gigabyte of RAM, your addresses go from <code>0</code> to <code>1,073,741,823</code>. That number comes from 2<sup>30</sup>, the number of bytes in a gigabyte.</p>
  <p>This memory is kind of like a giant array: addresses start at zero and go up to the final number. So here‚Äôs a diagram of our first stack frame:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>We‚Äôve got <code>x</code> located at address <code>0</code>, with the value <code>42</code>.</p>
  <p>When <code>foo()</code> is called, a new stack frame is allocated:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Because <code>0</code> was taken by the first frame, <code>1</code> and <code>2</code> are used for <code>foo()</code>‚Äôs stack frame. It grows upward, the more functions we call.</p>
  <p>There‚Äôs some important things we have to take note of here. The numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no relationship to the actual numbers the computer will actually use. In particular, the series of addresses are in reality going to be separated by some number of bytes that separate each address, and that separation may even exceed the size of the value being stored.</p>
  <p>After <code>foo()</code> is over, its frame is deallocated:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then, after <code>main()</code>, even this last value goes away. Easy!</p>
  <p>It‚Äôs called a ‚Äòstack‚Äô because it works like a stack of dinner plates: the first plate you put down is the last plate to pick back up. Stacks are sometimes called ‚Äòlast in, first out queues‚Äô for this reason, as the last value you put on the stack is the first one you retrieve from it.</p>
  <p>Let‚Äôs try a three-deep example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar() {
      <span class="kw">let</span> i = <span class="dv">6</span>;
  }
  
  <span class="kw">fn</span> foo() {
      <span class="kw">let</span> a = <span class="dv">5</span>;
      <span class="kw">let</span> b = <span class="dv">100</span>;
      <span class="kw">let</span> c = <span class="dv">1</span>;
  
      bar();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre></div>
  <p>Okay, first, we call <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Next up, <code>main()</code> calls <code>foo()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> calls <code>bar()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">6</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Whew! Our stack is growing tall.</p>
  <p>After <code>bar()</code> is over, its frame is deallocated, leaving just <code>foo()</code> and <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then <code>foo()</code> ends, leaving just <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>And then we‚Äôre done. Getting the hang of it? It‚Äôs like piling up dishes: you add to the top, you take away from the top.</p>
  </section>
  <section id="the-heap" class="level3">
  <h3>The Heap</h3>
  <p>Now, this works pretty well, but not everything can work like this. Sometimes, you need to pass some memory between different functions, or keep it alive for longer than a single function‚Äôs execution. For this, we can use the heap.</p>
  <p>In Rust, you can allocate memory on the heap with the <a href="http://doc.rust-lang.org/std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a>. Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(<span class="dv">5</span>);
      <span class="kw">let</span> y = <span class="dv">42</span>;
  }</code></pre></div>
  <p>Here‚Äôs what happens in memory when <code>main()</code> is called:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate space for two variables on the stack. <code>y</code> is <code>42</code>, as it always has been, but what about <code>x</code>? Well, <code>x</code> is a <code>Box&lt;i32&gt;</code>, and boxes allocate memory on the heap. The actual value of the box is a structure which has a pointer to ‚Äòthe heap‚Äô. When we start executing the function, and <code>Box::new()</code> is called, it allocates some memory for the heap, and puts <code>5</code> there. The memory now looks like this:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  </tbody>
  </table>
  <p>We have (2<sup>30</sup>) - 1 in our hypothetical computer with 1GB of RAM. And since our stack grows from zero, the easiest place to allocate memory is from the other end. So our first value is at the highest place in memory. And the value of the struct at <code>x</code> has a <a href="#sec--raw-pointers">raw pointer</a> to the place we‚Äôve allocated on the heap, so the value of <code>x</code> is (2<sup>30</sup>) - 1, the memory location we‚Äôve asked for.</p>
  <p>We haven‚Äôt really talked too much about what it actually means to allocate and deallocate memory in these contexts. Getting into very deep detail is out of the scope of this tutorial, but what‚Äôs important to point out here is that the heap isn‚Äôt just a stack that grows from the opposite end. We‚Äôll have an example of this later in the book, but because the heap can be allocated and freed in any order, it can end up with ‚Äòholes‚Äô. Here‚Äôs a diagram of the memory layout of a program which has been running for a while now:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 3</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 4</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 4</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  </tbody>
  </table>
  <p>In this case, we‚Äôve allocated four things on the heap, but deallocated two of them. There‚Äôs a gap between (2<sup>30</sup>) - 1 and (2<sup>30</sup>) - 4 which isn‚Äôt currently being used. The specific details of how and why this happens depends on what kind of strategy you use to manage the heap. Different programs can use different ‚Äòmemory allocators‚Äô, which are libraries that manage this for you. Rust programs use <a href="http://www.canonware.com/jemalloc/">jemalloc</a> for this purpose.</p>
  <p>Anyway, back to our example. Since this memory is on the heap, it can stay alive longer than the function which allocates the box. In this case, however, it doesn‚Äôt.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> When the function is over, we need to free the stack frame for <code>main()</code>. <code>Box&lt;T&gt;</code>, though, has a trick up its sleeve: <a href="#sec--drop">Drop</a>. The implementation of <code>Drop</code> for <code>Box</code> deallocates the memory that was allocated when it was created. Great! So when <code>x</code> goes away, it first frees the memory allocated on the heap:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>And then the stack frame goes away, freeing all of our memory.</p>
  </section>
  <section id="arguments-and-borrowing" class="level3">
  <h3>Arguments and borrowing</h3>
  <p>We‚Äôve got some basic examples with the stack and the heap going, but what about function arguments and borrowing? Here‚Äôs a small Rust program:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(i: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> z = <span class="dv">42</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
      <span class="kw">let</span> y = &amp;x;
  
      foo(y);
  }</code></pre></div>
  <p>When we enter <code>main()</code>, memory looks like this:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p><code>x</code> is a plain old <code>5</code>, and <code>y</code> is a reference to <code>x</code>. So its value is the memory location that <code>x</code> lives at, which in this case is <code>0</code>.</p>
  <p>What about when we call <code>foo()</code>, passing <code>y</code> as an argument?</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p>Stack frames aren‚Äôt just for local bindings, they‚Äôre for arguments too. So in this case, we need to have both <code>i</code>, our argument, and <code>z</code>, our local variable binding. <code>i</code> is a copy of the argument, <code>y</code>. Since <code>y</code>‚Äôs value is <code>0</code>, so is <code>i</code>‚Äôs.</p>
  <p>This is one reason why borrowing a variable doesn‚Äôt deallocate any memory: the value of a reference is just a pointer to a memory location. If we got rid of the underlying memory, things wouldn‚Äôt work very well.</p>
  </section>
  <section id="a-complex-example" class="level3">
  <h3>A complex example</h3>
  <p>Okay, let‚Äôs go through this complex program step-by-step:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> y = <span class="dv">10</span>;
      <span class="kw">let</span> z = &amp;y;
  
      baz(z);
      bar(x, z);
  }
  
  <span class="kw">fn</span> bar(a: &amp;<span class="dt">i32</span>, b: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> c = <span class="dv">5</span>;
      <span class="kw">let</span> d = <span class="dt">Box</span>::new(<span class="dv">5</span>);
      <span class="kw">let</span> e = &amp;d;
  
      baz(e);
  }
  
  <span class="kw">fn</span> baz(f: &amp;<span class="dt">i32</span>) {
      <span class="kw">let</span> g = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> h = <span class="dv">3</span>;
      <span class="kw">let</span> i = <span class="dt">Box</span>::new(<span class="dv">20</span>);
      <span class="kw">let</span> j = &amp;h;
  
      foo(j);
  }</code></pre></div>
  <p>First, we call <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We allocate memory for <code>j</code>, <code>i</code>, and <code>h</code>. <code>i</code> is on the heap, and so has a value pointing there.</p>
  <p>Next, at the end of <code>main()</code>, <code>foo()</code> gets called:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Space gets allocated for <code>x</code>, <code>y</code>, and <code>z</code>. The argument <code>x</code> has the same value as <code>j</code>, since that‚Äôs what we passed it in. It‚Äôs a pointer to the <code>0</code> address, since <code>j</code> points at <code>h</code>.</p>
  <p>Next, <code>foo()</code> calls <code>baz()</code>, passing <code>z</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We‚Äôve allocated memory for <code>f</code> and <code>g</code>. <code>baz()</code> is very short, so when it‚Äôs over, we get rid of its stack frame:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, <code>foo()</code> calls <code>bar()</code> with <code>x</code> and <code>z</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">‚Üí 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>We end up allocating another value on the heap, and so we have to subtract one from (2<sup>30</sup>) - 1. It‚Äôs easier to just write that than <code>1,073,741,822</code>. In any case, we set up the variables as usual.</p>
  <p>At the end of <code>bar()</code>, it calls <code>baz()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">12</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">11</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">‚Üí 9</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">‚Üí 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>With this, we‚Äôre at our deepest point! Whew! Congrats for following along this far.</p>
  <p>After <code>baz()</code> is over, we get rid of <code>f</code> and <code>g</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">‚Üí 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Next, we return from <code>bar()</code>. <code>d</code> in this case is a <code>Box&lt;T&gt;</code>, so it also frees what it points to: (2<sup>30</sup>) - 2.</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">‚Üí 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And after that, <code>foo()</code> returns:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Address</th>
  <th style="text-align: left;">Name</th>
  <th style="text-align: left;">Value</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  <td style="text-align: left;">‚Ä¶</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">‚Üí 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">‚Üí (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>And then, finally, <code>main()</code>, which cleans the rest up. When <code>i</code> is <code>Drop</code>ped, it will clean up the last of the heap too.</p>
  </section>
  <section id="what-do-other-languages-do" class="level3">
  <h3>What do other languages do?</h3>
  <p>Most languages with a garbage collector heap-allocate by default. This means that every value is boxed. There are a number of reasons why this is done, but they‚Äôre out of scope for this tutorial. There are some possible optimizations that don‚Äôt make it true 100% of the time, too. Rather than relying on the stack and <code>Drop</code> to clean up memory, the garbage collector deals with the heap instead.</p>
  </section>
  <section id="which-to-use" class="level3">
  <h3>Which to use?</h3>
  <p>So if the stack is faster and easier to manage, why do we need the heap? A big reason is that Stack-allocation alone means you only have LIFO semantics for reclaiming storage. Heap-allocation is strictly more general, allowing storage to be taken from and returned to the pool in arbitrary order, but at a complexity cost.</p>
  <p>Generally, you should prefer stack allocation, and so, Rust stack-allocates by default. The LIFO model of the stack is simpler, at a fundamental level. This has two big impacts: runtime efficiency and semantic impact.</p>
  <section id="runtime-efficiency" class="level4">
  <h4>Runtime Efficiency</h4>
  <p>Managing the memory for the stack is trivial: The machine just increments or decrements a single value, the so-called ‚Äústack pointer‚Äù. Managing memory for the heap is non-trivial: heap-allocated memory is freed at arbitrary points, and each block of heap-allocated memory can be of arbitrary size, the memory manager must generally work much harder to identify memory for reuse.</p>
  <p>If you‚Äôd like to dive into this topic in greater detail, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688">this paper</a> is a great introduction.</p>
  </section>
  <section id="semantic-impact" class="level4">
  <h4>Semantic impact</h4>
  <p>Stack-allocation impacts the Rust language itself, and thus the developer‚Äôs mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e.¬†expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols, potentially from outside the language itself, to drive deallocation (reference counting, as used by <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, is one example of this).</p>
  <p>When taken to the extreme, the increased expressive power of heap allocation comes at the cost of either significant runtime support (e.g.¬†in the form of a garbage collector) or significant programmer effort (in the form of explicit memory management calls that require verification not provided by the Rust compiler).</p>
  </section>
  </section>
  </section>
  <section id="sec--testing" class="level2">
  <h2>Testing</h2>
  <blockquote>
  <p>Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.</p>
  <p>Edsger W. Dijkstra, ‚ÄúThe Humble Programmer‚Äù (1972)</p>
  </blockquote>
  <p>Let‚Äôs talk about how to test Rust code. What we will not be talking about is the right way to test Rust code. There are many schools of thought regarding the right and wrong way to write tests. All of these approaches use the same basic tools, and so we‚Äôll show you the syntax for using them.</p>
  <section id="the-test-attribute" class="level3">
  <h3>The <code>test</code> attribute</h3>
  <p>At its simplest, a test in Rust is a function that‚Äôs annotated with the <code>test</code> attribute. Let‚Äôs make a new project with Cargo called <code>adder</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new adder
  $ <span class="kw">cd</span> adder</code></pre></div>
  <p>Cargo will automatically generate a simple test when you make a new project. Here‚Äôs the contents of <code>src/lib.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
  }</code></pre></div>
  <p>Note the <code>#[test]</code>. This attribute indicates that this is a test function. It currently has no body. That‚Äôs good enough to pass! We can run the tests with <code>cargo test</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>Cargo compiled and ran our tests. There are two sets of output here: one for the test we wrote, and another for documentation tests. We‚Äôll talk about those later. For now, see this line:</p>
  <pre class="text"><code>test it_works ... ok</code></pre>
  <p>Note the <code>it_works</code>. This comes from the name of our function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> it_works() {</code></pre></div>
  <p>We also get a summary line:</p>
  <pre class="text"><code>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>So why does our do-nothing test pass? Any test which doesn‚Äôt <code>panic!</code> passes, and any test that does <code>panic!</code> fails. Let‚Äôs make our test fail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert!</span>(<span class="cn">false</span>);
  }</code></pre></div>
  <p><code>assert!</code> is a macro provided by Rust which takes one argument: if the argument is <code>true</code>, nothing happens. If the argument is false, it <code>panic!</code>s. Let‚Äôs run our tests again:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... FAILED
  
  <span class="kw">failures</span>:
  
  <span class="kw">----</span> it_works stdout ----
          <span class="kw">thread</span> <span class="st">'it_works'</span> panicked at <span class="st">'assertion failed: false'</span>, /home/steve/tmp/adder
  ‚Ü≥ <span class="kw">/src</span>/lib.rs:<span class="kw">3</span>
  
  
  
  <span class="kw">failures</span>:
      <span class="kw">it_works</span>
  
  <span class="kw">test</span> result: FAILED. 0 passed<span class="kw">;</span> <span class="kw">1</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
  <span class="kw">thread</span> <span class="st">'&lt;main&gt;'</span> panicked at <span class="st">'Some tests failed'</span>, /home/steve/src/rust/src/libtest/lib.
  ‚Ü≥ <span class="kw">rs</span>:247</code></pre></div>
  <p>Rust indicates that our test failed:</p>
  <pre class="text"><code>test it_works ... FAILED</code></pre>
  <p>And that‚Äôs reflected in the summary line:</p>
  <pre class="text"><code>test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured</code></pre>
  <p>We also get a non-zero status code. We can use <code>$?</code> on OS X and Linux:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> <span class="ot">$?</span>
  <span class="kw">101</span></code></pre></div>
  <p>On Windows, if you‚Äôre using <code>cmd</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">echo</span> %ERRORLEVEL%</code></pre></div>
  <p>And if you‚Äôre using PowerShell:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">echo</span> <span class="ot">$LASTEXITCODE</span> <span class="co"># the code itself</span>
  <span class="kw">&gt;</span> <span class="kw">echo</span> <span class="ot">$?</span> <span class="co"># a boolean, fail or succeed</span></code></pre></div>
  <p>This is useful if you want to integrate <code>cargo test</code> into other tooling.</p>
  <p>We can invert our test‚Äôs failure with another attribute: <code>should_panic</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>should_panic<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert!</span>(<span class="cn">false</span>);
  }</code></pre></div>
  <p>This test will now succeed if we <code>panic!</code> and fail if we complete. Let‚Äôs try it:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>Rust provides another macro, <code>assert_eq!</code>, that compares two arguments for equality:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>should_panic<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre></div>
  <p>Does this test pass or fail? Because of the <code>should_panic</code> attribute, it passes:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p><code>should_panic</code> tests can be fragile, as it‚Äôs hard to guarantee that the test didn‚Äôt fail for an unexpected reason. To help with this, an optional <code>expected</code> parameter can be added to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. A safer version of the example above would be:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>should_panic<span class="at">(</span>expected <span class="at">=</span> <span class="st">&quot;assertion failed&quot;</span><span class="at">)]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre></div>
  <p>That‚Äôs all there is to the basics! Let‚Äôs write one ‚Äòreal‚Äô test:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
  }</code></pre></div>
  <p>This is a very common use of <code>assert_eq!</code>: call some function with some known arguments and compare it to the expected output.</p>
  </section>
  <section id="the-ignore-attribute" class="level3">
  <h3>The <code>ignore</code> attribute</h3>
  <p>Sometimes a few specific tests can be very time-consuming to execute. These can be disabled by default by using the <code>ignore</code> attribute:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
  }
  
  <span class="at">#[</span>test<span class="at">]</span>
  <span class="at">#[</span>ignore<span class="at">]</span>
  <span class="kw">fn</span> expensive_test() {
      <span class="co">// code that takes an hour to run</span>
  }</code></pre></div>
  <p>Now we run our tests and see that <code>it_works</code> is run, but <code>expensive_test</code> is not:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> expensive_test ... ignored
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">1</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>The expensive tests can be run explicitly using <code>cargo test -- --ignored</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test -- --ignored
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> expensive_test ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>The <code>--ignored</code> argument is an argument to the test binary, and not to cargo, which is why the command is <code>cargo test -- --ignored</code>.</p>
  </section>
  <section id="the-tests-module" class="level3">
  <h3>The <code>tests</code> module</h3>
  <p>There is one way in which our existing example is not idiomatic: it‚Äôs missing the <code>tests</code> module. The idiomatic way of writing our example looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::add_two;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>There‚Äôs a few changes here. The first is the introduction of a <code>mod tests</code> with a <code>cfg</code> attribute. The module allows us to group all of our tests together, and to also define helper functions if needed, that don‚Äôt become a part of the rest of our crate. The <code>cfg</code> attribute only compiles our test code if we‚Äôre currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.</p>
  <p>The second change is the <code>use</code> declaration. Because we‚Äôre in an inner module, we need to bring our test function into scope. This can be annoying if you have a large module, and so this is a common use of globs. Let‚Äôs change our <code>src/lib.rs</code> to make use of it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the different <code>use</code> line. Now we run our tests:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
      <span class="kw">Updating</span> registry <span class="kw">`https</span>://github.com/rust-lang/crates.io-index<span class="kw">`</span>
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> tests::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>It works!</p>
  <p>The current convention is to use the <code>tests</code> module to hold your ‚Äúunit-style‚Äù tests. Anything that just tests one small bit of functionality makes sense to go here. But what about ‚Äúintegration-style‚Äù tests instead? For that, we have the <code>tests</code> directory</p>
  </section>
  <section id="the-tests-directory" class="level3">
  <h3>The <code>tests</code> directory</h3>
  <p>To write an integration test, let‚Äôs make a <code>tests</code> directory, and put a <code>tests/lib.rs</code> file inside, with this as its contents:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> adder;
  
  <span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="pp">assert_eq!</span>(<span class="dv">4</span>, adder::add_two(<span class="dv">2</span>));
  }</code></pre></div>
  <p>This looks similar to our previous tests, but slightly different. We now have an <code>extern crate adder</code> at the top. This is because the tests in the <code>tests</code> directory are an entirely separate crate, and so we need to import our library. This is also why <code>tests</code> is a suitable place to write integration-style tests: they use the library like any other consumer of it would.</p>
  <p>Let‚Äôs run them:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> tests::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
       <span class="kw">Running</span> target/lib-c18e7d3494509e74
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>Now we have three sections: our previous test is also run, as well as our new one.</p>
  <p>That‚Äôs all there is to the <code>tests</code> directory. The <code>tests</code> module isn‚Äôt needed here, since the whole thing is focused on tests.</p>
  <p>Let‚Äôs finally check out that third section: documentation tests.</p>
  </section>
  <section id="documentation-tests" class="level3">
  <h3>Documentation tests</h3>
  <p>Nothing is better than documentation with examples. Nothing is worse than examples that don‚Äôt actually work, because the code has changed since the documentation has been written. To this end, Rust supports automatically running examples in your documentation (<strong>note:</strong> this only works in library crates, not binary crates). Here‚Äôs a fleshed-out <code>src/lib.rs</code> with examples:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! The `adder` crate provides functions that add numbers to other numbers.</span>
  <span class="co">//!</span>
  <span class="co">//! # Examples</span>
  <span class="co">//!</span>
  <span class="co">//! ```</span>
  <span class="co">//! assert_eq!(4, adder::add_two(2));</span>
  <span class="co">//! ```</span>
  
  <span class="co">/// This function adds two to its argument.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use adder::add_two;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(4, add_two(2));</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the module-level documentation with <code>//!</code> and the function-level documentation with <code>///</code>. Rust‚Äôs documentation supports Markdown in comments, and so triple graves mark code blocks. It is conventional to include the <code># Examples</code> section, exactly like that, with examples following.</p>
  <p>Let‚Äôs run the tests again:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/steve/tmp/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> tests::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
       <span class="kw">Running</span> target/lib-c18e7d3494509e74
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> add_two_0 ... ok
  <span class="kw">test</span> _0 ... ok
  
  <span class="kw">test</span> result: ok. 2 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre></div>
  <p>Now we have all three kinds of tests running! Note the names of the documentation tests: the <code>_0</code> is generated for the module test, and <code>add_two_0</code> for the function test. These will auto increment with names like <code>add_two_1</code> as you add more examples.</p>
  </section>
  </section>
  <section id="sec--conditional-compilation" class="level2">
  <h2>Conditional Compilation</h2>
  <p>Rust has a special attribute, <code>#[cfg]</code>, which allows you to compile code based on a flag passed to the compiler. It has two forms:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>foo<span class="at">)]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>bar <span class="at">=</span> <span class="st">&quot;baz&quot;</span><span class="at">)]</span></code></pre></div>
  <p>They also have some helpers:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>unix<span class="at">,</span> windows<span class="at">))]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>all<span class="at">(</span>unix<span class="at">,</span> target_pointer_width <span class="at">=</span> <span class="st">&quot;32&quot;</span><span class="at">))]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>not<span class="at">(</span>foo<span class="at">))]</span></code></pre></div>
  <p>These can nest arbitrarily:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>not<span class="at">(</span>unix<span class="at">),</span> all<span class="at">(</span>target_os<span class="at">=</span><span class="st">&quot;macos&quot;</span><span class="at">,</span> target_arch <span class="at">=</span> <span class="st">&quot;powerpc&quot;</span><span class="at">)))]</span></code></pre></div>
  <p>As for how to enable or disable these switches, if you‚Äôre using Cargo, they get set in the <a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section"><code>[features]</code> section</a> of your <code>Cargo.toml</code>:</p>
  <pre class="toml"><code>[features]
  # no features by default
  default = []
  
  # The ‚Äúsecure-password‚Äù feature depends on the bcrypt package.
  secure-password = [&quot;bcrypt&quot;]</code></pre>
  <p>When you do this, Cargo passes along a flag to <code>rustc</code>:</p>
  <pre class="text"><code>--cfg feature=&quot;${feature_name}&quot;</code></pre>
  <p>The sum of these <code>cfg</code> flags will determine which ones get activated, and therefore, which code gets compiled. Let‚Äôs take this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>feature <span class="at">=</span> <span class="st">&quot;foo&quot;</span><span class="at">)]</span>
  <span class="kw">mod</span> foo {
  }</code></pre></div>
  <p>If we compile it with <code>cargo build --features &quot;foo&quot;</code>, it will send the <code>--cfg feature=&quot;foo&quot;</code> flag to <code>rustc</code>, and the output will have the <code>mod foo</code> in it. If we compile it with a regular <code>cargo build</code>, no extra flags get passed on, and so, no <code>foo</code> module will exist.</p>
  <section id="cfg_attr" class="level3">
  <h3>cfg_attr</h3>
  <p>You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg_attr<span class="at">(</span>a<span class="at">,</span> b<span class="at">)]</span></code></pre></div>
  <p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code> attribute, and nothing otherwise.</p>
  </section>
  <section id="cfg" class="level3">
  <h3>cfg!</h3>
  <p>The <code>cfg!</code> <a href="#sec--compiler-plugins">syntax extension</a> lets you use these kinds of flags elsewhere in your code, too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="pp">cfg!</span>(target_os = <span class="st">&quot;macos&quot;</span>) || <span class="pp">cfg!</span>(target_os = <span class="st">&quot;ios&quot;</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;Think Different!&quot;</span>);
  }</code></pre></div>
  <p>These will be replaced by a <code>true</code> or <code>false</code> at compile-time, depending on the configuration settings.</p>
  </section>
  </section>
  <section id="sec--documentation" class="level2">
  <h2>Documentation</h2>
  <p>Documentation is an important part of any software project, and it‚Äôs first-class in Rust. Let‚Äôs talk about the tooling Rust gives you to document your project.</p>
  <section id="about-rustdoc" class="level4">
  <h4>About <code>rustdoc</code></h4>
  <p>The Rust distribution includes a tool, <code>rustdoc</code>, that generates documentation. <code>rustdoc</code> is also used by Cargo through <code>cargo doc</code>.</p>
  <p>Documentation can be generated in two ways: from source code, and from standalone Markdown files.</p>
  </section>
  <section id="documenting-source-code" class="level4">
  <h4>Documenting source code</h4>
  <p>The primary way of documenting a Rust project is through annotating the source code. You can use documentation comments for this purpose:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Constructs a new `Rc&lt;T&gt;`.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> new(value: T) -&gt; Rc&lt;T&gt; {
      <span class="co">// implementation goes here</span>
  }</code></pre></div>
  <p>This code generates documentation that looks <a href="https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">like this</a>. I‚Äôve left the implementation out, with a regular comment in its place.</p>
  <p>The first thing to notice about this annotation is that it uses <code>///</code> instead of <code>//</code>. The triple slash indicates a documentation comment.</p>
  <p>Documentation comments are written in Markdown.</p>
  <p>Rust keeps track of these comments, and uses them when generating documentation. This is important when documenting things like enums:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// The `Option` type. See [the module level documentation](../) for more.</span>
  <span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="co">/// No value</span>
      <span class="cn">None</span>,
      <span class="co">/// Some value `T`</span>
      <span class="cn">Some</span>(T),
  }</code></pre></div>
  <p>The above works, but this does not:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// The `Option` type. See [the module level documentation](../) for more.</span>
  <span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">None</span>, <span class="co">/// No value</span>
      <span class="cn">Some</span>(T), <span class="co">/// Some value `T`</span>
  }</code></pre></div>
  <p>You‚Äôll get an error:</p>
  <pre class="text"><code>hello.rs:4:1: 4:2 error: expected ident, found `}`
  hello.rs:4 }
             ^</code></pre>
  <p>This <a href="https://github.com/rust-lang/rust/issues/22547">unfortunate error</a> is correct: documentation comments apply to the thing after them, and there‚Äôs nothing after that last comment.</p>
  <section id="writing-documentation-comments" class="level5">
  <h5>Writing documentation comments</h5>
  <p>Anyway, let‚Äôs cover each part of this comment in detail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Constructs a new `Rc&lt;T&gt;`.</span></code></pre></div>
  <p>The first line of a documentation comment should be a short summary of its functionality. One sentence. Just the basics. High level.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">///</span>
  <span class="co">/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated</span>
  <span class="co">/// semantics, maybe additional options, all kinds of stuff.</span>
  <span class="co">///</span></code></pre></div>
  <p>Our original example had just a summary line, but if we had more things to say, we could have added more explanation in a new paragraph.</p>
  <section id="special-sections" class="level6">
  <h6>Special sections</h6>
  <p>Next, are special sections. These are indicated with a header, <code>#</code>. There are four kinds of headers that are commonly used. They aren‚Äôt special syntax, just convention, for now.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Panics</span></code></pre></div>
  <p>Unrecoverable misuses of a function (i.e.¬†programming errors) in Rust are usually indicated by panics, which kill the whole current thread at the very least. If your function has a non-trivial contract like this, that is detected/enforced by panics, documenting it is very important.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Failures</span></code></pre></div>
  <p>If your function or method returns a <code>Result&lt;T, E&gt;</code>, then describing the conditions under which it returns <code>Err(E)</code> is a nice thing to do. This is slightly less important than <code>Panics</code>, because failure is encoded into the type system, but it‚Äôs still a good thing to do.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Safety</span></code></pre></div>
  <p>If your function is <code>unsafe</code>, you should explain which invariants the caller is responsible for upholding.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>Fourth, <code>Examples</code>. Include one or more examples of using your function or method, and your users will love you for it. These examples go inside of code block annotations, which we‚Äôll talk about in a moment, and can have more than one section:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// Simple `&amp;str` patterns:</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(' ').collect();</span>
  <span class="co">/// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);</span>
  <span class="co">/// ```</span>
  <span class="co">///</span>
  <span class="co">/// More complex patterns with a lambda:</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();</span>
  <span class="co">/// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>Let‚Äôs discuss the details of these code blocks.</p>
  </section>
  <section id="code-block-annotations" class="level6">
  <h6>Code block annotations</h6>
  <p>To write some Rust code in a comment, use the triple graves:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// println!(&quot;Hello, world&quot;);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>If you want something that‚Äôs not Rust code, you can add an annotation:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```c</span>
  <span class="co">/// printf(&quot;Hello, world\n&quot;);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>This will highlight according to whatever language you‚Äôre showing off. If you‚Äôre just showing plain text, choose <code>text</code>.</p>
  <p>It‚Äôs important to choose the correct annotation here, because <code>rustdoc</code> uses it in an interesting way: It can be used to actually test your examples in a library crate, so that they don‚Äôt get out of date. If you have some C code but <code>rustdoc</code> thinks it‚Äôs Rust because you left off the annotation, <code>rustdoc</code> will complain when trying to generate the documentation.</p>
  </section>
  </section>
  </section>
  <section id="documentation-as-tests" class="level4">
  <h4>Documentation as tests</h4>
  <p>Let‚Äôs discuss our sample example documentation:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// println!(&quot;Hello, world&quot;);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>You‚Äôll notice that you don‚Äôt need a <code>fn main()</code> or anything here. <code>rustdoc</code> will automatically add a main() wrapper around your code, and in the right place. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>This will end up testing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">use</span> std::rc::Rc;
      <span class="kw">let</span> five = Rc::new(<span class="dv">5</span>);
  }</code></pre></div>
  <p>Here‚Äôs the full algorithm rustdoc uses to postprocess examples:</p>
  <ol type="1">
  <li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.</li>
  <li>Some common <code>allow</code> attributes are inserted, including <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger these lints.</li>
  <li>If the example does not contain <code>extern crate</code>, then <code>extern crate    &lt;mycrate&gt;;</code> is inserted.</li>
  <li>Finally, if the example does not contain <code>fn main</code>, the remainder of the text is wrapped in <code>fn main() { your_code }</code></li>
  </ol>
  <p>Sometimes, this isn‚Äôt enough, though. For example, all of these code samples with <code>///</code> we‚Äôve been talking about? The raw text:</p>
  <pre class="text"><code>/// Some documentation.
  # fn foo() {}</code></pre>
  <p>looks different than the output:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Some documentation.</span></code></pre></div>
  <p>Yes, that‚Äôs right: you can add lines that start with <code>#</code>, and they will be hidden from the output, but will be used when compiling your code. You can use this to your advantage. In this case, documentation comments need to apply to some kind of function, so if I want to show you just a documentation comment, I need to add a little function definition below it. At the same time, it‚Äôs just there to satisfy the compiler, so hiding it makes the example more clear. You can use this technique to explain longer examples in detail, while still preserving the testability of your documentation. For example, this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = <span class="dv">6</span>;
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x + y);</code></pre></div>
  <p>Here‚Äôs an explanation, rendered:</p>
  <p>First, we set <code>x</code> to five:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;</code></pre></div>
  <p>Next, we set <code>y</code> to six:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y = <span class="dv">6</span>;</code></pre></div>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x + y);</code></pre></div>
  <p>Here‚Äôs the same explanation, in raw text:</p>
  <blockquote>
  <p>First, we set <code>x</code> to five:</p>
  <pre class="text"><code>let x = 5;
  # let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Next, we set <code>y</code> to six:</p>
  <pre class="text"><code># let x = 5;
  let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
  <pre class="text"><code># let x = 5;
  # let y = 6;
  println!(&quot;{}&quot;, x + y);</code></pre>
  </blockquote>
  <p>By repeating all parts of the example, you can ensure that your example still compiles, while only showing the parts that are relevant to that part of your explanation.</p>
  <section id="documenting-macros" class="level5">
  <h5>Documenting macros</h5>
  <p>Here‚Äôs an example of documenting a macro:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Panic with a given message unless an expression evaluates to true.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// # #[macro_use] extern crate foo;</span>
  <span class="co">/// # fn main() {</span>
  <span class="co">/// panic_unless!(1 + 1 == 2, ‚ÄúMath is broken.‚Äù);</span>
  <span class="co">/// # }</span>
  <span class="co">/// ```</span>
  <span class="co">///</span>
  <span class="co">/// ```should_panic</span>
  <span class="co">/// # #[macro_use] extern crate foo;</span>
  <span class="co">/// # fn main() {</span>
  <span class="co">/// panic_unless!(true == false, ‚ÄúI‚Äôm broken.‚Äù);</span>
  <span class="co">/// # }</span>
  <span class="co">/// ```</span>
  <span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> panic_unless {
      ($condition:expr, $($rest:expr),+) =&gt; ({ <span class="kw">if</span> ! $condition { <span class="pp">panic!</span>($($rest),+); } }
  ‚Ü≥ );
  }</code></pre></div>
  <p>You‚Äôll note three things: we need to add our own <code>extern crate</code> line, so that we can add the <code>#[macro_use]</code> attribute. Second, we‚Äôll need to add our own <code>main()</code> as well. Finally, a judicious use of <code>#</code> to comment out those two things, so they don‚Äôt show up in the output.</p>
  </section>
  <section id="running-documentation-tests" class="level5">
  <h5>Running documentation tests</h5>
  <p>To run the tests, either</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustdoc</span> --test path/to/my/crate/root.rs
  <span class="co"># or</span>
  $ <span class="kw">cargo</span> test</code></pre></div>
  <p>That‚Äôs right, <code>cargo test</code> tests embedded documentation too. <strong>However, <code>cargo test</code> will not test binary crates, only library ones.</strong> This is due to the way <code>rustdoc</code> works: it links against the library to be tested, but with a binary, there‚Äôs nothing to link to.</p>
  <p>There are a few more annotations that are useful to help <code>rustdoc</code> do the right thing when testing your code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```ignore</span>
  <span class="co">/// fn foo() {</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>The <code>ignore</code> directive tells Rust to ignore your code. This is almost never what you want, as it‚Äôs the most generic. Instead, consider annotating it with <code>text</code> if it‚Äôs not code, or using <code>#</code>s to get a working example that only shows the part you care about.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```should_panic</span>
  <span class="co">/// assert!(false);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly, but not actually pass as a test.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```no_run</span>
  <span class="co">/// loop {</span>
  <span class="co">///     println!(&quot;Hello, world&quot;);</span>
  <span class="co">/// }</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>The <code>no_run</code> attribute will compile your code, but not run it. This is important for examples such as ‚ÄúHere‚Äôs how to start up a network service,‚Äù which you would want to make sure compile, but might run in an infinite loop!</p>
  </section>
  <section id="documenting-modules" class="level5">
  <h5>Documenting modules</h5>
  <p>Rust has another kind of doc comment, <code>//!</code>. This comment doesn‚Äôt document the next item, but the enclosing item. In other words:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> foo {
      <span class="co">//! This is documentation for the `foo` module.</span>
      <span class="co">//!</span>
      <span class="co">//! # Examples</span>
  
      <span class="co">// ...</span>
  }</code></pre></div>
  <p>This is where you‚Äôll see <code>//!</code> used most often: for module documentation. If you have a module in <code>foo.rs</code>, you‚Äôll often open its code and see this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! A module for using `foo`s.</span>
  <span class="co">//!</span>
  <span class="co">//! The `foo` module contains a lot of useful functionality blah blah blah</span></code></pre></div>
  </section>
  <section id="documentation-comment-style" class="level5">
  <h5>Documentation comment style</h5>
  <p>Check out <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> for full conventions around the style and format of documentation.</p>
  </section>
  </section>
  <section id="other-documentation" class="level4">
  <h4>Other documentation</h4>
  <p>All of this behavior works in non-Rust source files too. Because comments are written in Markdown, they‚Äôre often <code>.md</code> files.</p>
  <p>When you write documentation in Markdown files, you don‚Äôt need to prefix the documentation with comments. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre></div>
  <p>is just</p>
  <div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu">### Examples</span>
  
  ```
  use std::rc::Rc;
  
  let five = Rc::new(5);
  ```</code></pre></div>
  <p>when it‚Äôs in a Markdown file. There is one wrinkle though: Markdown files need to have a title like this:</p>
  <div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown">% The title
  
  This is the example documentation.</code></pre></div>
  <p>This <code>%</code> line needs to be the very first line of the file.</p>
  </section>
  <section id="doc-attributes" class="level4">
  <h4><code>doc</code> attributes</h4>
  <p>At a deeper level, documentation comments are sugar for documentation attributes:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// this</span>
  
  <span class="at">#[</span>doc<span class="at">=</span><span class="st">&quot;this&quot;</span><span class="at">]</span></code></pre></div>
  <p>are the same, as are these:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! this</span>
  
  <span class="at">#![</span>doc<span class="at">=</span><span class="st">&quot;/// this&quot;</span><span class="at">]</span></code></pre></div>
  <p>You won‚Äôt often see this attribute used for writing documentation, but it can be useful when changing some options, or when writing a macro.</p>
  <section id="re-exports" class="level5">
  <h5>Re-exports</h5>
  <p><code>rustdoc</code> will show the documentation for a public re-export in both places:</p>
  <pre class="ignore"><code>extern crate foo;
  
  pub use foo::bar;</code></pre>
  <p>This will create documentation for bar both inside the documentation for the crate <code>foo</code>, as well as the documentation for your crate. It will use the same documentation in both places.</p>
  <p>This behavior can be suppressed with <code>no_inline</code>:</p>
  <pre class="ignore"><code>extern crate foo;
  
  #[doc(no_inline)]
  pub use foo::bar;</code></pre>
  </section>
  <section id="controlling-html" class="level5">
  <h5>Controlling HTML</h5>
  <p>You can control a few aspects of the HTML that <code>rustdoc</code> generates through the <code>#![doc]</code> version of the attribute:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>doc<span class="at">(</span>html_logo_url <span class="at">=</span> <span class="st">&quot;https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;</span><span class="at">,</span>
         html_favicon_url <span class="at">=</span> <span class="st">&quot;https://www.rust-lang.org/favicon.ico&quot;</span><span class="at">,</span>
         html_root_url <span class="at">=</span> <span class="st">&quot;https://doc.rust-lang.org/&quot;</span><span class="at">)]</span></code></pre></div>
  <p>This sets a few different options, with a logo, favicon, and a root URL.</p>
  </section>
  </section>
  <section id="generation-options" class="level4">
  <h4>Generation options</h4>
  <p><code>rustdoc</code> also contains a few other options on the command line, for further customization:</p>
  <ul>
  <li><code>--html-in-header FILE</code>: includes the contents of FILE at the end of the <code>&lt;head&gt;...&lt;/head&gt;</code> section.</li>
  <li><code>--html-before-content FILE</code>: includes the contents of FILE directly after <code>&lt;body&gt;</code>, before the rendered content (including the search bar).</li>
  <li><code>--html-after-content FILE</code>: includes the contents of FILE after all the rendered content.</li>
  </ul>
  </section>
  <section id="security-note" class="level4">
  <h4>Security note</h4>
  <p>The Markdown in documentation comments is placed without processing into the final webpage. Be careful with literal HTML:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;</span></code></pre></div>
  </section>
  </section>
  <section id="sec--iterators" class="level2">
  <h2>Iterators</h2>
  <p>Let‚Äôs talk about loops.</p>
  <p>Remember Rust‚Äôs <code>for</code> loop? Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>Now that you know more Rust, we can talk in detail about how this works. Ranges (the <code>0..10</code>) are ‚Äòiterators‚Äô. An iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</p>
  <p>Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> range = <span class="dv">0.</span>.<span class="dv">10</span>;
  
  <span class="kw">loop</span> {
      <span class="kw">match</span> range.next() {
          <span class="cn">Some</span>(x) =&gt; {
              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
          },
          <span class="cn">None</span> =&gt; { <span class="kw">break</span> }
      }
  }</code></pre></div>
  <p>We make a mutable binding to the range, which is our iterator. We then <code>loop</code>, with an inner <code>match</code>. This <code>match</code> is used on the result of <code>range.next()</code>, which gives us a reference to the next value of the iterator. <code>next</code> returns an <code>Option&lt;i32&gt;</code>, in this case, which will be <code>Some(i32)</code> when we have a value and <code>None</code> once we run out. If we get <code>Some(i32)</code>, we print it out, and if we get <code>None</code>, we <code>break</code> out of the loop.</p>
  <p>This code sample is basically the same as our <code>for</code> loop version. The <code>for</code> loop is just a handy way to write this <code>loop</code>/<code>match</code>/<code>break</code> construct.</p>
  <p><code>for</code> loops aren‚Äôt the only thing that uses iterators, however. Writing your own iterator involves implementing the <code>Iterator</code> trait. While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks. Before we talk about those, we should talk about a Rust anti-pattern. And that‚Äôs using ranges like this.</p>
  <p>Yes, we just talked about how ranges are cool. But ranges are also very primitive. For example, if you needed to iterate over the contents of a vector, you may be tempted to write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0.</span>.nums.len() {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, nums[i]);
  }</code></pre></div>
  <p>This is strictly worse than using an actual iterator. You can iterate over vectors directly, so write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> &amp;nums {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre></div>
  <p>There are two reasons for this. First, this more directly expresses what we mean. We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector. Second, this version is more efficient: the first version will have extra bounds checking because it used indexing, <code>nums[i]</code>. But since we yield a reference to each element of the vector in turn with the iterator, there‚Äôs no bounds checking in the second example. This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we‚Äôre safe.</p>
  <p>There‚Äôs another detail here that‚Äôs not 100% clear because of how <code>println!</code> works. <code>num</code> is actually of type <code>&amp;i32</code>. That is, it‚Äôs a reference to an <code>i32</code>, not an <code>i32</code> itself. <code>println!</code> handles the dereferencing for us, so we don‚Äôt see it. This code works fine too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> &amp;nums {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, *num);
  }</code></pre></div>
  <p>Now we‚Äôre explicitly dereferencing <code>num</code>. Why does <code>&amp;nums</code> give us references? Firstly, because we explicitly asked it to with <code>&amp;</code>. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we‚Äôre just borrowing a reference to the data, and so it‚Äôs just passing a reference, without needing to do the move.</p>
  <p>So, now that we‚Äôve established that ranges are often not what you want, let‚Äôs talk about what you do want instead.</p>
  <p>There are three broad classes of things that are relevant here: iterators, <em>iterator adapters</em>, and <em>consumers</em>. Here‚Äôs some definitions:</p>
  <ul>
  <li><em>iterators</em> give you a sequence of values.</li>
  <li><em>iterator adapters</em> operate on an iterator, producing a new iterator with a different output sequence.</li>
  <li><em>consumers</em> operate on an iterator, producing some final set of values.</li>
  </ul>
  <p>Let‚Äôs talk about consumers first, since you‚Äôve already seen an iterator, ranges.</p>
  <section id="consumers" class="level4">
  <h4>Consumers</h4>
  <p>A <em>consumer</em> operates on an iterator, returning some kind of value or values. The most common consumer is <code>collect()</code>. This code doesn‚Äôt quite compile, but it shows the intention:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect();</code></pre></div>
  <p>As you can see, we call <code>collect()</code> on our iterator. <code>collect()</code> takes as many values as the iterator will give it, and returns a collection of the results. So why won‚Äôt this compile? Rust can‚Äôt determine what type of things you want to collect, and so you need to let it know. Here‚Äôs the version that does compile:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>If you remember, the <code>::&lt;&gt;</code> syntax allows us to give a type hint, and so we tell it that we want a vector of integers. You don‚Äôt always need to use the whole type, though. Using a <code>_</code> will let you provide a partial hint:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;<span class="dt">Vec</span>&lt;_&gt;&gt;();</code></pre></div>
  <p>This says ‚ÄúCollect into a <code>Vec&lt;T&gt;</code>, please, but infer what the <code>T</code> is for me.‚Äù <code>_</code> is sometimes called a ‚Äútype placeholder‚Äù for this reason.</p>
  <p><code>collect()</code> is the most common consumer, but there are others too. <code>find()</code> is one:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> greater_than_forty_two = (<span class="dv">0.</span>.<span class="dv">100</span>)
                               .find(|x| *x &gt; <span class="dv">42</span>);
  
  <span class="kw">match</span> greater_than_forty_two {
      <span class="cn">Some</span>(_) =&gt; <span class="pp">println!</span>(<span class="st">&quot;We got some numbers!&quot;</span>),
      <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;No numbers found :(&quot;</span>),
  }</code></pre></div>
  <p><code>find</code> takes a closure, and works on a reference to each element of an iterator. This closure returns <code>true</code> if the element is the element we‚Äôre looking for, and <code>false</code> otherwise. Because we might not find a matching element, <code>find</code> returns an <code>Option</code> rather than the element itself.</p>
  <p>Another important consumer is <code>fold</code>. Here‚Äôs what it looks like:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> sum = (<span class="dv">1.</span>.<span class="dv">4</span>).fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre></div>
  <p><code>fold()</code> is a consumer that looks like this: <code>fold(base, |accumulator, element| ...)</code>. It takes two arguments: the first is an element called the <em>base</em>. The second is a closure that itself takes two arguments: the first is called the <em>accumulator</em>, and the second is an <em>element</em>. Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration. On the first iteration, the base is the value of the accumulator.</p>
  <p>Okay, that‚Äôs a bit confusing. Let‚Äôs examine the values of all of these things in this iterator:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">base</th>
  <th style="text-align: left;">accumulator</th>
  <th style="text-align: left;">element</th>
  <th style="text-align: left;">closure result</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">3</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">6</td>
  </tr>
  </tbody>
  </table>
  <p>We called <code>fold()</code> with these arguments:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">.fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre></div>
  <p>So, <code>0</code> is our base, <code>sum</code> is our accumulator, and <code>x</code> is our element. On the first iteration, we set <code>sum</code> to <code>0</code>, and <code>x</code> is the first element of <code>nums</code>, <code>1</code>. We then add <code>sum</code> and <code>x</code>, which gives us <code>0 + 1 = 1</code>. On the second iteration, that value becomes our accumulator, <code>sum</code>, and the element is the second element of the array, <code>2</code>. <code>1 + 2 = 3</code>, and so that becomes the value of the accumulator for the last iteration. On that iteration, <code>x</code> is the last element, <code>3</code>, and <code>3 + 3 = 6</code>, which is our final result for our sum. <code>1 + 2 + 3 = 6</code>, and that‚Äôs the result we got.</p>
  <p>Whew. <code>fold</code> can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place. Any time you have a list of things, and you want a single result, <code>fold</code> is appropriate.</p>
  <p>Consumers are important due to one additional property of iterators we haven‚Äôt talked about yet: laziness. Let‚Äôs talk some more about iterators, and you‚Äôll see why consumers matter.</p>
  </section>
  <section id="iterators" class="level4">
  <h4>Iterators</h4>
  <p>As we‚Äôve said before, an iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things. Because you need to call the method, this means that iterators can be <em>lazy</em> and not generate all of the values upfront. This code, for example, does not actually generate the numbers <code>1-99</code>, instead creating a value that merely represents the sequence:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="dv">1.</span>.<span class="dv">100</span>;</code></pre></div>
  <p>Since we didn‚Äôt do anything with the range, it didn‚Äôt generate the sequence. Let‚Äôs add the consumer:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = (<span class="dv">1.</span>.<span class="dv">100</span>).collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>Now, <code>collect()</code> will require that the range gives it some numbers, and so it will do the work of generating the sequence.</p>
  <p>Ranges are one of two basic iterators that you‚Äôll see. The other is <code>iter()</code>. <code>iter()</code> can turn a vector into a simple iterator that gives you each element in turn:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num <span class="kw">in</span> nums.iter() {
     <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre></div>
  <p>These two basic iterators should serve you well. There are some more advanced iterators, including ones that are infinite.</p>
  <p>That‚Äôs enough about iterators. Iterator adapters are the last concept we need to talk about with regards to iterators. Let‚Äôs get to it!</p>
  </section>
  <section id="iterator-adapters" class="level4">
  <h4>Iterator adapters</h4>
  <p><em>Iterator adapters</em> take an iterator and modify it somehow, producing a new iterator. The simplest one is called <code>map</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| x + <span class="dv">1</span>);</code></pre></div>
  <p><code>map</code> is called upon another iterator, and produces a new iterator where each element reference has the closure it‚Äôs been given as an argument called on it. So this would give us the numbers from <code>2-100</code>. Well, almost! If you compile the example, you‚Äôll get a warning:</p>
  <pre class="text"><code>warning: unused result which must be used: iterator adaptors are lazy and
           do nothing unless consumed, #[warn(unused_must_use)] on by default
  (1..100).map(|x| x + 1);
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Laziness strikes again! That closure will never execute. This example doesn‚Äôt print any numbers:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x));</code></pre></div>
  <p>If you are trying to execute a closure on an iterator for its side effects, just use <code>for</code> instead.</p>
  <p>There are tons of interesting iterator adapters. <code>take(n)</code> will return an iterator over the next <code>n</code> elements of the original iterator. Note that this has no side effect on the original iterator. Let‚Äôs try it out with our infinite iterator from before:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">1.</span>.).take(<span class="dv">5</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This will print</p>
  <pre class="text"><code>1
  2
  3
  4
  5</code></pre>
  <p><code>filter()</code> is an adapter that takes a closure as an argument. This closure returns <code>true</code> or <code>false</code>. The new iterator <code>filter()</code> produces only the elements that that closure returns <code>true</code> for:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">1.</span>.<span class="dv">100</span>).filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This will print all of the even numbers between one and a hundred. (Note that because <code>filter</code> doesn‚Äôt consume the elements that are being iterated over, it is passed a reference to each element, and thus the filter predicate uses the <code>&amp;x</code> pattern to extract the integer itself.)</p>
  <p>You can chain all three things together: start with an iterator, adapt it a few times, and then consume the result. Check it out:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.)
      .filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>)
      .filter(|&amp;x| x % <span class="dv">3</span> == <span class="dv">0</span>)
      .take(<span class="dv">5</span>)
      .collect::&lt;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;&gt;();</code></pre></div>
  <p>This will give you a vector containing <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, and <code>30</code>.</p>
  <p>This is just a small taste of what iterators, iterator adapters, and consumers can help you with. There are a number of really useful iterators, and you can write your own as well. Iterators provide a safe, efficient way to manipulate all kinds of lists. They‚Äôre a little unusual at first, but if you play with them, you‚Äôll get hooked. For a full list of the different iterators and consumers, check out the <a href="http://doc.rust-lang.org/std/iter/index.html">iterator module documentation</a>.</p>
  </section>
  </section>
  <section id="sec--concurrency" class="level2">
  <h2>Concurrency</h2>
  <p>Concurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today. Computers are gaining more and more cores, yet many programmers aren‚Äôt prepared to fully utilize them.</p>
  <p>Rust‚Äôs memory safety features also apply to its concurrency story too. Even concurrent Rust programs must be memory safe, having no data races. Rust‚Äôs type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.</p>
  <p>Before we talk about the concurrency features that come with Rust, it‚Äôs important to understand something: Rust is low-level enough that the vast majority of this is provided by the standard library, not by the language. This means that if you don‚Äôt like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things. <a href="https://github.com/carllerche/mio">mio</a> is a real-world example of this principle in action.</p>
  <section id="background-send-and-sync" class="level4">
  <h4>Background: <code>Send</code> and <code>Sync</code></h4>
  <p>Concurrency is difficult to reason about. In Rust, we have a strong, static type system to help us reason about our code. As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.</p>
  <section id="send" class="level5">
  <h5><code>Send</code></h5>
  <p>The first trait we‚Äôre going to talk about is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. When a type <code>T</code> implements <code>Send</code>, it indicates that something of this type is able to have ownership transferred safely between threads.</p>
  <p>This is important to enforce certain restrictions. For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread. Therefore, we‚Äôd ensure that <code>Send</code> was implemented for that type.</p>
  <p>In the opposite way, if we were wrapping a library with FFI that isn‚Äôt threadsafe, we wouldn‚Äôt want to implement <code>Send</code>, and so the compiler will help us enforce that it can‚Äôt leave the current thread.</p>
  </section>
  <section id="sync" class="level5">
  <h5><code>Sync</code></h5>
  <p>The second of these traits is called <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. When a type <code>T</code> implements <code>Sync</code>, it indicates that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references. This implies that types which don‚Äôt have <a href="#sec--mutability">interior mutability</a> are inherently <code>Sync</code>, which includes simple primitive types (like <code>u8</code>) and aggregate types containing them.</p>
  <p>For sharing references across threads, Rust provides a wrapper type called <code>Arc&lt;T&gt;</code>. <code>Arc&lt;T&gt;</code> implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements both <code>Send</code> and <code>Sync</code>. For example, an object of type <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> cannot be transferred across threads because <a href="choosing-your-guarantees.html#refcell%3Ct%3E"><code>RefCell</code></a> does not implement <code>Sync</code>, consequently <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> would not implement <code>Send</code>.</p>
  <p>These two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency. Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!</p>
  </section>
  </section>
  <section id="threads" class="level4">
  <h4>Threads</h4>
  <p>Rust‚Äôs standard library provides a library for threads, which allow you to run Rust code in parallel. Here‚Äôs a basic example of using <code>std::thread</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      thread::spawn(|| {
          <span class="pp">println!</span>(<span class="st">&quot;Hello from a thread!&quot;</span>);
      });
  }</code></pre></div>
  <p>The <code>thread::spawn()</code> method accepts a <a href="#sec--closures">closure</a>, which is executed in a new thread. It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> handle = thread::spawn(|| {
          <span class="st">&quot;Hello from a thread!&quot;</span>
      });
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, handle.join().unwrap());
  }</code></pre></div>
  <p>Many languages have the ability to execute threads, but it‚Äôs wildly unsafe. There are entire books about how to prevent errors that occur from shared mutable state. Rust helps out with its type system here as well, by preventing data races at compile time. Let‚Äôs talk about how you actually share things between threads.</p>
  </section>
  <section id="safe-shared-mutable-state" class="level4">
  <h4>Safe Shared Mutable State</h4>
  <p>Due to Rust‚Äôs type system, we have a concept that sounds like a lie: ‚Äúsafe shared mutable state.‚Äù Many programmers agree that shared mutable state is very, very bad.</p>
  <p>Someone once said this:</p>
  <blockquote>
  <p>Shared mutable state is the root of all evil. Most languages attempt to deal with this problem through the ‚Äòmutable‚Äô part, but Rust deals with it by solving the ‚Äòshared‚Äô part.</p>
  </blockquote>
  <p>The same <a href="#sec--ownership">ownership system</a> that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.</p>
  <p>As an example, here is a Rust program that would have a data race in many languages. It will not compile:</p>
  <pre class="ignore"><code>use std::thread;
  
  fn main() {
      let mut data = vec![1, 2, 3];
  
      for i in 0..3 {
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>This gives us an error:</p>
  <pre class="text"><code>8:17 error: capture of moved value: `data`
          data[i] += 1;
          ^~~~</code></pre>
  <p>Rust knows this wouldn‚Äôt be safe! If we had a reference to <code>data</code> in each thread, and the thread takes ownership of the reference, we‚Äôd have three owners!</p>
  <p>So, we need some type that lets us have more than one reference to a value and that we can share between threads, that is it must implement <code>Sync</code>.</p>
  <p>We‚Äôll use <code>Arc&lt;T&gt;</code>, rust‚Äôs standard atomic reference count type, which wraps a value up with some extra runtime bookkeeping which allows us to share the ownership of the value between multiple references at the same time.</p>
  <p>The bookkeeping consists of a count of how many of these references exist to the value, hence the reference count part of the name.</p>
  <p>The Atomic part means <code>Arc&lt;T&gt;</code> can safely be accessed from multiple threads. To do this the compiler guarantees that mutations of the internal count use indivisible operations which can‚Äôt have data races.</p>
  <pre class="ignore"><code>use std::thread;
  use std::sync::Arc;
  
  fn main() {
      let mut data = Arc::new(vec![1, 2, 3]);
  
      for i in 0..3 {
          let data = data.clone();
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>We now call <code>clone()</code> on our <code>Arc&lt;T&gt;</code>, which increases the internal count. This handle is then moved into the new thread.</p>
  <p>And‚Ä¶ still gives us an error.</p>
  <pre class="text"><code>&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable
  &lt;anon&gt;:11                    data[i] += 1;
                               ^~~~</code></pre>
  <p><code>Arc&lt;T&gt;</code> assumes one more property about its contents to ensure that it is safe to share across threads: it assumes its contents are <code>Sync</code>. This is true for our value if it‚Äôs immutable, but we want to be able to mutate it, so we need something else to persuade the borrow checker we know what we‚Äôre doing.</p>
  <p>It looks like we need some type that allows us to safely mutate a shared value, for example a type that that can ensure only one thread at a time is able to mutate the value inside it at any one time.</p>
  <p>For that, we can use the <code>Mutex&lt;T&gt;</code> type!</p>
  <p>Here‚Äôs the working version:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Arc, Mutex};
  <span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> data = Arc::new(Mutex::new(<span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]));
  
      <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">3</span> {
          <span class="kw">let</span> data = data.clone();
          thread::spawn(<span class="kw">move</span> || {
              <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
              data[i] += <span class="dv">1</span>;
          });
      }
  
      thread::sleep_ms(<span class="dv">50</span>);
  }</code></pre></div>
  <p>Note that the value of <code>i</code> is bound (copied) to the closure and not shared among the threads.</p>
  <p>Also note that <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a> method of <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> has this signature:</p>
  <pre class="ignore"><code>fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;</code></pre>
  <p>and because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code>, the guard cannot cross thread boundaries, ensuring thread-locality of lock acquire and release.</p>
  <p>Let‚Äôs examine the body of the thread more closely:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">thread::spawn(<span class="kw">move</span> || {
      <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
      data[i] += <span class="dv">1</span>;
  });</code></pre></div>
  <p>First, we call <code>lock()</code>, which acquires the mutex‚Äôs lock. Because this may fail, it returns an <code>Result&lt;T, E&gt;</code>, and because this is just an example, we <code>unwrap()</code> it to get a reference to the data. Real code would have more robust error handling here. We‚Äôre then free to mutate it, since we have the lock.</p>
  <p>Lastly, while the threads are running, we wait on a short timer. But this is not ideal: we may have picked a reasonable amount of time to wait but it‚Äôs more likely we‚Äôll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.</p>
  <p>A more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other. Let‚Äôs talk about one of them: channels.</p>
  </section>
  <section id="channels" class="level4">
  <h4>Channels</h4>
  <p>Here‚Äôs a version of our code that uses channels for synchronization, rather than waiting for a specific time:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Arc, Mutex};
  <span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::mpsc;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> data = Arc::new(Mutex::new(<span class="dv">0</span>));
  
      <span class="kw">let</span> (tx, rx) = mpsc::channel();
  
      <span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">let</span> (data, tx) = (data.clone(), tx.clone());
  
          thread::spawn(<span class="kw">move</span> || {
              <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
              *data += <span class="dv">1</span>;
  
              tx.send(());
          });
      }
  
      <span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
          rx.recv();
      }
  }</code></pre></div>
  <p>We use the <code>mpsc::channel()</code> method to construct a new channel. We just <code>send</code> a simple <code>()</code> down the channel, and then wait for ten of them to come back.</p>
  <p>While this channel is just sending a generic signal, we can send any data that is <code>Send</code> over the channel!</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::mpsc;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> (tx, rx) = mpsc::channel();
  
      <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">let</span> tx = tx.clone();
  
          thread::spawn(<span class="kw">move</span> || {
              <span class="kw">let</span> answer = i * i;
  
              tx.send(answer);
          });
      }
  
      <span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, rx.recv().unwrap());
      }
  }</code></pre></div>
  <p>Here we create 10 threads, asking each to calculate the square of a number (<code>i</code> at the time of <code>spawn()</code>), and then <code>send()</code> back the answer over the channel.</p>
  </section>
  <section id="panics" class="level4">
  <h4>Panics</h4>
  <p>A <code>panic!</code> will crash the currently executing thread. You can use Rust‚Äôs threads as a simple isolation mechanism:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">let</span> handle = thread::spawn(<span class="kw">move</span> || {
      <span class="pp">panic!</span>(<span class="st">&quot;oops!&quot;</span>);
  });
  
  <span class="kw">let</span> result = handle.join();
  
  <span class="pp">assert!</span>(result.is_err());</code></pre></div>
  <p><code>Thread.join()</code> gives us a <code>Result</code> back, which allows us to check if the thread has panicked or not.</p>
  </section>
  </section>
  <section id="sec--error-handling" class="level2">
  <h2>Error Handling</h2>
  <p>Like most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.</p>
  <p>In this chapter, we intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, we will attempt to introduce error handling one piece at a time so that you‚Äôll come away with a solid working knowledge of how everything fits together.</p>
  <p>When done na√Øvely, error handling in Rust can be verbose and annoying. This chapter will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.</p>
  <section id="table-of-contents" class="level3">
  <h3>Table of Contents</h3>
  <p>This chapter is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may want to jump around.</p>
  <ul>
  <li><a href="#the-basics">The Basics</a>
  <ul>
  <li><a href="#unwrapping-explained">Unwrapping explained</a></li>
  <li><a href="#the-option-type">The <code>Option</code> type</a>
  <ul>
  <li><a href="#composing-optiont-values">Composing <code>Option&lt;T&gt;</code> values</a></li>
  </ul></li>
  <li><a href="#the-result-type">The <code>Result</code> type</a>
  <ul>
  <li><a href="#parsing-integers">Parsing integers</a></li>
  <li><a href="#the-result-type-alias-idiom">The <code>Result</code> type alias idiom</a></li>
  </ul></li>
  <li><a href="#a-brief-interlude-unwrapping-isnt-evil">A brief interlude: unwrapping isn‚Äôt evil</a></li>
  </ul></li>
  <li><a href="#working-with-multiple-error-types">Working with multiple error types</a>
  <ul>
  <li><a href="#composing-option-and-result">Composing <code>Option</code> and <code>Result</code></a></li>
  <li><a href="#the-limits-of-combinators">The limits of combinators</a></li>
  <li><a href="#early-returns">Early returns</a></li>
  <li><a href="#the-try-macro">The <code>try!</code> macro</a></li>
  <li><a href="#defining-your-own-error-type">Defining your own error type</a></li>
  </ul></li>
  <li><a href="#standard-library-traits-used-for-error-handling">Standard library traits used for error handling</a>
  <ul>
  <li><a href="#the-error-trait">The <code>Error</code> trait</a></li>
  <li><a href="#the-from-trait">The <code>From</code> trait</a></li>
  <li><a href="#the-real-try-macro">The real <code>try!</code> macro</a></li>
  <li><a href="#composing-custom-error-types">Composing custom error types</a></li>
  <li><a href="#advice-for-library-writers">Advice for library writers</a></li>
  </ul></li>
  <li><a href="#case-study-a-program-to-read-population-data">Case study: A program to read population data</a>
  <ul>
  <li><a href="#initial-setup">Initial setup</a></li>
  <li><a href="#argument-parsing">Argument parsing</a></li>
  <li><a href="#writing-the-logic">Writing the logic</a></li>
  <li><a href="#error-handling-with-boxerror">Error handling with <code>Box&lt;Error&gt;</code></a></li>
  <li><a href="#reading-from-stdin">Reading from stdin</a></li>
  <li><a href="#error-handling-with-a-custom-type">Error handling with a custom type</a></li>
  <li><a href="#adding-functionality">Adding functionality</a></li>
  </ul></li>
  <li><a href="#the-short-story">The short story</a></li>
  </ul>
  </section>
  <section id="the-basics" class="level3">
  <h3>The Basics</h3>
  <p>You can think of error handling as using <em>case analysis</em> to determine whether a computation was successful or not. As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.</p>
  <p>Keeping code composable is important, because without that requirement, we could <a href="http://doc.rust-lang.org/std/macro.panic!.html"><code>panic</code></a> whenever we come across something unexpected. (<code>panic</code> causes the current task to unwind, and in most cases, the entire program aborts.) Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Guess a number between 1 and 10.</span>
  <span class="co">// If it matches the number we had in mind, return true. Else, return false.</span>
  <span class="kw">fn</span> guess(n: <span class="dt">i32</span>) -&gt; <span class="dt">bool</span> {
      <span class="kw">if</span> n &lt; <span class="dv">1</span> || n &gt; <span class="dv">10</span> {
          <span class="pp">panic!</span>(<span class="st">&quot;Invalid number: {}&quot;</span>, n);
      }
      n == <span class="dv">5</span>
  }
  
  <span class="kw">fn</span> main() {
      guess(<span class="dv">11</span>);
  }</code></pre></div>
  <p>If you try running this code, the program will crash with a message like this:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5</code></pre>
  <p>Here‚Äôs another example that is slightly less contrived. A program that accepts an integer as an argument, doubles it and prints it.</p>
  <p><span id="code-unwrap-double"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> argv = env::args();
      <span class="kw">let</span> arg: <span class="dt">String</span> = argv.nth(<span class="dv">1</span>).unwrap(); <span class="co">// error 1</span>
      <span class="kw">let</span> n: <span class="dt">i32</span> = arg.parse().unwrap(); <span class="co">// error 2</span>
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="dv">2</span> * n);
  }</code></pre></div>
  <p>If you give this program zero arguments (error 1) or if the first argument isn‚Äôt an integer (error 2), the program will panic just like in the first example.</p>
  <p>You can think of this style of error handling as similar to a bull running through a china shop. The bull will get to where it wants to go, but it will trample everything in the process.</p>
  <section id="unwrapping-explained" class="level4">
  <h4>Unwrapping explained</h4>
  <p>In the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to <code>panic</code> like the first example. This is because the panic is embedded in the calls to <code>unwrap</code>.</p>
  <p>To ‚Äúunwrap‚Äù something in Rust is to say, ‚ÄúGive me the result of the computation, and if there was an error, just panic and stop the program.‚Äù It would be better if we just showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code> types. Both of these types have a method called <code>unwrap</code> defined on them.</p>
  <section id="the-option-type" class="level5">
  <h5>The <code>Option</code> type</h5>
  <p>The <code>Option</code> type is <a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard library</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">None</span>,
      <span class="cn">Some</span>(T),
  }</code></pre></div>
  <p>The <code>Option</code> type is a way to use Rust‚Äôs type system to express the <em>possibility of absence</em>. Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence. Let‚Äôs take a look at an example that tries to find a character in a string:</p>
  <p><span id="code-option-ex-string-find"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Searches `haystack` for the Unicode character `needle`. If one is found, the</span>
  <span class="co">// byte offset of the character is returned. Otherwise, `None` is returned.</span>
  <span class="kw">fn</span> find(haystack: &amp;<span class="dt">str</span>, needle: <span class="dt">char</span>) -&gt; <span class="dt">Option</span>&lt;<span class="dt">usize</span>&gt; {
      <span class="kw">for</span> (offset, c) <span class="kw">in</span> haystack.char_indices() {
          <span class="kw">if</span> c == needle {
              <span class="kw">return</span> <span class="cn">Some</span>(offset);
          }
      }
      <span class="cn">None</span>
  }</code></pre></div>
  <p>Notice that when this function finds a matching character, it doesn‚Äôt just return the <code>offset</code>. Instead, it returns <code>Some(offset)</code>. <code>Some</code> is a variant or a <em>value constructor</em> for the <code>Option</code> type. You can think of it as a function with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>. Correspondingly, <code>None</code> is also a value constructor, except it has no arguments. You can think of <code>None</code> as a function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
  <p>This might seem like much ado about nothing, but this is only half of the story. The other half is <em>using</em> the <code>find</code> function we‚Äôve written. Let‚Äôs try to use it to find the extension in a file name.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> file_name = <span class="st">&quot;foobar.rs&quot;</span>;
      <span class="kw">match</span> find(file_name, <span class="ch">'.'</span>) {
          <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;No file extension found.&quot;</span>),
          <span class="cn">Some</span>(i) =&gt; <span class="pp">println!</span>(<span class="st">&quot;File extension: {}&quot;</span>, &amp;file_name[i+<span class="dv">1.</span>.]),
      }
  }</code></pre></div>
  <p>This code uses <a href="http://doc.rust-lang.org/book/patterns.html">pattern matching</a> to do <em>case analysis</em> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function. In fact, case analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code>. This means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is <code>None</code> instead of <code>Some(t)</code>.</p>
  <p>But wait, what about <code>unwrap</code> used in <a href="#code-unwrap-double"><code>unwrap-double</code></a>? There was no case analysis there! Instead, the case analysis was put inside the <code>unwrap</code> method for you. You could define it yourself if you want:</p>
  <p><span id="code-option-def-unwrap"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">None</span>,
      <span class="cn">Some</span>(T),
  }
  
  <span class="kw">impl</span>&lt;T&gt; <span class="dt">Option</span>&lt;T&gt; {
      <span class="kw">fn</span> unwrap(<span class="kw">self</span>) -&gt; T {
          <span class="kw">match</span> <span class="kw">self</span> {
              <span class="dt">Option</span>::<span class="cn">Some</span>(val) =&gt; val,
              <span class="dt">Option</span>::<span class="cn">None</span> =&gt;
                <span class="pp">panic!</span>(<span class="st">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),
          }
      }
  }</code></pre></div>
  <p>The <code>unwrap</code> method <em>abstracts away the case analysis</em>. This is precisely the thing that makes <code>unwrap</code> ergonomic to use. Unfortunately, that <code>panic!</code> means that <code>unwrap</code> is not composable: it is the bull in the china shop.</p>
  </section>
  <section id="composing-optiont-values" class="level5">
  <h5>Composing <code>Option&lt;T&gt;</code> values</h5>
  <p>In <a href="#code-option-ex-string-find"><code>option-ex-string-find</code></a> we saw how to use <code>find</code> to discover the extension in a file name. Of course, not all file names have a <code>.</code> in them, so it‚Äôs possible that the file name has no extension. This <em>possibility of absence</em> is encoded into the types using <code>Option&lt;T&gt;</code>. In other words, the compiler will force us to address the possibility that an extension does not exist. In our case, we just print out a message saying as such.</p>
  <p>Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Returns the extension of the given file name, where the extension is defined</span>
  <span class="co">// as all characters proceding the first `.`.</span>
  <span class="co">// If `file_name` has no `.`, then `None` is returned.</span>
  <span class="kw">fn</span> extension_explicit(file_name: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; {
      <span class="kw">match</span> find(file_name, <span class="ch">'.'</span>) {
          <span class="cn">None</span> =&gt; <span class="cn">None</span>,
          <span class="cn">Some</span>(i) =&gt; <span class="cn">Some</span>(&amp;file_name[i+<span class="dv">1.</span>.]),
      }
  }</code></pre></div>
  <p>(Pro-tip: don‚Äôt use this code. Use the <a href="http://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a> method in the standard library instead.)</p>
  <p>The code stays simple, but the important thing to notice is that the type of <code>find</code> forces us to consider the possibility of absence. This is a good thing because it means the compiler won‚Äôt let us accidentally forget about the case where a file name doesn‚Äôt have an extension. On the other hand, doing explicit case analysis like we‚Äôve done in <code>extension_explicit</code> every time can get a bit tiresome.</p>
  <p>In fact, the case analysis in <code>extension_explicit</code> follows a very common pattern: <em>map</em> a function on to the value inside of an <code>Option&lt;T&gt;</code>, unless the option is <code>None</code>, in which case, just return <code>None</code>.</p>
  <p>Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:</p>
  <p><span id="code-option-map"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> map&lt;F, T, A&gt;(option: <span class="dt">Option</span>&lt;T&gt;, f: F) -&gt; <span class="dt">Option</span>&lt;A&gt; <span class="kw">where</span> F: <span class="bu">FnOnce</span>(T) -&gt; A {
      <span class="kw">match</span> option {
          <span class="cn">None</span> =&gt; <span class="cn">None</span>,
          <span class="cn">Some</span>(value) =&gt; <span class="cn">Some</span>(f(value)),
      }
  }</code></pre></div>
  <p>Indeed, <code>map</code> is <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library.</p>
  <p>Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method to get rid of the case analysis:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Returns the extension of the given file name, where the extension is defined</span>
  <span class="co">// as all characters proceding the first `.`.</span>
  <span class="co">// If `file_name` has no `.`, then `None` is returned.</span>
  <span class="kw">fn</span> extension(file_name: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; {
      find(file_name, <span class="ch">'.'</span>).map(|i| &amp;file_name[i+<span class="dv">1.</span>.])
  }</code></pre></div>
  <p>One other pattern that we find is very common is assigning a default value to the case when an <code>Option</code> value is <code>None</code>. For example, maybe your program assumes that the extension of a file is <code>rs</code> even if none is present. As you might imagine, the case analysis for this is not specific to file extensions - it can work with any <code>Option&lt;T&gt;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> unwrap_or&lt;T&gt;(option: <span class="dt">Option</span>&lt;T&gt;, default: T) -&gt; T {
      <span class="kw">match</span> option {
          <span class="cn">None</span> =&gt; default,
          <span class="cn">Some</span>(value) =&gt; value,
      }
  }</code></pre></div>
  <p>The trick here is that the default value must have the same type as the value that might be inside the <code>Option&lt;T&gt;</code>. Using it is dead simple in our case:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(extension(<span class="st">&quot;foobar.csv&quot;</span>).unwrap_or(<span class="st">&quot;rs&quot;</span>), <span class="st">&quot;csv&quot;</span>);
      <span class="pp">assert_eq!</span>(extension(<span class="st">&quot;foobar&quot;</span>).unwrap_or(<span class="st">&quot;rs&quot;</span>), <span class="st">&quot;rs&quot;</span>);
  }</code></pre></div>
  <p>(Note that <code>unwrap_or</code> is <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library, so we use that here instead of the free-standing function we defined above. Don‚Äôt forget to check out the more general <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a> method.)</p>
  <p>There is one more combinator that we think is worth paying special attention to: <code>and_then</code>. It makes it easy to compose distinct computations that admit the <em>possibility of absence</em>. For example, much of the code in this section is about finding an extension given a file name. In order to do this, you first need the file name which is typically extracted from a file <em>path</em>. While most file paths have a file name, not <em>all</em> of them do. For example, <code>.</code>, <code>..</code> or <code>/</code>.</p>
  <p>So, we are tasked with the challenge of finding an extension given a file <em>path</em>. Let‚Äôs start with explicit case analysis:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> file_path_ext_explicit(file_path: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; {
      <span class="kw">match</span> file_name(file_path) {
          <span class="cn">None</span> =&gt; <span class="cn">None</span>,
          <span class="cn">Some</span>(name) =&gt; <span class="kw">match</span> extension(name) {
              <span class="cn">None</span> =&gt; <span class="cn">None</span>,
              <span class="cn">Some</span>(ext) =&gt; <span class="cn">Some</span>(ext),
          }
      }
  }
  
  <span class="kw">fn</span> file_name(file_path: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; {
    <span class="co">// implementation elided</span>
    <span class="pp">unimplemented!</span>()
  }</code></pre></div>
  <p>You might think that we could just use the <code>map</code> combinator to reduce the case analysis, but its type doesn‚Äôt quite fit. Namely, <code>map</code> takes a function that does something only with the inner value. The result of that function is then <em>always</em> <a href="#code-option-map">rewrapped with <code>Some</code></a>. Instead, we need something like <code>map</code>, but which allows the caller to return another <code>Option</code>. Its generic implementation is even simpler than <code>map</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> and_then&lt;F, T, A&gt;(option: <span class="dt">Option</span>&lt;T&gt;, f: F) -&gt; <span class="dt">Option</span>&lt;A&gt;
          <span class="kw">where</span> F: <span class="bu">FnOnce</span>(T) -&gt; <span class="dt">Option</span>&lt;A&gt; {
      <span class="kw">match</span> option {
          <span class="cn">None</span> =&gt; <span class="cn">None</span>,
          <span class="cn">Some</span>(value) =&gt; f(value),
      }
  }</code></pre></div>
  <p>Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> file_path_ext(file_path: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; {
      file_name(file_path).and_then(extension)
  }</code></pre></div>
  <p>The <code>Option</code> type has many other combinators <a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard library</a>. It is a good idea to skim this list and familiarize yourself with what‚Äôs available‚Äîthey can often reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for <code>Result</code>, which we will talk about next.</p>
  <p>Combinators make using types like <code>Option</code> ergonomic because they reduce explicit case analysis. They are also composable because they permit the caller to handle the possibility of absence in their own way. Methods like <code>unwrap</code> remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code>.</p>
  </section>
  </section>
  <section id="the-result-type" class="level4">
  <h4>The <code>Result</code> type</h4>
  <p>The <code>Result</code> type is also <a href="http://doc.rust-lang.org/std/result/">defined in the standard library</a>:</p>
  <p><span id="code-result-def"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; {
      <span class="cn">Ok</span>(T),
      <span class="cn">Err</span>(E),
  }</code></pre></div>
  <p>The <code>Result</code> type is a richer version of <code>Option</code>. Instead of expressing the possibility of <em>absence</em> like <code>Option</code> does, <code>Result</code> expresses the possibility of <em>error</em>. Usually, the <em>error</em> is used to explain why the result of some computation failed. This is a strictly more general form of <code>Option</code>. Consider the following type alias, which is semantically equivalent to the real <code>Option&lt;T&gt;</code> in every way:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Option&lt;T&gt; = <span class="dt">Result</span>&lt;T, ()&gt;;</code></pre></div>
  <p>This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced ‚Äúunit‚Äù or ‚Äúempty tuple‚Äù). Exactly one value inhabits the <code>()</code> type: <code>()</code>. (Yup, the type and value level terms have the same notation!)</p>
  <p>The <code>Result</code> type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is meant to be expected or ‚Äú<code>Ok</code>‚Äù while the other outcome is meant to be unexpected or ‚Äú<code>Err</code>‚Äù.</p>
  <p>Just like <code>Option</code>, the <code>Result</code> type also has an <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code> method defined</a> in the standard library. Let‚Äôs define it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T, E: ::std::fmt::<span class="bu">Debug</span>&gt; <span class="dt">Result</span>&lt;T, E&gt; {
      <span class="kw">fn</span> unwrap(<span class="kw">self</span>) -&gt; T {
          <span class="kw">match</span> <span class="kw">self</span> {
              <span class="dt">Result</span>::<span class="cn">Ok</span>(val) =&gt; val,
              <span class="dt">Result</span>::<span class="cn">Err</span>(err) =&gt;
                <span class="pp">panic!</span>(<span class="st">&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;</span>, err),
          }
      }
  }</code></pre></div>
  <p>This is effectively the same as our <a href="#code-option-def-unwrap">definition for <code>Option::unwrap</code></a>, except it includes the error value in the <code>panic!</code> message. This makes debugging easier, but it also requires us to add a <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> constraint on the <code>E</code> type parameter (which represents our error type). Since the vast majority of types should satisfy the <code>Debug</code> constraint, this tends to work out in practice. (<code>Debug</code> on a type simply means that there‚Äôs a reasonable way to print a human readable description of values with that type.)</p>
  <p>OK, let‚Äôs move on to an example.</p>
  <section id="parsing-integers" class="level5">
  <h5>Parsing integers</h5>
  <p>The Rust standard library makes converting strings to integers dead simple. It‚Äôs so easy in fact, that it is very tempting to write something like the following:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> double_number(number_str: &amp;<span class="dt">str</span>) -&gt; <span class="dt">i32</span> {
      <span class="dv">2</span> * number_str.parse::&lt;<span class="dt">i32</span>&gt;().unwrap()
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> n: <span class="dt">i32</span> = double_number(<span class="st">&quot;10&quot;</span>);
      <span class="pp">assert_eq!</span>(n, <span class="dv">20</span>);
  }</code></pre></div>
  <p>At this point, you should be skeptical of calling <code>unwrap</code>. For example, if the string doesn‚Äôt parse as a number, you‚Äôll get a panic:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntErro
  ‚Ü≥ r { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-l
  ‚Ü≥ inux/build/src/libcore/result.rs:729</code></pre>
  <p>This is rather unsightly, and if this happened inside a library you‚Äôre using, you might be understandably annoyed. Instead, we should try to handle the error in our function and let the caller decide what to do. This means changing the return type of <code>double_number</code>. But to what? Well, that requires looking at the signature of the <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code> method</a> in the standard library:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> <span class="dt">str</span> {
      <span class="kw">fn</span> parse&lt;F: FromStr&gt;(&amp;<span class="kw">self</span>) -&gt; <span class="dt">Result</span>&lt;F, F::<span class="cn">Err</span>&gt;;
  }</code></pre></div>
  <p>Hmm. So we at least know that we need to use a <code>Result</code>. Certainly, it‚Äôs possible that this could have returned an <code>Option</code>. After all, a string either parses as a number or it doesn‚Äôt, right? That‚Äôs certainly a reasonable way to go, but the implementation internally distinguishes <em>why</em> the string didn‚Äôt parse as an integer. (Whether it‚Äôs an empty string, an invalid digit, too big or too small.) Therefore, using a <code>Result</code> makes sense because we want to provide more information than simply ‚Äúabsence.‚Äù We want to say <em>why</em> the parsing failed. You should try to emulate this line of reasoning when faced with a choice between <code>Option</code> and <code>Result</code>. If you can provide detailed error information, then you probably should. (We‚Äôll see more on this later.)</p>
  <p>OK, but how do we write our return type? The <code>parse</code> method as defined above is generic over all the different number types defined in the standard library. We could (and probably should) also make our function generic, but let‚Äôs favor explicitness for the moment. We only care about <code>i32</code>, so we need to <a href="http://doc.rust-lang.org/std/primitive.i32.html">find its implementation of <code>FromStr</code></a> (do a <code>CTRL-F</code> in your browser for ‚ÄúFromStr‚Äù) and look at its <a href="http://doc.rust-lang.org/book/associated-types.html">associated type</a> <code>Err</code>. We did this so we can find the concrete error type. In this case, it‚Äôs <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>. Finally, we can rewrite our function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, ParseIntError&gt; {
      <span class="kw">match</span> number_str.parse::&lt;<span class="dt">i32</span>&gt;() {
          <span class="cn">Ok</span>(n) =&gt; <span class="cn">Ok</span>(<span class="dv">2</span> * n),
          <span class="cn">Err</span>(err) =&gt; <span class="cn">Err</span>(err),
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_number(<span class="st">&quot;10&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">assert_eq!</span>(n, <span class="dv">20</span>),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {:?}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>This is a little better, but now we‚Äôve written a lot more code! The case analysis has once again bitten us.</p>
  <p>Combinators to the rescue! Just like <code>Option</code>, <code>Result</code> has lots of combinators defined as methods. There is a large intersection of common combinators between <code>Result</code> and <code>Option</code>. In particular, <code>map</code> is part of that intersection:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, ParseIntError&gt; {
      number_str.parse::&lt;<span class="dt">i32</span>&gt;().map(|n| <span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_number(<span class="st">&quot;10&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">assert_eq!</span>(n, <span class="dv">20</span>),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {:?}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>The usual suspects are all there for <code>Result</code>, including <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> and <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>. Additionally, since <code>Result</code> has a second type parameter, there are combinators that affect only the error type, such as <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a> (instead of <code>map</code>) and <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a> (instead of <code>and_then</code>).</p>
  </section>
  <section id="the-result-type-alias-idiom" class="level5">
  <h5>The <code>Result</code> type alias idiom</h5>
  <p>In the standard library, you may frequently see types like <code>Result&lt;i32&gt;</code>. But wait, <a href="#code-result-def">we defined <code>Result</code></a> to have two type parameters. How can we get away with only specifying one? The key is to define a <code>Result</code> type alias that <em>fixes</em> one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous example parsing integers could be rewritten like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  <span class="kw">use</span> std::result;
  
  <span class="kw">type</span> Result&lt;T&gt; = result::<span class="dt">Result</span>&lt;T, ParseIntError&gt;;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>&gt; {
      <span class="pp">unimplemented!</span>();
  }</code></pre></div>
  <p>Why would we do this? Well, if we have a lot of functions that could return <code>ParseIntError</code>, then it‚Äôs much more convenient to define an alias that always uses <code>ParseIntError</code> so that we don‚Äôt have to write it out all the time.</p>
  <p>The most prominent place this idiom is used in the standard library is with <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Typically, one writes <code>io::Result&lt;T&gt;</code>, which makes it clear that you‚Äôre using the <code>io</code> module‚Äôs type alias instead of the plain definition from <code>std::result</code>. (This idiom is also used for <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.)</p>
  </section>
  </section>
  <section id="a-brief-interlude-unwrapping-isnt-evil" class="level4">
  <h4>A brief interlude: unwrapping isn‚Äôt evil</h4>
  <p>If you‚Äôve been following along, you might have noticed that I‚Äôve taken a pretty hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort your program. <em>Generally speaking</em>, this is good advice.</p>
  <p>However, <code>unwrap</code> can still be used judiciously. What exactly justifies use of <code>unwrap</code> is somewhat of a grey area and reasonable people can disagree. I‚Äôll summarize some of my <em>opinions</em> on the matter.</p>
  <ul>
  <li><strong>In examples and quick ‚Äòn‚Äô dirty code.</strong> Sometimes you‚Äôre writing examples or a quick program, and error handling simply isn‚Äôt important. Beating the convenience of <code>unwrap</code> can be hard in such scenarios, so it is very appealing.</li>
  <li><strong>When panicking indicates a bug in the program.</strong> When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible. This is because it exposes a bug in your program. This can be explicit, like from an <code>assert!</code> failing, or it could be because your index into an array was out of bounds.</li>
  </ul>
  <p>This is probably not an exhaustive list. Moreover, when using an <code>Option</code>, it is often better to use its <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a> method. <code>expect</code> does exactly the same thing as <code>unwrap</code>, except it prints a message you give to <code>expect</code>. This makes the resulting panic a bit nicer to deal with, since it will show your message instead of ‚Äúcalled unwrap on a <code>None</code> value.‚Äù</p>
  <p>My advice boils down to this: use good judgment. There‚Äôs a reason why the words ‚Äúnever do X‚Äù or ‚ÄúY is considered harmful‚Äù don‚Äôt appear in my writing. There are trade offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases. My goal is only to help you evaluate trade offs as accurately as possible.</p>
  <p>Now that we‚Äôve covered the basics of error handling in Rust, and explained unwrapping, let‚Äôs start exploring more of the standard library.</p>
  </section>
  </section>
  <section id="working-with-multiple-error-types" class="level3">
  <h3>Working with multiple error types</h3>
  <p>Thus far, we‚Äôve looked at error handling where everything was either an <code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code>. But what happens when you have both an <code>Option</code> and a <code>Result</code>? Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a <code>Result&lt;T, Error2&gt;</code>? Handling <em>composition of distinct error types</em> is the next challenge in front of us, and it will be the major theme throughout the rest of this chapter.</p>
  <section id="composing-option-and-result" class="level4">
  <h4>Composing <code>Option</code> and <code>Result</code></h4>
  <p>So far, I‚Äôve talked about combinators defined for <code>Option</code> and combinators defined for <code>Result</code>. We can use these combinators to compose results of different computations without doing explicit case analysis.</p>
  <p>Of course, in real code, things aren‚Äôt always as clean. Sometimes you have a mix of <code>Option</code> and <code>Result</code> types. Must we resort to explicit case analysis, or can we continue using combinators?</p>
  <p>For now, let‚Äôs revisit one of the first examples in this chapter:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> argv = env::args();
      <span class="kw">let</span> arg: <span class="dt">String</span> = argv.nth(<span class="dv">1</span>).unwrap(); <span class="co">// error 1</span>
      <span class="kw">let</span> n: <span class="dt">i32</span> = arg.parse().unwrap(); <span class="co">// error 2</span>
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="dv">2</span> * n);
  }</code></pre></div>
  <p>Given our new found knowledge of <code>Option</code>, <code>Result</code> and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn‚Äôt panic if there‚Äôs an error.</p>
  <p>The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while <code>arg.parse()</code> produces a <code>Result</code>. These aren‚Äôt directly composable. When faced with both an <code>Option</code> and a <code>Result</code>, the solution is <em>usually</em> to convert the <code>Option</code> to a <code>Result</code>. In our case, the absence of a command line parameter (from <code>env::args()</code>) means the user didn‚Äôt invoke the program correctly. We could just use a <code>String</code> to describe the error. Let‚Äôs try:</p>
  <p><span id="code-error-double-string"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> double_arg(<span class="kw">mut</span> argv: env::Args) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">String</span>&gt; {
      argv.nth(<span class="dv">1</span>)
          .ok_or(<span class="st">&quot;Please give at least one argument&quot;</span>.to_owned())
          .and_then(|arg| arg.parse::&lt;<span class="dt">i32</span>&gt;().map_err(|err| err.to_string()))
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_arg(env::args()) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>There are a couple new things in this example. The first is the use of the <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> combinator. This is one way to convert an <code>Option</code> into a <code>Result</code>. The conversion requires you to specify what error to use if <code>Option</code> is <code>None</code>. Like the other combinators we‚Äôve seen, its definition is very simple:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ok_or&lt;T, E&gt;(option: <span class="dt">Option</span>&lt;T&gt;, err: E) -&gt; <span class="dt">Result</span>&lt;T, E&gt; {
      <span class="kw">match</span> option {
          <span class="cn">Some</span>(val) =&gt; <span class="cn">Ok</span>(val),
          <span class="cn">None</span> =&gt; <span class="cn">Err</span>(err),
      }
  }</code></pre></div>
  <p>The other new combinator used here is <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>. This is just like <code>Result::map</code>, except it maps a function on to the <em>error</em> portion of a <code>Result</code> value. If the <code>Result</code> is an <code>Ok(...)</code> value, then it is returned unmodified.</p>
  <p>We use <code>map_err</code> here because it is necessary for the error types to remain the same (because of our use of <code>and_then</code>). Since we chose to convert the <code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code>) to a <code>Result&lt;String, String&gt;</code>, we must also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code>.</p>
  </section>
  <section id="the-limits-of-combinators" class="level4">
  <h4>The limits of combinators</h4>
  <p>Doing IO and parsing input is a very common task, and it‚Äôs one that I personally have done a lot of in Rust. Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.</p>
  <p>Let‚Äôs start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. Then we multiply it by <code>2</code> and print the output.</p>
  <p>Although I‚Äôve tried to convince you not to use <code>unwrap</code>, it can be useful to first write your code using <code>unwrap</code>. It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur. Let‚Äôs start there so we can get a handle on the code, and then refactor it to use better error handling.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">i32</span> {
      <span class="kw">let</span> <span class="kw">mut</span> file = File::open(file_path).unwrap(); <span class="co">// error 1</span>
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      file.read_to_string(&amp;<span class="kw">mut</span> contents).unwrap(); <span class="co">// error 2</span>
      <span class="kw">let</span> n: <span class="dt">i32</span> = contents.trim().parse().unwrap(); <span class="co">// error 3</span>
      <span class="dv">2</span> * n
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> doubled = file_double(<span class="st">&quot;foobar&quot;</span>);
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, doubled);
  }</code></pre></div>
  <p>(N.B. The <code>AsRef&lt;Path&gt;</code> is used because those are the <a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">same bounds used on <code>std::fs::File::open</code></a>. This makes it ergnomic to use any kind of string as a file path.)</p>
  <p>There are three different errors that can occur here:</p>
  <ol type="1">
  <li>A problem opening the file.</li>
  <li>A problem reading data from the file.</li>
  <li>A problem parsing the data as a number.</li>
  </ol>
  <p>The first two problems are described via the <a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> type. We know this because of the return types of <a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> and <a href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>. (Note that they both use the <a href="#the-result-type-alias-idiom"><code>Result</code> type alias idiom</a> described previously. If you click on the <code>Result</code> type, you‚Äôll <a href="http://doc.rust-lang.org/std/io/type.Result.html">see the type alias</a>, and consequently, the underlying <code>io::Error</code> type.) The third problem is described by the <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> type. The <code>io::Error</code> type in particular is <em>pervasive</em> throughout the standard library. You will see it again and again.</p>
  <p>Let‚Äôs start the process of refactoring the <code>file_double</code> function. To make this function composable with other components of the program, it should <em>not</em> panic if any of the above error conditions are met. Effectively, this means that the function should <em>return an error</em> if any of its operations fail. Our problem is that the return type of <code>file_double</code> is <code>i32</code>, which does not give us any useful way of reporting an error. Thus, we must start by changing the return type from <code>i32</code> to something else.</p>
  <p>The first thing we need to decide: should we use <code>Option</code> or <code>Result</code>? We certainly could use <code>Option</code> very easily. If any of the three errors occur, we could simply return <code>None</code>. This will work <em>and it is better than panicking</em>, but we can do a lot better. Instead, we should pass some detail about the error that occurred. Since we want to express the <em>possibility of error</em>, we should use <code>Result&lt;i32, E&gt;</code>. But what should <code>E</code> be? Since two <em>different</em> types of errors can occur, we need to convert them to a common type. One such type is <code>String</code>. Let‚Äôs see how that impacts our code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">String</span>&gt; {
      File::open(file_path)
           .map_err(|err| err.to_string())
           .and_then(|<span class="kw">mut</span> file| {
                <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
                file.read_to_string(&amp;<span class="kw">mut</span> contents)
                    .map_err(|err| err.to_string())
                    .map(|_| contents)
           })
           .and_then(|contents| {
                contents.trim().parse::&lt;<span class="dt">i32</span>&gt;()
                        .map_err(|err| err.to_string())
           })
           .map(|n| <span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>This code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way we write it is by <em>following the types</em>. As soon as we changed the return type of <code>file_double</code> to <code>Result&lt;i32, String&gt;</code>, we had to start looking for the right combinators. In this case, we only used three different combinators: <code>and_then</code>, <code>map</code> and <code>map_err</code>.</p>
  <p><code>and_then</code> is used to chain multiple computations where each computation could return an error. After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, there are two calls to <code>and_then</code>.</p>
  <p><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code>. For example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is an <code>i32</code>) by <code>2</code>. If an error had occurred before that point, this operation would have been skipped because of how <code>map</code> is defined.</p>
  <p><code>map_err</code> is the trick that makes all of this work. <code>map_err</code> is just like <code>map</code>, except it applies a function to the <code>Err(...)</code> value of a <code>Result</code>. In this case, we want to convert all of our errors to one type: <code>String</code>. Since both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code>, we can call the <code>to_string()</code> method to convert them.</p>
  <p>With all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. Let‚Äôs try a different approach: early returns.</p>
  </section>
  <section id="early-returns" class="level4">
  <h4>Early returns</h4>
  <p>I‚Äôd like to take the code from the previous section and rewrite it using <em>early returns</em>. Early returns let you exit the function early. We can‚Äôt return early in <code>file_double</code> from inside another closure, so we‚Äôll need to revert back to explicit case analysis.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">String</span>&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="kw">match</span> File::open(file_path) {
          <span class="cn">Ok</span>(file) =&gt; file,
          <span class="cn">Err</span>(err) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(err.to_string()),
      };
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Err</span>(err) = file.read_to_string(&amp;<span class="kw">mut</span> contents) {
          <span class="kw">return</span> <span class="cn">Err</span>(err.to_string());
      }
      <span class="kw">let</span> n: <span class="dt">i32</span> = <span class="kw">match</span> contents.trim().parse() {
          <span class="cn">Ok</span>(n) =&gt; n,
          <span class="cn">Err</span>(err) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(err.to_string()),
      };
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>Reasonable people can disagree over whether this code is better that the code that uses combinators, but if you aren‚Äôt familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with <code>match</code> and <code>if let</code>. If an error occurs, it simply stops executing the function and returns the error (by converting it to a string).</p>
  <p>Isn‚Äôt this a step backwards though? Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we‚Äôve reverted back to explicit case analysis here. It turns out, there are <em>multiple</em> ways to reduce explicit case analysis. Combinators aren‚Äôt the only way.</p>
  </section>
  <section id="the-try-macro" class="level4">
  <h4>The <code>try!</code> macro</h4>
  <p>A cornerstone of error handling in Rust is the <code>try!</code> macro. The <code>try!</code> macro abstracts case analysis just like combinators, but unlike combinators, it also abstracts <em>control flow</em>. Namely, it can abstract the <em>early return</em> pattern seen above.</p>
  <p>Here is a simplified definition of a <code>try!</code> macro:</p>
  <p><span id="code-try-def-simple"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="cn">Ok</span>(val) =&gt; val,
          <span class="cn">Err</span>(err) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(err),
      });
  }</code></pre></div>
  <p>(The <a href="http://doc.rust-lang.org/std/macro.try!.html">real definition</a> is a bit more sophisticated. We will address that later.)</p>
  <p>Using the <code>try!</code> macro makes it very easy to simplify our last example. Since it does the case analysis and the early return for us, we get tighter code that is easier to read:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">String</span>&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path).map_err(|e| e.to_string()));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(|e| e.to_string()));
      <span class="kw">let</span> n = <span class="pp">try!</span>(contents.trim().parse::&lt;<span class="dt">i32</span>&gt;().map_err(|e| e.to_string()));
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>The <code>map_err</code> calls are still necessary given <a href="#code-try-def-simple">our definition of <code>try!</code></a>. This is because the error types still need to be converted to <code>String</code>. The good news is that we will soon learn how to remove those <code>map_err</code> calls! The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the <code>map_err</code> calls.</p>
  </section>
  <section id="defining-your-own-error-type" class="level4">
  <h4>Defining your own error type</h4>
  <p>Before we dive into some of the standard library error traits, I‚Äôd like to wrap up this section by removing the use of <code>String</code> as our error type in the previous examples.</p>
  <p>Using <code>String</code> as we did in our previous examples is convenient because it‚Äôs easy to convert errors to strings, or even make up your own errors as strings on the spot. However, using <code>String</code> for your errors has some downsides.</p>
  <p>The first downside is that the error messages tend to clutter your code. It‚Äôs possible to define the error messages elsewhere, but unless you‚Äôre unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly this in a <a href="#code-error-double-string">previous example</a>.</p>
  <p>The second and more important downside is that <code>String</code>s are <em>lossy</em>. That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a <code>String</code> error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)</p>
  <p>For example, the <code>io::Error</code> type embeds an <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>, which is <em>structured data</em> that represents what went wrong during an IO operation. This is important because you might want to react differently depending on the error. (e.g., A <code>BrokenPipe</code> error might mean quitting your program gracefully while a <code>NotFound</code> error might mean exiting with an error code and showing an error to the user.) With <code>io::ErrorKind</code>, the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a <code>String</code>.</p>
  <p>Instead of using a <code>String</code> as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with <em>structured data</em>. We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.</p>
  <p>The ideal way to represent <em>one of many possibilities</em> is to define our own sum type using <code>enum</code>. In our case, an error is either an <code>io::Error</code> or a <code>num::ParseIntError</code>, so a natural definition arises:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// We derive `Debug` because all types should probably derive `Debug`.</span>
  <span class="co">// This gives us a reasonable human readable description of `CliError` values.</span>
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }</code></pre></div>
  <p>Tweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our <code>CliError</code> type using the corresponding value constructor:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path).map_err(CliError::Io));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(CliError::Io));
      <span class="kw">let</span> n: <span class="dt">i32</span> = <span class="pp">try!</span>(contents.trim().parse().map_err(CliError::Parse));
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="cn">Ok</span>(n) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="cn">Err</span>(err) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Error: {:?}&quot;</span>, err),
      }
  }</code></pre></div>
  <p>The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code>. The <em>caller</em> gets to decide the level of detail to report to the user. In effect, using a <code>String</code> as an error type removes choices from the caller while using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the conveniences as before in addition to <em>structured data</em> describing the error.</p>
  <p>A rule of thumb is to define your own error type, but a <code>String</code> error type will do in a pinch, particularly if you‚Äôre writing an application. If you‚Äôre writing a library, defining your own error type should be strongly preferred so that you don‚Äôt remove choices from the caller unnecessarily.</p>
  </section>
  </section>
  <section id="standard-library-traits-used-for-error-handling" class="level3">
  <h3>Standard library traits used for error handling</h3>
  <p>The standard library defines two integral traits for error handling: <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> and <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>. While <code>Error</code> is designed specifically for generically describing errors, the <code>From</code> trait serves a more general role for converting values between two distinct types.</p>
  <section id="the-error-trait" class="level4">
  <h4>The <code>Error</code> trait</h4>
  <p>The <code>Error</code> trait is <a href="http://doc.rust-lang.org/std/error/trait.Error.html">defined in the standard library</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::{<span class="bu">Debug</span>, <span class="bu">Display</span>};
  
  <span class="kw">trait</span> Error: <span class="bu">Debug</span> + <span class="bu">Display</span> {
    <span class="co">/// A short description of the error.</span>
    <span class="kw">fn</span> description(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="dt">str</span>;
  
    <span class="co">/// The lower level cause of this error, if any.</span>
    <span class="kw">fn</span> cause(&amp;<span class="kw">self</span>) -&gt; <span class="dt">Option</span>&lt;&amp;Error&gt; { <span class="cn">None</span> }
  }</code></pre></div>
  <p>This trait is super generic because it is meant to be implemented for <em>all</em> types that represent errors. This will prove useful for writing composable code as we‚Äôll see later. Otherwise, the trait allows you to do at least the following things:</p>
  <ul>
  <li>Obtain a <code>Debug</code> representation of the error.</li>
  <li>Obtain a user-facing <code>Display</code> representation of the error.</li>
  <li>Obtain a short description of the error (via the <code>description</code> method).</li>
  <li>Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</li>
  </ul>
  <p>The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and <code>Display</code>. The latter two are from the two methods defined on <code>Error</code>. The power of <code>Error</code> comes from the fact that all error types impl <code>Error</code>, which means errors can be existentially quantified as a <a href="http://doc.rust-lang.org/book/trait-objects.html">trait object</a>. This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code>. Indeed, the <code>cause</code> method returns an <code>&amp;Error</code>, which is itself a trait object. We‚Äôll revisit the <code>Error</code> trait‚Äôs utility as a trait object later.</p>
  <p>For now, it suffices to show an example implementing the <code>Error</code> trait. Let‚Äôs use the error type we defined in the <a href="#defining-your-own-error-type">previous section</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// We derive `Debug` because all types should probably derive `Debug`.</span>
  <span class="co">// This gives us a reasonable human readable description of `CliError` values.</span>
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }</code></pre></div>
  <p>This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number. The error could represent as many error types as you want by adding new variants to the <code>enum</code> definition.</p>
  <p>Implementing <code>Error</code> is pretty straight-forward. It‚Äôs mostly going to be a lot explicit case analysis.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error;
  <span class="kw">use</span> std::fmt;
  
  <span class="kw">impl</span> fmt::<span class="bu">Display</span> <span class="kw">for</span> CliError {
      <span class="kw">fn</span> fmt(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> fmt::Formatter) -&gt; fmt::<span class="dt">Result</span> {
          <span class="kw">match</span> *<span class="kw">self</span> {
              <span class="co">// Both underlying errors already impl `Display`, so we defer to</span>
              <span class="co">// their implementations.</span>
              CliError::Io(<span class="kw">ref</span> err) =&gt; <span class="pp">write!</span>(f, <span class="st">&quot;IO error: {}&quot;</span>, err),
              CliError::Parse(<span class="kw">ref</span> err) =&gt; <span class="pp">write!</span>(f, <span class="st">&quot;Parse error: {}&quot;</span>, err),
          }
      }
  }
  
  <span class="kw">impl</span> error::Error <span class="kw">for</span> CliError {
      <span class="kw">fn</span> description(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="dt">str</span> {
          <span class="co">// Both underlying errors already impl `Error`, so we defer to their</span>
          <span class="co">// implementations.</span>
          <span class="kw">match</span> *<span class="kw">self</span> {
              CliError::Io(<span class="kw">ref</span> err) =&gt; err.description(),
              <span class="co">// Normally we can just write `err.description()`, but the error</span>
              <span class="co">// type has a concrete method called `description`, which conflicts</span>
              <span class="co">// with the trait method. For now, we must explicitly call</span>
              <span class="co">// `description` through the `Error` trait.</span>
              CliError::Parse(<span class="kw">ref</span> err) =&gt; error::Error::description(err),
          }
      }
  
      <span class="kw">fn</span> cause(&amp;<span class="kw">self</span>) -&gt; <span class="dt">Option</span>&lt;&amp;error::Error&gt; {
          <span class="kw">match</span> *<span class="kw">self</span> {
              <span class="co">// N.B. Both of these implicitly cast `err` from their concrete</span>
              <span class="co">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span>
              <span class="co">// to a trait object `&amp;Error`. This works because both error types</span>
              <span class="co">// implement `Error`.</span>
              CliError::Io(<span class="kw">ref</span> err) =&gt; <span class="cn">Some</span>(err),
              CliError::Parse(<span class="kw">ref</span> err) =&gt; <span class="cn">Some</span>(err),
          }
      }
  }</code></pre></div>
  <p>We note that this is a very typical implementation of <code>Error</code>: match on your different error types and satisfy the contracts defined for <code>description</code> and <code>cause</code>.</p>
  </section>
  <section id="the-from-trait" class="level4">
  <h4>The <code>From</code> trait</h4>
  <p>The <code>std::convert::From</code> trait is <a href="http://doc.rust-lang.org/std/convert/trait.From.html">defined in the standard library</a>:</p>
  <p><span id="code-from-def"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> From&lt;T&gt; {
      <span class="kw">fn</span> from(T) -&gt; <span class="kw">Self</span>;
  }</code></pre></div>
  <p>Deliciously simple, yes? <code>From</code> is very useful because it gives us a generic way to talk about conversion <em>from</em> a particular type <code>T</code> to some other type (in this case, ‚Äúsome other type‚Äù is the subject of the impl, or <code>Self</code>). The crux of <code>From</code> is the <a href="http://doc.rust-lang.org/std/convert/trait.From.html">set of implementations provided by the standard library</a>.</p>
  <p>Here are a few simple examples demonstrating how <code>From</code> works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> string: <span class="dt">String</span> = From::from(<span class="st">&quot;foo&quot;</span>);
  <span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = From::from(<span class="st">&quot;foo&quot;</span>);
  <span class="kw">let</span> cow: ::std::borrow::Cow&lt;<span class="dt">str</span>&gt; = From::from(<span class="st">&quot;foo&quot;</span>);</code></pre></div>
  <p>OK, so <code>From</code> is useful for converting between strings. But what about errors? It turns out, there is one critical impl:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;<span class="ot">'a</span>, E: Error + <span class="ot">'a</span>&gt; From&lt;E&gt; <span class="kw">for</span> <span class="dt">Box</span>&lt;Error + <span class="ot">'a</span>&gt;</code></pre></div>
  <p>This impl says that for <em>any</em> type that impls <code>Error</code>, we can convert it to a trait object <code>Box&lt;Error&gt;</code>. This may not seem terribly surprising, but it is useful in a generic context.</p>
  <p>Remember the two errors we were dealing with previously? Specifically, <code>io::Error</code> and <code>num::ParseIntError</code>. Since both impl <code>Error</code>, they work with <code>From</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error::Error;
  <span class="kw">use</span> std::fs;
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// We have to jump through some hoops to actually get error values.</span>
  <span class="kw">let</span> io_err: io::Error = io::Error::last_os_error();
  <span class="kw">let</span> parse_err: num::ParseIntError = <span class="st">&quot;not a number&quot;</span>.parse::&lt;<span class="dt">i32</span>&gt;().unwrap_err();
  
  <span class="co">// OK, here are the conversions.</span>
  <span class="kw">let</span> err1: <span class="dt">Box</span>&lt;Error&gt; = From::from(io_err);
  <span class="kw">let</span> err2: <span class="dt">Box</span>&lt;Error&gt; = From::from(parse_err);</code></pre></div>
  <p>There is a really important pattern to recognize here. Both <code>err1</code> and <code>err2</code> have the <em>same type</em>. This is because they are existentially quantified types, or trait objects. In particular, their underlying type is <em>erased</em> from the compiler‚Äôs knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same. Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same function call: <code>From::from</code>. This is because <code>From::from</code> is overloaded on both its argument and its return type.</p>
  <p>This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.</p>
  <p>Time to revisit an old friend; the <code>try!</code> macro.</p>
  </section>
  <section id="the-real-try-macro" class="level4">
  <h4>The real <code>try!</code> macro</h4>
  <p>Previously, we presented this definition of <code>try!</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="cn">Ok</span>(val) =&gt; val,
          <span class="cn">Err</span>(err) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(err),
      });
  }</code></pre></div>
  <p>This is not its real definition. Its real definition is <a href="http://doc.rust-lang.org/std/macro.try!.html">in the standard library</a>:</p>
  <p><span id="code-try-def"></span></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="cn">Ok</span>(val) =&gt; val,
          <span class="cn">Err</span>(err) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(::std::convert::From::from(err)),
      });
  }</code></pre></div>
  <p>There‚Äôs one tiny but powerful change: the error value is passed through <code>From::from</code>. This makes the <code>try!</code> macro a lot more powerful because it gives you automatic type conversion for free.</p>
  <p>Armed with our more powerful <code>try!</code> macro, let‚Äôs take a look at code we wrote previously to read a file and convert its contents to an integer:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">String</span>&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path).map_err(|e| e.to_string()));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(|e| e.to_string()));
      <span class="kw">let</span> n = <span class="pp">try!</span>(contents.trim().parse::&lt;<span class="dt">i32</span>&gt;().map_err(|e| e.to_string()));
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre></div>
  <p>Earlier, we promised that we could get rid of the <code>map_err</code> calls. Indeed, all we have to do is pick a type that <code>From</code> works with. As we saw in the previous section, <code>From</code> has an impl that let‚Äôs it convert any error type into a <code>Box&lt;Error&gt;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error::Error;
  <span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, <span class="dt">Box</span>&lt;Error&gt;&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents));
      <span class="kw">let</span> n = <span class="pp">try!</span>(contents.trim().parse::&lt;<span class="dt">i32</span>&gt;());
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre></div>
  <p>We are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because the <code>try!</code> macro encapsulates three things simultaneously:</p>
  <ol type="1">
  <li>Case analysis.</li>
  <li>Control flow.</li>
  <li>Error type conversion.</li>
  </ol>
  <p>When all three things are combined, we get code that is unencumbered by combinators, calls to <code>unwrap</code> or case analysis.</p>
  <p>There‚Äôs one little nit left: the <code>Box&lt;Error&gt;</code> type is <em>opaque</em>. If we return a <code>Box&lt;Error&gt;</code> to the caller, the caller can‚Äôt (easily) inspect underlying error type. The situation is certainly better than <code>String</code> because the caller can call methods like <a href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a> and <a href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>, but the limitation remains: <code>Box&lt;Error&gt;</code> is opaque. (N.B. This isn‚Äôt entirely true because Rust does have runtime reflection, which is useful in some scenarios that are <a href="https://crates.io/crates/error">beyond the scope of this chapter</a>.)</p>
  <p>It‚Äôs time to revisit our custom <code>CliError</code> type and tie everything together.</p>
  </section>
  <section id="composing-custom-error-types" class="level4">
  <h4>Composing custom error types</h4>
  <p>In the last section, we looked at the real <code>try!</code> macro and how it does automatic type conversion for us by calling <code>From::from</code> on the error value. In particular, we converted errors to <code>Box&lt;Error&gt;</code>, which works, but the type is opaque to callers.</p>
  <p>To fix this, we use the same remedy that we‚Äôre already familiar with: a custom error type. Once again, here is the code that reads the contents of a file and converts it to an integer:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::{<span class="kw">self</span>, Read};
  <span class="kw">use</span> std::num;
  <span class="kw">use</span> std::path::Path;
  
  <span class="co">// We derive `Debug` because all types should probably derive `Debug`.</span>
  <span class="co">// This gives us a reasonable human readable description of `CliError` values.</span>
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }
  
  <span class="kw">fn</span> file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path).map_err(CliError::Io));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(CliError::Io));
      <span class="kw">let</span> n: <span class="dt">i32</span> = <span class="pp">try!</span>(contents.trim().parse().map_err(CliError::Parse));
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre></div>
  <p>Notice that we still have the calls to <code>map_err</code>. Why? Well, recall the definitions of <a href="#code-try-def"><code>try!</code></a> and <a href="#code-from-def"><code>From</code></a>. The problem is that there is no <code>From</code> impl that allows us to convert from error types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code>. Of course, it is easy to fix this! Since we defined <code>CliError</code>, we can impl <code>From</code> with it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="kw">impl</span> From&lt;io::Error&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: io::Error) -&gt; CliError {
          CliError::Io(err)
      }
  }
  
  <span class="kw">impl</span> From&lt;num::ParseIntError&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: num::ParseIntError) -&gt; CliError {
          CliError::Parse(err)
      }
  }</code></pre></div>
  <p>All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from other error types. In our case, construction is as simple as invoking the corresponding value constructor. Indeed, it is <em>typically</em> this easy.</p>
  <p>We can finally rewrite <code>file_double</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="dt">Result</span>&lt;<span class="dt">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="pp">try!</span>(File::open(file_path));
      <span class="kw">let</span> <span class="kw">mut</span> contents = <span class="dt">String</span>::new();
      <span class="pp">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents));
      <span class="kw">let</span> n: <span class="dt">i32</span> = <span class="pp">try!</span>(contents.trim().parse());
      <span class="cn">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre></div>
  <p>The only thing we did here was remove the calls to <code>map_err</code>. They are no longer needed because the <code>try!</code> macro invokes <code>From::from</code> on the error value. This works because we‚Äôve provided <code>From</code> impls for all the error types that could appear.</p>
  <p>If we modified our <code>file_double</code> function to perform some other operation, say, convert a string to a float, then we‚Äôd need to add a new variant to our error type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      ParseInt(num::ParseIntError),
      ParseFloat(num::ParseFloatError),
  }</code></pre></div>
  <p>And add a new <code>From</code> impl:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">use</span> std::num;
  
  <span class="kw">impl</span> From&lt;num::ParseFloatError&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: num::ParseFloatError) -&gt; CliError {
          CliError::ParseFloat(err)
      }
  }</code></pre></div>
  <p>And that‚Äôs it!</p>
  </section>
  <section id="advice-for-library-writers" class="level4">
  <h4>Advice for library writers</h4>
  <p>If your library needs to report custom errors, then you should probably define your own error type. It‚Äôs up to you whether or not to expose its representation (like <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>) or keep it hidden (like <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>). Regardless of how you do it, it‚Äôs usually good practice to at least provide some information about the error beyond just its <code>String</code> representation. But certainly, this will vary depending on use cases.</p>
  <p>At a minimum, you should probably implement the <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait. This will give users of your library some minimum flexibility for <a href="#the-real-try!-macro">composing errors</a>. Implementing the <code>Error</code> trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both <code>fmt::Debug</code> and <code>fmt::Display</code>).</p>
  <p>Beyond that, it can also be useful to provide implementations of <code>From</code> on your error types. This allows you (the library author) and your users to <a href="#composing-custom-error-types">compose more detailed errors</a>. For example, <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code>.</p>
  <p>Finally, depending on your tastes, you may also want to define a <a href="#the-result-type-alias-idiom"><code>Result</code> type alias</a>, particularly if your library defines a single error type. This is used in the standard library for <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> and <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>
  </section>
  </section>
  <section id="case-study-a-program-to-read-population-data" class="level3">
  <h3>Case study: A program to read population data</h3>
  <p>This chapter was long, and depending on your background, it might be rather dense. While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical. So, we‚Äôre going to do something new: a case study.</p>
  <p>For this, we‚Äôre going to build up a command line program that lets you query world population data. The objective is simple: you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!</p>
  <p>The data we‚Äôll be using comes from the <a href="https://github.com/petewarden/dstkdata">Data Science Toolkit</a>. I‚Äôve prepared some data from it for this exercise. You can either grab the <a href="http://burntsushi.net/stuff/worldcitiespop.csv.gz">world population data</a> (41MB gzip compressed, 145MB uncompressed) or just the <a href="http://burntsushi.net/stuff/uscitiespop.csv.gz">US population data</a> (2.2MB gzip compressed, 7.2MB uncompressed).</p>
  <p>Up until now, we‚Äôve kept the code limited to Rust‚Äôs standard library. For a real task like this though, we‚Äôll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For that, we‚Äôll use the <a href="https://crates.io/crates/csv"><code>csv</code></a>, and <a href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crates.</p>
  <section id="initial-setup" class="level4">
  <h4>Initial setup</h4>
  <p>We‚Äôre not going to spend a lot of time on setting up a project with Cargo because it is already covered well in <a href="http://doc.rust-lang.org/book/hello-cargo.html">the Cargo chapter</a> and <a href="http://doc.crates.io/guide.html">Cargo‚Äôs documentation</a>.</p>
  <p>To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your <code>Cargo.toml</code> looks something like this:</p>
  <pre class="text"><code>[package]
  name = &quot;city-pop&quot;
  version = &quot;0.1.0&quot;
  authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]
  
  [[bin]]
  name = &quot;city-pop&quot;
  
  [dependencies]
  csv = &quot;0.*&quot;
  rustc-serialize = &quot;0.*&quot;
  getopts = &quot;0.*&quot;</code></pre>
  <p>You should already be able to run:</p>
  <pre class="text"><code>cargo build --release
  ./target/release/city-pop
  # Outputs: Hello, world!</code></pre>
  </section>
  <section id="argument-parsing" class="level4">
  <h4>Argument parsing</h4>
  <p>Let‚Äôs get argument parsing out of the way. we won‚Äôt go into too much detail on Getopts, but there is <a href="http://doc.rust-lang.org/getopts/getopts/index.html">some good documentation</a> describing it. The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods). Once the parsing is done, we can decode the program arguments into a Rust struct. From there, we can get information about the flags, for instance, wether they were passed in, and what arguments they had. Here‚Äôs our program with the appropriate <code>extern crate</code> statements, and the basic argument setup for Getopts:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> getopts;
  <span class="kw">extern</span> <span class="kw">crate</span> rustc_serialize;
  
  <span class="kw">use</span> getopts::Options;
  <span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> print_usage(program: &amp;<span class="dt">str</span>, opts: Options) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, opts.usage(&amp;<span class="pp">format!</span>(<span class="st">&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, progr
  ‚Ü≥ am)));
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> args: <span class="dt">Vec</span>&lt;<span class="dt">String</span>&gt; = env::args().collect();
      <span class="kw">let</span> program = args[<span class="dv">0</span>].clone();
  
      <span class="kw">let</span> <span class="kw">mut</span> opts = Options::new();
      opts.optflag(<span class="st">&quot;h&quot;</span>, <span class="st">&quot;help&quot;</span>, <span class="st">&quot;Show this usage message.&quot;</span>);
  
      <span class="kw">let</span> matches = <span class="kw">match</span> opts.parse(&amp;args[<span class="dv">1.</span>.]) {
          <span class="cn">Ok</span>(m)  =&gt; { m }
      <span class="cn">Err</span>(e) =&gt; { <span class="pp">panic!</span>(e.to_string()) }
      };
      <span class="kw">if</span> matches.opt_present(<span class="st">&quot;h&quot;</span>) {
          print_usage(&amp;program, opts);
      <span class="kw">return</span>;
      }
      <span class="kw">let</span> data_path = args[<span class="dv">1</span>].clone();
      <span class="kw">let</span> city = args[<span class="dv">2</span>].clone();
  
      <span class="co">// Do stuff with information</span>
  }</code></pre></div>
  <p>First, we get a vector of the arguments passed into our program. We then store the first one, knowing that it is our program‚Äôs name. Once that‚Äôs done, we set up our argument flags, in this case a simplistic help message flag. Once we have the argument flags set up, we use <code>Options.parse</code> to parse the argument vector (starting from index one, becouse index 0 is the program name). If this was successful, we assign matches to the parsed object, if not, we panic. Once past that, we test if the user passed in the help flag, and if so print the usage message. The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template. If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.</p>
  </section>
  <section id="writing-the-logic" class="level4">
  <h4>Writing the logic</h4>
  <p>We‚Äôre all different in how we write code, but error handling is usually the last thing we want to think about. This isn‚Äôt very good practice for good design, but it can be useful for rapidly prototyping. In our case, because Rust forces us to be explicit about error handling, it will also make it obvious what parts of our program can cause errors. Why? Because Rust will make us call <code>unwrap</code>! This can give us a nice bird‚Äôs eye view of how we need to approach error handling.</p>
  <p>In this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field in matching rows. Let‚Äôs do it. (Make sure to add <code>extern crate csv;</code> to the top of your file.)</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// This struct represents the data in each row of the CSV file.</span>
  <span class="co">// Type based decoding absolves us of a lot of the nitty gritty error</span>
  <span class="co">// handling, like parsing strings as integers or floats.</span>
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">,</span> RustcDecodable<span class="at">)]</span>
  <span class="kw">struct</span> Row {
      country: <span class="dt">String</span>,
      city: <span class="dt">String</span>,
      accent_city: <span class="dt">String</span>,
      region: <span class="dt">String</span>,
  
      <span class="co">// Not every row has data for the population, latitude or longitude!</span>
      <span class="co">// So we express them as `Option` types, which admits the possibility of</span>
      <span class="co">// absence. The CSV parser will fill in the correct value for us.</span>
      population: <span class="dt">Option</span>&lt;<span class="dt">u64</span>&gt;,
      latitude: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt;,
      longitude: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt;,
  }
  
  <span class="kw">fn</span> print_usage(program: &amp;<span class="dt">str</span>, opts: Options) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, opts.usage(&amp;<span class="pp">format!</span>(<span class="st">&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, progr
  ‚Ü≥ am)));
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> args: <span class="dt">Vec</span>&lt;<span class="dt">String</span>&gt; = env::args().collect();
      <span class="kw">let</span> program = args[<span class="dv">0</span>].clone();
  
      <span class="kw">let</span> <span class="kw">mut</span> opts = Options::new();
      opts.optflag(<span class="st">&quot;h&quot;</span>, <span class="st">&quot;help&quot;</span>, <span class="st">&quot;Show this usage message.&quot;</span>);
  
      <span class="kw">let</span> matches = <span class="kw">match</span> opts.parse(&amp;args[<span class="dv">1.</span>.]) {
          <span class="cn">Ok</span>(m)  =&gt; { m }
          <span class="cn">Err</span>(e) =&gt; { <span class="pp">panic!</span>(e.to_string()) }
      };
  
      <span class="kw">if</span> matches.opt_present(<span class="st">&quot;h&quot;</span>) {
          print_usage(&amp;program, opts);
          <span class="kw">return</span>;
      }
  
      <span class="kw">let</span> data_file = args[<span class="dv">1</span>].clone();
      <span class="kw">let</span> data_path = Path::new(&amp;data_file);
      <span class="kw">let</span> city = args[<span class="dv">2</span>].clone();
  
      <span class="kw">let</span> file = fs::File::open(data_path).unwrap();
      <span class="kw">let</span> <span class="kw">mut</span> rdr = csv::Reader::from_reader(file);
  
      <span class="kw">for</span> row <span class="kw">in</span> rdr.decode::&lt;Row&gt;() {
          <span class="kw">let</span> row = row.unwrap();
  
          <span class="kw">if</span> row.city == city {
              <span class="pp">println!</span>(<span class="st">&quot;{}, {}: {:?}&quot;</span>,
                  row.city, row.country,
                  row.population.expect(<span class="st">&quot;population count&quot;</span>));
          }
      }
  }</code></pre></div>
  <p>Let‚Äôs outline the errors. We can start with the obvious: the three places that <code>unwrap</code> is called:</p>
  <ol type="1">
  <li><a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>fs::File::open</code></a> can return an <a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>.</li>
  <li><a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a> decodes one record at a time, and <a href="http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">decoding a record</a> (look at the <code>Item</code> associated type on the <code>Iterator</code> impl) can produce a <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>.</li>
  <li>If <code>row.population</code> is <code>None</code>, then calling <code>expect</code> will panic.</li>
  </ol>
  <p>Are there any others? What if we can‚Äôt find a matching city? Tools like <code>grep</code> will return an error code, so we probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We‚Äôre going to explore two different ways to approach handling these errors.</p>
  <p>I‚Äôd like to start with <code>Box&lt;Error&gt;</code>. Later, we‚Äôll see how defining our own error type can be useful.</p>
  </section>
  <section id="error-handling-with-boxerror" class="level4">
  <h4>Error handling with <code>Box&lt;Error&gt;</code></h4>
  <p><code>Box&lt;Error&gt;</code> is nice because it <em>just works</em>. You don‚Äôt need to define your own error types and you don‚Äôt need any <code>From</code> implementations. The downside is that since <code>Box&lt;Error&gt;</code> is a trait object, it <em>erases the type</em>, which means the compiler can no longer reason about its underlying type.</p>
  <p><a href="#the-limits-of-combinators">Previously</a> we started refactoring our code by changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code>. In this case, <code>OurErrorType</code> is just <code>Box&lt;Error&gt;</code>. But what‚Äôs <code>T</code>? And can we add a return type to <code>main</code>?</p>
  <p>The answer to the second question is no, we can‚Äôt. That means we‚Äôll need to write a new function. But what is <code>T</code>? The simplest thing we can do is to return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code>. (Better code would return an iterator, but that is left as an exercise to the reader.)</p>
  <p>Let‚Äôs refactor our code into its own function, but keep the calls to <code>unwrap</code>. Note that we opt to handle the possibility of a missing population count by simply ignoring that row.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Row {
      <span class="co">// unchanged</span>
  }
  
  <span class="kw">struct</span> PopulationCount {
      city: <span class="dt">String</span>,
      country: <span class="dt">String</span>,
      <span class="co">// This is no longer an `Option` because values of this type are only</span>
      <span class="co">// constructed if they have a population count.</span>
      count: <span class="dt">u64</span>,
  }
  
  <span class="kw">fn</span> print_usage(program: &amp;<span class="dt">str</span>, opts: Options) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, opts.usage(&amp;<span class="pp">format!</span>(<span class="st">&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, progr
  ‚Ü≥ am)));
  }
  
  <span class="kw">fn</span> search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Vec</span>&lt;PopulationCount&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> found = <span class="pp">vec!</span>[];
      <span class="kw">let</span> file = fs::File::open(file_path).unwrap();
      <span class="kw">let</span> <span class="kw">mut</span> rdr = csv::Reader::from_reader(file);
      <span class="kw">for</span> row <span class="kw">in</span> rdr.decode::&lt;Row&gt;() {
          <span class="kw">let</span> row = row.unwrap();
          <span class="kw">match</span> row.population {
              <span class="cn">None</span> =&gt; { } <span class="co">// skip it</span>
              <span class="cn">Some</span>(count) =&gt; <span class="kw">if</span> row.city == city {
                  found.push(PopulationCount {
                      city: row.city,
                      country: row.country,
                      count: count,
                  });
              },
          }
      }
      found
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> args: <span class="dt">Vec</span>&lt;<span class="dt">String</span>&gt; = env::args().collect();
      <span class="kw">let</span> program = args[<span class="dv">0</span>].clone();
  
      <span class="kw">let</span> <span class="kw">mut</span> opts = Options::new();
      opts.optflag(<span class="st">&quot;h&quot;</span>, <span class="st">&quot;help&quot;</span>, <span class="st">&quot;Show this usage message.&quot;</span>);
  
      <span class="kw">let</span> matches = <span class="kw">match</span> opts.parse(&amp;args[<span class="dv">1.</span>.]) {
          <span class="cn">Ok</span>(m)  =&gt; { m }
          <span class="cn">Err</span>(e) =&gt; { <span class="pp">panic!</span>(e.to_string()) }
      };
      <span class="kw">if</span> matches.opt_present(<span class="st">&quot;h&quot;</span>) {
          print_usage(&amp;program, opts);
          <span class="kw">return</span>;
      }
  
      <span class="kw">let</span> data_file = args[<span class="dv">1</span>].clone();
      <span class="kw">let</span> data_path = Path::new(&amp;data_file);
      <span class="kw">let</span> city = args[<span class="dv">2</span>].clone();
      <span class="kw">for</span> pop <span class="kw">in</span> search(&amp;data_path, &amp;city) {
          <span class="pp">println!</span>(<span class="st">&quot;{}, {}: {:?}&quot;</span>, pop.city, pop.country, pop.count);
      }
  }</code></pre></div>
  <p>While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code>), we still should handle the absence of any search results.</p>
  <p>To convert this to proper error handling, we need to do the following:</p>
  <ol type="1">
  <li>Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;,    Box&lt;Error&gt;&gt;</code>.</li>
  <li>Use the <a href="#code-try-def"><code>try!</code> macro</a> so that errors are returned to the caller instead of panicking the program.</li>
  <li>Handle the error in <code>main</code>.</li>
  </ol>
  <p>Let‚Äôs try it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> search&lt;P: AsRef&lt;Path&gt;&gt;
           (file_path: P, city: &amp;<span class="dt">str</span>)
           -&gt; <span class="dt">Result</span>&lt;<span class="dt">Vec</span>&lt;PopulationCount&gt;, <span class="dt">Box</span>&lt;Error+<span class="bu">Send</span>+<span class="bu">Sync</span>&gt;&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> found = <span class="pp">vec!</span>[];
      <span class="kw">let</span> file = <span class="pp">try!</span>(fs::File::open(file_path));
      <span class="kw">let</span> <span class="kw">mut</span> rdr = csv::Reader::from_reader(file);
      <span class="kw">for</span> row <span class="kw">in</span> rdr.decode::&lt;Row&gt;() {
          <span class="kw">let</span> row = <span class="pp">try!</span>(row);
          <span class="kw">match</span> row.population {
              <span class="cn">None</span> =&gt; { } <span class="co">// skip it</span>
              <span class="cn">Some</span>(count) =&gt; <span class="kw">if</span> row.city == city {
                  found.push(PopulationCount {
                      city: row.city,
                      country: row.country,
                      count: count,
                  });
              },
          }
      }
      <span class="kw">if</span> found.is_empty() {
          <span class="cn">Err</span>(From::from(<span class="st">&quot;No matching cities with a population were found.&quot;</span>))
      } <span class="kw">else</span> {
          <span class="cn">Ok</span>(found)
      }
  }</code></pre></div>
  <p>Instead of <code>x.unwrap()</code>, we now have <code>try!(x)</code>. Since our function returns a <code>Result&lt;T, E&gt;</code>, the <code>try!</code> macro will return early from the function if an error occurs.</p>
  <p>There is one big gotcha in this code: we used <code>Box&lt;Error + Send + Sync&gt;</code> instead of <code>Box&lt;Error&gt;</code>. We did this so we could convert a plain string to an error type. We need these extra bounds so that we can use the <a href="http://doc.rust-lang.org/std/convert/trait.From.html">corresponding <code>From</code> impls</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// We are making use of this impl in the code above, since we call `From::from`</span>
  <span class="co">// on a `&amp;'static str`.</span>
  <span class="kw">impl</span>&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt; From&lt;&amp;<span class="ot">'b</span> <span class="dt">str</span>&gt; <span class="kw">for</span> <span class="dt">Box</span>&lt;Error + <span class="bu">Send</span> + <span class="bu">Sync</span> + <span class="ot">'a</span>&gt;
  
  <span class="co">// But this is also useful when you need to allocate a new string for an</span>
  <span class="co">// error message, usually with `format!`.</span>
  <span class="kw">impl</span> From&lt;<span class="dt">String</span>&gt; <span class="kw">for</span> <span class="dt">Box</span>&lt;Error + <span class="bu">Send</span> + <span class="bu">Sync</span>&gt;</code></pre></div>
  <p>Now that we‚Äôve seen how to do proper error handling with <code>Box&lt;Error&gt;</code>, let‚Äôs try a different approach with our own custom error type. But first, let‚Äôs take a quick break from error handling and add support for reading from <code>stdin</code>.</p>
  </section>
  <section id="reading-from-stdin" class="level4">
  <h4>Reading from stdin</h4>
  <p>In our program, we accept a single file for input and do one pass over the data. This means we probably should be able to accept input on stdin. But maybe we like the current format too‚Äîso let‚Äôs have both!</p>
  <p>Adding support for stdin is actually quite easy. There are only two things we have to do:</p>
  <ol type="1">
  <li>Tweak the program arguments so that a single parameter‚Äîthe city‚Äîcan be accepted while the population data is read from stdin.</li>
  <li>Modify the program so that an option <code>-f</code> can take the file, if it is not passed into stdin.</li>
  <li>Modify the <code>search</code> function to take an <em>optional</em> file path. When <code>None</code>, it should know to read from stdin.</li>
  </ol>
  <p>First, here‚Äôs the new usage:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_usage(program: &amp;<span class="dt">str</span>, opts: Options) {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, opts.usage(&amp;<span class="pp">format!</span>(<span class="st">&quot;Usage: {} [options] &lt;city&gt;&quot;</span>, program)));
  }</code></pre></div>
  <p>The next part is going to be only a little harder:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...
  <span class="kw">let</span> <span class="kw">mut</span> opts = Options::new();
  opts.optopt(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class="st">&quot;NAME&quot;</span>);
  opts.optflag(<span class="st">&quot;h&quot;</span>, <span class="st">&quot;help&quot;</span>, <span class="st">&quot;Show this usage message.&quot;</span>);
  ...
  <span class="kw">let</span> file = matches.opt_str(<span class="st">&quot;f&quot;</span>);
  <span class="kw">let</span> data_file = file.as_ref().map(Path::new);
  
  <span class="kw">let</span> city = <span class="kw">if</span> !matches.free.is_empty() {
      matches.free[<span class="dv">0</span>].clone()
  } <span class="kw">else</span> {
      print_usage(&amp;program, opts);
      <span class="kw">return</span>;
  };
  
  <span class="kw">for</span> pop <span class="kw">in</span> search(&amp;data_file, &amp;city) {
      <span class="pp">println!</span>(<span class="st">&quot;{}, {}: {:?}&quot;</span>, pop.city, pop.country, pop.count);
  }
  ...</code></pre></div>
  <p>In this peice of code, we take <code>file</code> (which has the type <code>Option&lt;String&gt;</code>), and convert it to a type that <code>search</code> can use, in this case, <code>&amp;Option&lt;AsRef&lt;Path&gt;&gt;</code>. Do do this, we take a reference of file, and map <code>Path::new</code> onto it. In this case, <code>as_ref()</code> converts the <code>Option&lt;String&gt;</code> into an <code>Option&lt;&amp;str&gt;</code>, and from there, we can execute <code>Path::new</code> to the content of the optional, and return the optional of the new value. Once we have that, it is a simple matter of getting the <code>city</code> argument and executing <code>search</code>.</p>
  <p>Modifying <code>search</code> is slightly trickier. The <code>csv</code> crate can build a parser out of <a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader">any type that implements <code>io::Read</code></a>. But how can we use the same code over both types? There‚Äôs actually a couple ways we could go about this. One way is to write <code>search</code> such that it is generic on some type parameter <code>R</code> that satisfies <code>io::Read</code>. Another way is to just use trait objects:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> search&lt;P: AsRef&lt;Path&gt;&gt;
           (file_path: &amp;<span class="dt">Option</span>&lt;P&gt;, city: &amp;<span class="dt">str</span>)
           -&gt; <span class="dt">Result</span>&lt;<span class="dt">Vec</span>&lt;PopulationCount&gt;, <span class="dt">Box</span>&lt;Error+<span class="bu">Send</span>+<span class="bu">Sync</span>&gt;&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> found = <span class="pp">vec!</span>[];
      <span class="kw">let</span> input: <span class="dt">Box</span>&lt;io::Read&gt; = <span class="kw">match</span> *file_path {
          <span class="cn">None</span> =&gt; <span class="dt">Box</span>::new(io::stdin()),
          <span class="cn">Some</span>(<span class="kw">ref</span> file_path) =&gt; <span class="dt">Box</span>::new(<span class="pp">try!</span>(fs::File::open(file_path))),
      };
      <span class="kw">let</span> <span class="kw">mut</span> rdr = csv::Reader::from_reader(input);
      <span class="co">// The rest remains unchanged!</span>
  }</code></pre></div>
  </section>
  <section id="error-handling-with-a-custom-type" class="level4">
  <h4>Error handling with a custom type</h4>
  <p>Previously, we learned how to <a href="#composing-custom-error-types">compose errors using a custom error type</a>. We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code> and <code>From</code>.</p>
  <p>Since we have three distinct errors (IO, CSV parsing and not found), let‚Äôs define an <code>enum</code> with three variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Csv(csv::Error),
      NotFound,
  }</code></pre></div>
  <p>And now for impls on <code>Display</code> and <code>Error</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> fmt::<span class="bu">Display</span> <span class="kw">for</span> CliError {
      <span class="kw">fn</span> fmt(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> fmt::Formatter) -&gt; fmt::<span class="dt">Result</span> {
          <span class="kw">match</span> *<span class="kw">self</span> {
              CliError::Io(<span class="kw">ref</span> err) =&gt; err.fmt(f),
              CliError::Csv(<span class="kw">ref</span> err) =&gt; err.fmt(f),
              CliError::NotFound =&gt; <span class="pp">write!</span>(f, <span class="st">&quot;No matching cities with a </span><span class="sc">\</span>
  <span class="st">                                             population were found.&quot;</span>),
          }
      }
  }
  
  <span class="kw">impl</span> Error <span class="kw">for</span> CliError {
      <span class="kw">fn</span> description(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="dt">str</span> {
          <span class="kw">match</span> *<span class="kw">self</span> {
              CliError::Io(<span class="kw">ref</span> err) =&gt; err.description(),
              CliError::Csv(<span class="kw">ref</span> err) =&gt; err.description(),
              CliError::NotFound =&gt; <span class="st">&quot;not found&quot;</span>,
          }
      }
  }</code></pre></div>
  <p>Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to provide a couple <code>From</code> impls. How do we know which impls to provide? Well, we‚Äôll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code>. Those are the only external errors, so we‚Äôll only need two <code>From</code> impls for now:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> From&lt;io::Error&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: io::Error) -&gt; CliError {
          CliError::Io(err)
      }
  }
  
  <span class="kw">impl</span> From&lt;csv::Error&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: csv::Error) -&gt; CliError {
          CliError::Csv(err)
      }
  }</code></pre></div>
  <p>The <code>From</code> impls are important because of how <a href="#code-try-def"><code>try!</code> is defined</a>. In particular, if an error occurs, <code>From::from</code> is called on the error, which in this case, will convert it to our own error type <code>CliError</code>.</p>
  <p>With the <code>From</code> impls done, we only need to make two small tweaks to our <code>search</code> function: the return type and the ‚Äúnot found‚Äù error. Here it is in full:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> search&lt;P: AsRef&lt;Path&gt;&gt;
           (file_path: &amp;<span class="dt">Option</span>&lt;P&gt;, city: &amp;<span class="dt">str</span>)
           -&gt; <span class="dt">Result</span>&lt;<span class="dt">Vec</span>&lt;PopulationCount&gt;, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> found = <span class="pp">vec!</span>[];
      <span class="kw">let</span> input: <span class="dt">Box</span>&lt;io::Read&gt; = <span class="kw">match</span> *file_path {
          <span class="cn">None</span> =&gt; <span class="dt">Box</span>::new(io::stdin()),
          <span class="cn">Some</span>(<span class="kw">ref</span> file_path) =&gt; <span class="dt">Box</span>::new(<span class="pp">try!</span>(fs::File::open(file_path))),
      };
      <span class="kw">let</span> <span class="kw">mut</span> rdr = csv::Reader::from_reader(input);
      <span class="kw">for</span> row <span class="kw">in</span> rdr.decode::&lt;Row&gt;() {
          <span class="kw">let</span> row = <span class="pp">try!</span>(row);
          <span class="kw">match</span> row.population {
              <span class="cn">None</span> =&gt; { } <span class="co">// skip it</span>
              <span class="cn">Some</span>(count) =&gt; <span class="kw">if</span> row.city == city {
                  found.push(PopulationCount {
                      city: row.city,
                      country: row.country,
                      count: count,
                  });
              },
          }
      }
      <span class="kw">if</span> found.is_empty() {
          <span class="cn">Err</span>(CliError::NotFound)
      } <span class="kw">else</span> {
          <span class="cn">Ok</span>(found)
      }
  }</code></pre></div>
  <p>No other changes are necessary.</p>
  </section>
  <section id="adding-functionality" class="level4">
  <h4>Adding functionality</h4>
  <p>Writing generic code is great, because generalizing stuff is cool, and it can then be useful later. But sometimes, the juice isn‚Äôt worth the squeeze. Look at what we just did in the previous step:</p>
  <ol type="1">
  <li>Defined a new error type.</li>
  <li>Added impls for <code>Error</code>, <code>Display</code> and two for <code>From</code>.</li>
  </ol>
  <p>The big downside here is that our program didn‚Äôt improve a whole lot. There is quite a bit of overhead to representing errors with <code>enum</code>s, especially in short programs like this.</p>
  <p><em>One</em> useful aspect of using a custom error type like we‚Äôve done here is that the <code>main</code> function can now choose to handle errors differently. Previously, with <code>Box&lt;Error&gt;</code>, it didn‚Äôt have much of a choice: just print the message. We‚Äôre still doing that here, but what if we wanted to, say, add a <code>--quiet</code> flag? The <code>--quiet</code> flag should silence any verbose output.</p>
  <p>Right now, if the program doesn‚Äôt find a match, it will output a message saying so. This can be a little clumsy, especially if you intend for the program to be used in shell scripts.</p>
  <p>So let‚Äôs start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Option variable. Once were done that, Getopts does the rest:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...
  <span class="kw">let</span> <span class="kw">mut</span> opts = Options::new();
  opts.optopt(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class="st">&quot;NAME&quot;</span>);
  opts.optflag(<span class="st">&quot;h&quot;</span>, <span class="st">&quot;help&quot;</span>, <span class="st">&quot;Show this usage message.&quot;</span>);
  opts.optflag(<span class="st">&quot;q&quot;</span>, <span class="st">&quot;quiet&quot;</span>, <span class="st">&quot;Silences errors and warnings.&quot;</span>);
  ...</code></pre></div>
  <p>Now we just need to implement our ‚Äúquiet‚Äù functionality. This requires us to tweak the case analysis in <code>main</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> search(&amp;args.arg_data_path, &amp;args.arg_city) {
      <span class="cn">Err</span>(CliError::NotFound) <span class="kw">if</span> args.flag_quiet =&gt; process::exit(<span class="dv">1</span>),
      <span class="cn">Err</span>(err) =&gt; <span class="pp">fatal!</span>(<span class="st">&quot;{}&quot;</span>, err),
      <span class="cn">Ok</span>(pops) =&gt; <span class="kw">for</span> pop <span class="kw">in</span> pops {
          <span class="pp">println!</span>(<span class="st">&quot;{}, {}: {:?}&quot;</span>, pop.city, pop.country, pop.count);
      }
  }</code></pre></div>
  <p>Certainly, we don‚Äôt want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case analysis to check if the error type is <code>NotFound</code> <em>and</em> if <code>--quiet</code> has been enabled. If the search failed, we still quit with an exit code (following <code>grep</code>‚Äôs convention).</p>
  <p>If we had stuck with <code>Box&lt;Error&gt;</code>, then it would be pretty tricky to implement the <code>--quiet</code> functionality.</p>
  <p>This pretty much sums up our case study. From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.</p>
  </section>
  </section>
  <section id="the-short-story" class="level3">
  <h3>The Short Story</h3>
  <p>Since this chapter is long, it is useful to have a quick summary for error handling in Rust. These are some good ‚Äúrules of thumb.‚Äù They are emphatically <em>not</em> commandments. There are probably good reasons to break every one of these heuristics!</p>
  <ul>
  <li>If you‚Äôre writing short example code that would be overburdened by error handling, it‚Äôs probably just fine to use <code>unwrap</code> (whether that‚Äôs <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>, <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> or preferably <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>). Consumers of your code should know to use proper error handling. (If they don‚Äôt, send them here!)</li>
  <li>If you‚Äôre writing a quick ‚Äòn‚Äô dirty program, don‚Äôt feel ashamed if you use <code>unwrap</code>. Be warned: if it winds up in someone else‚Äôs hands, don‚Äôt be surprised if they are agitated by poor error messages!</li>
  <li>If you‚Äôre writing a quick ‚Äòn‚Äô dirty program and feel ashamed about panicking anyway, then using either a <code>String</code> or a <code>Box&lt;Error + Send + Sync&gt;</code> for your error type (the <code>Box&lt;Error + Send + Sync&gt;</code> type is because of the <a href="http://doc.rust-lang.org/std/convert/trait.From.html">available <code>From</code> impls</a>).</li>
  <li>Otherwise, in a program, define your own error types with appropriate <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> impls to make the <a href="http://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a> macro more ergnomic.</li>
  <li>If you‚Äôre writing a library and your code can produce errors, define your own error type and implement the <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait. Where appropriate, implement <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> to make both your library code and the caller‚Äôs code easier to write. (Because of Rust‚Äôs coherence rules, callers will not be able to impl <code>From</code> on your error type, so your library should do it.)</li>
  <li>Learn the combinators defined on <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> and <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>. Using them exclusively can be a bit tiring at times, but I‚Äôve personally found a healthy mix of <code>try!</code> and combinators to be quite appealing. <code>and_then</code>, <code>map</code> and <code>unwrap_or</code> are my favorites.</li>
  </ul>
  </section>
  </section>
  <section id="sec--choosing-your-guarantees" class="level2">
  <h2>Choosing your Guarantees</h2>
  <p>One important feature of Rust is that it lets us control the costs and guarantees of a program.</p>
  <p>There are various ‚Äúwrapper type‚Äù abstractions in the Rust standard library which embody a multitude of tradeoffs between cost, ergonomics, and guarantees. Many let one choose between run time and compile time enforcement. This section will explain a few selected abstractions in detail.</p>
  <p>Before proceeding, it is highly recommended that one reads about <a href="#sec--ownership">ownership</a> and <a href="#sec--references-and-borrowing">borrowing</a> in Rust.</p>
  <section id="basic-pointer-types" class="level3">
  <h3>Basic pointer types</h3>
  <section id="boxt" class="level4">
  <h4><code>Box&lt;T&gt;</code></h4>
  <p><a href="http://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> is an ‚Äúowned‚Äù pointer, or a ‚Äúbox‚Äù. While it can hand out references to the contained data, it is the only owner of the data. In particular, consider the following:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dt">Box</span>::new(<span class="dv">1</span>);
  <span class="kw">let</span> y = x;
  <span class="co">// x no longer accessible here</span></code></pre></div>
  <p>Here, the box was <em>moved</em> into <code>y</code>. As <code>x</code> no longer owns it, the compiler will no longer allow the programmer to use <code>x</code> after this. A box can similarly be moved <em>out</em> of a function by returning it.</p>
  <p>When a box (that hasn‚Äôt been moved) goes out of scope, destructors are run. These destructors take care of deallocating the inner data.</p>
  <p>This is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be allowed to share references to this by the regular borrowing rules, checked at compile time.</p>
  </section>
  <section id="t-and-mut-t" class="level4">
  <h4><code>&amp;T</code> and <code>&amp;mut T</code></h4>
  <p>These are immutable and mutable references respectively. They follow the ‚Äúread-write lock‚Äù pattern, such that one may either have only one mutable reference to some data, or any number of immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at runtime. In most cases these two pointer types suffice for sharing cheap references between sections of code.</p>
  <p>These pointers cannot be copied in such a way that they outlive the lifetime associated with them.</p>
  </section>
  <section id="const-t-and-mut-t" class="level4">
  <h4><code>*const T</code> and <code>*mut T</code></h4>
  <p>These are C-like raw pointers with no lifetime or ownership attached to them. They just point to some location in memory with no other restrictions. The only guarantee that these provide is that they cannot be dereferenced except in code marked <code>unsafe</code>.</p>
  <p>These are useful when building safe, low cost abstractions like <code>Vec&lt;T&gt;</code>, but should be avoided in safe code.</p>
  </section>
  <section id="rct" class="level4">
  <h4><code>Rc&lt;T&gt;</code></h4>
  <p>This is the first wrapper we will cover that has a runtime cost.</p>
  <p><a href="http://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> is a reference counted pointer. In other words, this lets us have multiple ‚Äúowning‚Äù pointers to the same data, and the data will be dropped (destructors will be run) when all pointers are out of scope.</p>
  <p>Internally, it contains a shared ‚Äúreference count‚Äù (also called ‚Äúrefcount‚Äù), which is incremented each time the <code>Rc</code> is cloned, and decremented each time one of the <code>Rc</code>s goes out of scope. The main responsibility of <code>Rc&lt;T&gt;</code> is to ensure that destructors are called for shared data.</p>
  <p>The internal data here is immutable, and if a cycle of references is created, the data will be leaked. If we want data that doesn‚Äôt leak when there are cycles, we need a garbage collector.</p>
  <section id="guarantees" class="level6">
  <h6>Guarantees</h6>
  <p>The main guarantee provided here is that the data will not be destroyed until all references to it are out of scope.</p>
  <p>This should be used when we wish to dynamically allocate and share some data (read-only) between various portions of your program, where it is not certain which portion will finish using the pointer last. It‚Äôs a viable alternative to <code>&amp;T</code> when <code>&amp;T</code> is either impossible to statically check for correctness, or creates extremely unergonomic code where the programmer does not wish to spend the development cost of working with.</p>
  <p>This pointer is <em>not</em> thread safe, and Rust will not let it be sent or shared with other threads. This lets one avoid the cost of atomics in situations where they are unnecessary.</p>
  <p>There is a sister smart pointer to this one, <code>Weak&lt;T&gt;</code>. This is a non-owning, but also non-borrowed, smart pointer. It is also similar to <code>&amp;T</code>, but it is not restricted in lifetime‚Äîa <code>Weak&lt;T&gt;</code> can be held on to forever. However, it is possible that an attempt to access the inner data may fail and return <code>None</code>, since this can outlive the owned <code>Rc</code>s. This is useful for cyclic data structures and other things.</p>
  </section>
  <section id="cost" class="level6">
  <h6>Cost</h6>
  <p>As far as memory goes, <code>Rc&lt;T&gt;</code> is a single allocation, though it will allocate two extra words (i.e.¬†two <code>usize</code> values) as compared to a regular <code>Box&lt;T&gt;</code> (for ‚Äústrong‚Äù and ‚Äúweak‚Äù refcounts).</p>
  <p><code>Rc&lt;T&gt;</code> has the computational cost of incrementing/decrementing the refcount whenever it is cloned or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply increment the inner reference count and return a copy of the <code>Rc&lt;T&gt;</code>.</p>
  </section>
  </section>
  </section>
  <section id="cell-types" class="level3">
  <h3>Cell types</h3>
  <p><code>Cell</code>s provide interior mutability. In other words, they contain data which can be manipulated even if the type cannot be obtained in a mutable form (for example, when it is behind an <code>&amp;</code>-ptr or <code>Rc&lt;T&gt;</code>).</p>
  <p><a href="http://doc.rust-lang.org/std/cell/">The documentation for the <code>cell</code> module has a pretty good explanation for these</a>.</p>
  <p>These types are <em>generally</em> found in struct fields, but they may be found elsewhere too.</p>
  <section id="cellt" class="level4">
  <h4><code>Cell&lt;T&gt;</code></h4>
  <p><a href="http://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> is a type that provides zero-cost interior mutability, but only for <code>Copy</code> types. Since the compiler knows that all the data owned by the contained value is on the stack, there‚Äôs no worry of leaking any data behind references (or worse!) by simply replacing the data.</p>
  <p>It is still possible to violate your own invariants using this wrapper, so be careful when using it. If a field is wrapped in <code>Cell</code>, it‚Äôs a nice indicator that the chunk of data is mutable and may not stay the same between the time you first read it and when you intend to use it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::Cell;
  
  <span class="kw">let</span> x = Cell::new(<span class="dv">1</span>);
  <span class="kw">let</span> y = &amp;x;
  <span class="kw">let</span> z = &amp;x;
  x.set(<span class="dv">2</span>);
  y.set(<span class="dv">3</span>);
  z.set(<span class="dv">4</span>);
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x.get());</code></pre></div>
  <p>Note that here we were able to mutate the same value from various immutable references.</p>
  <p>This has the same runtime cost as the following:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">1</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
  <span class="kw">let</span> z = &amp;<span class="kw">mut</span> x;
  x = <span class="dv">2</span>;
  *y = <span class="dv">3</span>;
  *z = <span class="dv">4</span>;
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre></div>
  <p>but it has the added benefit of actually compiling successfully.</p>
  <section id="guarantees-1" class="level6">
  <h6>Guarantees</h6>
  <p>This relaxes the ‚Äúno aliasing with mutability‚Äù restriction in places where it‚Äôs unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your invariants depend on data stored within <code>Cell</code>, you should be careful.</p>
  <p>This is useful for mutating primitives and other <code>Copy</code> types when there is no easy way of doing it in line with the static rules of <code>&amp;</code> and <code>&amp;mut</code>.</p>
  <p><code>Cell</code> does not let you obtain interior references to the data, which makes it safe to freely mutate.</p>
  </section>
  <section id="cost-1" class="level6">
  <h6>Cost</h6>
  <p>There is no runtime cost to using <code>Cell&lt;T&gt;</code>, however if you are using it to wrap larger (<code>Copy</code>) structs, it might be worthwhile to instead wrap individual fields in <code>Cell&lt;T&gt;</code> since each write is otherwise a full copy of the struct.</p>
  </section>
  </section>
  <section id="refcellt" class="level4">
  <h4><code>RefCell&lt;T&gt;</code></h4>
  <p><a href="http://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> also provides interior mutability, but isn‚Äôt restricted to <code>Copy</code> types.</p>
  <p>Instead, it has a runtime cost. <code>RefCell&lt;T&gt;</code> enforces the read-write lock pattern at runtime (it‚Äôs like a single-threaded mutex), unlike <code>&amp;T</code>/<code>&amp;mut T</code> which do so at compile time. This is done by the <code>borrow()</code> and <code>borrow_mut()</code> functions, which modify an internal reference count and return smart pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when the smart pointers go out of scope. With this system, we can dynamically ensure that there are never any other borrows active when a mutable borrow is active. If the programmer attempts to make such a borrow, the thread will panic.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="pp">vec!</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]);
  {
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, *x.borrow())
  }
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> my_ref = x.borrow_mut();
      my_ref.push(<span class="dv">1</span>);
  }</code></pre></div>
  <p>Similar to <code>Cell</code>, this is mainly useful for situations where it‚Äôs hard or impossible to satisfy the borrow checker. Generally we know that such mutations won‚Äôt happen in a nested form, but it‚Äôs good to check.</p>
  <p>For large, complicated programs, it becomes useful to put some things in <code>RefCell</code>s to make things simpler. For example, a lot of the maps in <a href="http://doc.rust-lang.org/rustc/middle/ty/struct.ctxt.html">the <code>ctxt</code> struct</a> in the rust compiler internals are inside this wrapper. These are only modified once (during creation, which is not right after initialization) or a couple of times in well-separated places. However, since this struct is pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps impossible) and probably form a soup of <code>&amp;</code>-ptrs which would be hard to extend. On the other hand, the <code>RefCell</code> provides a cheap (not zero-cost) way of safely accessing these. In the future, if someone adds some code that attempts to modify the cell when it‚Äôs already borrowed, it will cause a (usually deterministic) panic which can be traced back to the offending borrow.</p>
  <p>Similarly, in Servo‚Äôs DOM there is a lot of mutation, most of which is local to a DOM type, but some of which crisscrosses the DOM and modifies various things. Using <code>RefCell</code> and <code>Cell</code> to guard all mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the places where mutation is <em>actually</em> happening.</p>
  <p>Note that <code>RefCell</code> should be avoided if a mostly simple solution is possible with <code>&amp;</code> pointers.</p>
  <section id="guarantees-2" class="level6">
  <h6>Guarantees</h6>
  <p><code>RefCell</code> relaxes the <em>static</em> restrictions preventing aliased mutation, and replaces them with <em>dynamic</em> ones. As such the guarantees have not changed.</p>
  </section>
  <section id="cost-2" class="level6">
  <h6>Cost</h6>
  <p><code>RefCell</code> does not allocate, but it contains an additional ‚Äúborrow state‚Äù indicator (one word in size) along with the data.</p>
  <p>At runtime each borrow causes a modification/check of the refcount.</p>
  </section>
  </section>
  </section>
  <section id="synchronous-types" class="level3">
  <h3>Synchronous types</h3>
  <p>Many of the types above cannot be used in a threadsafe manner. Particularly, <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, which both use non-atomic reference counts (<em>atomic</em> reference counts are those which can be incremented from multiple threads without causing a data race), cannot be used this way. This makes them cheaper to use, but we need thread safe versions of these too. They exist, in the form of <code>Arc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>RwLock&lt;T&gt;</code></p>
  <p>Note that the non-threadsafe types <em>cannot</em> be sent between threads, and this is checked at compile time.</p>
  <p>There are many useful wrappers for concurrent programming in the <a href="http://doc.rust-lang.org/std/sync/index.html">sync</a> module, but only the major ones will be covered below.</p>
  <section id="arct" class="level4">
  <h4><code>Arc&lt;T&gt;</code></h4>
  <p><a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> is just a version of <code>Rc&lt;T&gt;</code> that uses an atomic reference count (hence, ‚ÄúArc‚Äù). This can be sent freely between threads.</p>
  <p>C++‚Äôs <code>shared_ptr</code> is similar to <code>Arc</code>, however in the case of C++ the inner data is always mutable. For semantics similar to that from C++, we should use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, or <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (<code>UnsafeCell&lt;T&gt;</code> is a cell type that can be used to hold any data and has no runtime cost, but accessing it requires <code>unsafe</code> blocks). The last one should only be used if we are certain that the usage won‚Äôt cause any memory unsafety. Remember that writing to a struct is not an atomic operation, and many functions like <code>vec.push()</code> can reallocate internally and cause unsafe behavior, so even monotonicity may not be enough to justify <code>UnsafeCell</code>.</p>
  <section id="guarantees-3" class="level6">
  <h6>Guarantees</h6>
  <p>Like <code>Rc</code>, this provides the (thread safe) guarantee that the destructor for the internal data will be run when the last <code>Arc</code> goes out of scope (barring any cycles).</p>
  </section>
  <section id="cost-3" class="level6">
  <h6>Cost</h6>
  <p>This has the added cost of using atomics for changing the refcount (which will happen whenever it is cloned or goes out of scope). When sharing data from an <code>Arc</code> in a single thread, it is preferable to share <code>&amp;</code> pointers whenever possible.</p>
  </section>
  </section>
  <section id="mutext-and-rwlockt" class="level4">
  <h4><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></h4>
  <p><a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> and <a href="http://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> provide mutual-exclusion via RAII guards (guards are objects which maintain some state, like a lock, until their destructor is called). For both of these, the mutex is opaque until we call <code>lock()</code> on it, at which point the thread will block until a lock can be acquired, and then a guard will be returned. This guard can be used to access the inner data (mutably), and the lock will be released when the guard goes out of scope.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">{
      <span class="kw">let</span> guard = mutex.lock();
      <span class="co">// guard dereferences mutably to the inner type</span>
      *guard += <span class="dv">1</span>;
  } <span class="co">// lock released when destructor runs</span></code></pre></div>
  <p><code>RwLock</code> has the added benefit of being efficient for multiple reads. It is always safe to have multiple readers to shared data as long as there are no writers; and <code>RwLock</code> lets readers acquire a ‚Äúread lock‚Äù. Such locks can be acquired concurrently and are kept track of via a reference count. Writers must obtain a ‚Äúwrite lock‚Äù which can only be obtained when all readers have gone out of scope.</p>
  <section id="guarantees-4" class="level6">
  <h6>Guarantees</h6>
  <p>Both of these provide safe shared mutability across threads, however they are prone to deadlocks. Some level of additional protocol safety can be obtained via the type system.</p>
  </section>
  <section id="costs" class="level6">
  <h6>Costs</h6>
  <p>These use internal atomic-like types to maintain the locks, which are pretty costly (they can block all memory reads across processors till they‚Äôre done). Waiting on these locks can also be slow when there‚Äôs a lot of concurrent access happening.</p>
  </section>
  </section>
  </section>
  <section id="composition" class="level3">
  <h3>Composition</h3>
  <p>A common gripe when reading Rust code is with types like <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (or even more complicated compositions of such types). It‚Äôs not always clear what the composition does, or why the author chose one like this (and when one should be using such a composition in one‚Äôs own code)</p>
  <p>Usually, it‚Äôs a case of composing together the guarantees that you need, without paying for stuff that is unnecessary.</p>
  <p>For example, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is one such composition. <code>Rc&lt;T&gt;</code> itself can‚Äôt be dereferenced mutably; because <code>Rc&lt;T&gt;</code> provides sharing and shared mutability can lead to unsafe behavior, so we put <code>RefCell&lt;T&gt;</code> inside to get dynamically verified shared mutability. Now we have shared mutable data, but it‚Äôs shared in a way that there can only be one mutator (and no readers) or multiple readers.</p>
  <p>Now, we can take this a step further, and have <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> or <code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. These are both shareable, mutable vectors, but they‚Äôre not the same.</p>
  <p>With the former, the <code>RefCell&lt;T&gt;</code> is wrapping the <code>Vec&lt;T&gt;</code>, so the <code>Vec&lt;T&gt;</code> in its entirety is mutable. At the same time, there can only be one mutable borrow of the whole <code>Vec</code> at a given time. This means that your code cannot simultaneously work on different elements of the vector from different <code>Rc</code> handles. However, we are able to push and pop from the <code>Vec&lt;T&gt;</code> at will. This is similar to an <code>&amp;mut Vec&lt;T&gt;</code> with the borrow checking done at runtime.</p>
  <p>With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus, we can independently borrow separate elements, but we cannot push or pop from the vector. This is similar to an <code>&amp;mut [T]</code><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, but, again, the borrow checking is at runtime.</p>
  <p>In concurrent programs, we have a similar situation with <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, which provides shared mutability and ownership.</p>
  <p>When reading code that uses these, go in step by step and look at the guarantees/costs provided.</p>
  <p>When choosing a composed type, we must do the reverse; figure out which guarantees we want, and at which point of the composition we need them. For example, if there is a choice between <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> and <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, we should figure out the tradeoffs as done above and pick one.</p>
  </section>
  </section>
  <section id="sec--ffi" class="level2">
  <h2>FFI</h2>
  <section id="introduction-1" class="level3">
  <h3>Introduction</h3>
  <p>This guide will use the <a href="https://github.com/google/snappy">snappy</a> compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in <a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
  <p>The following is a minimal example of calling a foreign function which will compile if snappy is installed:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  <span class="kw">use</span> libc::<span class="dt">size_t</span>;
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;snappy&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
      <span class="kw">fn</span> snappy_max_compressed_length(source_length: <span class="dt">size_t</span>) -&gt; <span class="dt">size_t</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="kw">unsafe</span> { snappy_max_compressed_length(<span class="dv">100</span>) };
      <span class="pp">println!</span>(<span class="st">&quot;max compressed length of a 100 byte buffer: {}&quot;</span>, x);
  }</code></pre></div>
  <p>The <code>extern</code> block is a list of function signatures in a foreign library, in this case with the platform‚Äôs C ABI. The <code>#[link(...)]</code> attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.</p>
  <p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped with <code>unsafe {}</code> as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren‚Äôt thread-safe, and almost any function that takes a pointer argument isn‚Äôt valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust‚Äôs safe memory model.</p>
  <p>When declaring the argument types to a foreign function, the Rust compiler can not check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.</p>
  <p>The <code>extern</code> block can be extended to cover the entire snappy API:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  <span class="kw">use</span> libc::{<span class="dt">c_int</span>, <span class="dt">size_t</span>};
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;snappy&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
      <span class="kw">fn</span> snappy_compress(input: *<span class="kw">const</span> <span class="dt">u8</span>,
                         input_length: <span class="dt">size_t</span>,
                         compressed: *<span class="kw">mut</span> <span class="dt">u8</span>,
                         compressed_length: *<span class="kw">mut</span> <span class="dt">size_t</span>) -&gt; <span class="dt">c_int</span>;
      <span class="kw">fn</span> snappy_uncompress(compressed: *<span class="kw">const</span> <span class="dt">u8</span>,
                           compressed_length: <span class="dt">size_t</span>,
                           uncompressed: *<span class="kw">mut</span> <span class="dt">u8</span>,
                           uncompressed_length: *<span class="kw">mut</span> <span class="dt">size_t</span>) -&gt; <span class="dt">c_int</span>;
      <span class="kw">fn</span> snappy_max_compressed_length(source_length: <span class="dt">size_t</span>) -&gt; <span class="dt">size_t</span>;
      <span class="kw">fn</span> snappy_uncompressed_length(compressed: *<span class="kw">const</span> <span class="dt">u8</span>,
                                    compressed_length: <span class="dt">size_t</span>,
                                    result: *<span class="kw">mut</span> <span class="dt">size_t</span>) -&gt; <span class="dt">c_int</span>;
      <span class="kw">fn</span> snappy_validate_compressed_buffer(compressed: *<span class="kw">const</span> <span class="dt">u8</span>,
                                           compressed_length: <span class="dt">size_t</span>) -&gt; <span class="dt">c_int</span>;
  }</code></pre></div>
  </section>
  <section id="creating-a-safe-interface" class="level3">
  <h3>Creating a safe interface</h3>
  <p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.</p>
  <p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust vectors as pointers to memory. Rust‚Äôs vectors are guaranteed to be a contiguous block of memory. The length is number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> validate_compressed_buffer(src: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">bool</span> {
      <span class="kw">unsafe</span> {
          snappy_validate_compressed_buffer(src.as_ptr(), src.len() <span class="kw">as</span> <span class="dt">size_t</span>) == <span class="dv">0</span>
      }
  }</code></pre></div>
  <p>The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function signature.</p>
  <p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be allocated to hold the output too.</p>
  <p>The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the <code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> compress(src: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; {
      <span class="kw">unsafe</span> {
          <span class="kw">let</span> srclen = src.len() <span class="kw">as</span> <span class="dt">size_t</span>;
          <span class="kw">let</span> psrc = src.as_ptr();
  
          <span class="kw">let</span> <span class="kw">mut</span> dstlen = snappy_max_compressed_length(srclen);
          <span class="kw">let</span> <span class="kw">mut</span> dst = <span class="dt">Vec</span>::with_capacity(dstlen <span class="kw">as</span> <span class="dt">usize</span>);
          <span class="kw">let</span> pdst = dst.as_mut_ptr();
  
          snappy_compress(psrc, srclen, pdst, &amp;<span class="kw">mut</span> dstlen);
          dst.set_len(dstlen <span class="kw">as</span> <span class="dt">usize</span>);
          dst
      }
  }</code></pre></div>
  <p>Decompression is similar, because snappy stores the uncompressed size as part of the compression format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> uncompress(src: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">Option</span>&lt;<span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt;&gt; {
      <span class="kw">unsafe</span> {
          <span class="kw">let</span> srclen = src.len() <span class="kw">as</span> <span class="dt">size_t</span>;
          <span class="kw">let</span> psrc = src.as_ptr();
  
          <span class="kw">let</span> <span class="kw">mut</span> dstlen: <span class="dt">size_t</span> = <span class="dv">0</span>;
          snappy_uncompressed_length(psrc, srclen, &amp;<span class="kw">mut</span> dstlen);
  
          <span class="kw">let</span> <span class="kw">mut</span> dst = <span class="dt">Vec</span>::with_capacity(dstlen <span class="kw">as</span> <span class="dt">usize</span>);
          <span class="kw">let</span> pdst = dst.as_mut_ptr();
  
          <span class="kw">if</span> snappy_uncompress(psrc, srclen, pdst, &amp;<span class="kw">mut</span> dstlen) == <span class="dv">0</span> {
              dst.set_len(dstlen <span class="kw">as</span> <span class="dt">usize</span>);
              <span class="cn">Some</span>(dst)
          } <span class="kw">else</span> {
              <span class="cn">None</span> <span class="co">// SNAPPY_INVALID_INPUT</span>
          }
      }
  }</code></pre></div>
  <p>For reference, the examples used here are also available as a <a href="https://github.com/thestinger/rust-snappy">library on GitHub</a>.</p>
  </section>
  <section id="destructors" class="level3">
  <h3>Destructors</h3>
  <p>Foreign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust‚Äôs destructors to provide safety and guarantee the release of these resources (especially in the case of panic).</p>
  <p>For more about destructors, see the <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>.</p>
  </section>
  <section id="callbacks-from-c-code-to-rust-functions" class="level3">
  <h3>Callbacks from C code to Rust functions</h3>
  <p>Some external libraries require the usage of callbacks to report back their current state or intermediate data to the caller. It is possible to pass functions defined in Rust to an external library. The requirement for this is that the callback function is marked as <code>extern</code> with the correct calling convention to make it callable from C code.</p>
  <p>The callback function can then be sent through a registration call to the C library and afterwards be invoked from there.</p>
  <p>A basic example is:</p>
  <p>Rust code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">fn</span> callback(a: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;I'm called from C with value {0}&quot;</span>, a);
  }
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;extlib&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
     <span class="kw">fn</span> register_callback(cb: <span class="kw">extern</span> <span class="kw">fn</span>(<span class="dt">i32</span>)) -&gt; <span class="dt">i32</span>;
     <span class="kw">fn</span> trigger_callback();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">unsafe</span> {
          register_callback(callback);
          trigger_callback(); <span class="co">// Triggers the callback</span>
      }
  }</code></pre></div>
  <p>C code:</p>
  <div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*rust_callback)(<span class="dt">int32_t</span>);
  rust_callback cb;
  
  <span class="dt">int32_t</span> register_callback(rust_callback callback) {
      cb = callback;
      <span class="kw">return</span> <span class="dv">1</span>;
  }
  
  <span class="dt">void</span> trigger_callback() {
    cb(<span class="dv">7</span>); <span class="co">// Will call callback(7) in Rust</span>
  }</code></pre></div>
  <p>In this example Rust‚Äôs <code>main()</code> will call <code>trigger_callback()</code> in C, which would, in turn, call back to <code>callback()</code> in Rust.</p>
  <section id="targeting-callbacks-to-rust-objects" class="level4">
  <h4>Targeting callbacks to Rust objects</h4>
  <p>The former example showed how a global function can be called from C code. However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.</p>
  <p>This can be achieved by passing an raw pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.</p>
  <p>Rust code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span>
  <span class="kw">struct</span> RustObject {
      a: <span class="dt">i32</span>,
      <span class="co">// other members</span>
  }
  
  <span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="kw">fn</span> callback(target: *<span class="kw">mut</span> RustObject, a: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;I'm called from C with value {0}&quot;</span>, a);
      <span class="kw">unsafe</span> {
          <span class="co">// Update the value in RustObject with the value received from the callback</span>
          (*target).a = a;
      }
  }
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;extlib&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
     <span class="kw">fn</span> register_callback(target: *<span class="kw">mut</span> RustObject,
                          cb: <span class="kw">extern</span> <span class="kw">fn</span>(*<span class="kw">mut</span> RustObject, <span class="dt">i32</span>)) -&gt; <span class="dt">i32</span>;
     <span class="kw">fn</span> trigger_callback();
  }
  
  <span class="kw">fn</span> main() {
      <span class="co">// Create the object that will be referenced in the callback</span>
      <span class="kw">let</span> <span class="kw">mut</span> rust_object = <span class="dt">Box</span>::new(RustObject { a: <span class="dv">5</span> });
  
      <span class="kw">unsafe</span> {
          register_callback(&amp;<span class="kw">mut</span> *rust_object, callback);
          trigger_callback();
      }
  }</code></pre></div>
  <p>C code:</p>
  <div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*rust_callback)(<span class="dt">void</span>*, <span class="dt">int32_t</span>);
  <span class="dt">void</span>* cb_target;
  rust_callback cb;
  
  <span class="dt">int32_t</span> register_callback(<span class="dt">void</span>* callback_target, rust_callback callback) {
      cb_target = callback_target;
      cb = callback;
      <span class="kw">return</span> <span class="dv">1</span>;
  }
  
  <span class="dt">void</span> trigger_callback() {
    cb(cb_target, <span class="dv">7</span>); <span class="co">// Will call callback(&amp;rustObject, 7) in Rust</span>
  }</code></pre></div>
  </section>
  <section id="asynchronous-callbacks" class="level4">
  <h4>Asynchronous callbacks</h4>
  <p>In the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.</p>
  <p>Things get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in <code>std::sync::mpsc</code>) to forward data from the C thread that invoked the callback into a Rust thread.</p>
  <p>If an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed. This can be achieved by unregistering the callback in the object‚Äôs destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.</p>
  </section>
  </section>
  <section id="linking" class="level3">
  <h3>Linking</h3>
  <p>The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:</p>
  <ul>
  <li><code>#[link(name = &quot;foo&quot;)]</code></li>
  <li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
  </ul>
  <p>In both of these cases, <code>foo</code> is the name of the native library that we‚Äôre linking to, and in the second case <code>bar</code> is the type of native library that the compiler is linking to. There are currently three known types of native libraries:</p>
  <ul>
  <li>Dynamic - <code>#[link(name = &quot;readline&quot;)]</code></li>
  <li>Static - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
  <li>Frameworks - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
  </ul>
  <p>Note that frameworks are only available on OSX targets.</p>
  <p>The different <code>kind</code> values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary). Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.</p>
  <p>A few examples of how this model can be used are:</p>
  <ul>
  <li>A native build dependency. Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is just a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the Rust crate would declare a dependency via <code>#[link(name = &quot;foo&quot;, kind =   &quot;static&quot;)]</code>.</li>
  </ul>
  <p>Regardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.</p>
  <ul>
  <li>A normal dynamic dependency. Common system libraries (like <code>readline</code>) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.</li>
  </ul>
  <p>On OSX, frameworks behave with the same semantics as a dynamic library.</p>
  </section>
  <section id="unsafe-blocks" class="level3">
  <h3>Unsafe blocks</h3>
  <p>Some operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.</p>
  <p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">fn</span> kaboom(ptr: *<span class="kw">const</span> <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { *ptr }</code></pre></div>
  <p>This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
  </section>
  <section id="accessing-foreign-globals" class="level3">
  <h3>Accessing foreign globals</h3>
  <p>Foreign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in <code>extern</code> blocks with the <code>static</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;readline&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
      <span class="kw">static</span> rl_readline_version: libc::<span class="dt">c_int</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;You have readline version {} installed.&quot;</span>,
               rl_readline_version <span class="kw">as</span> <span class="dt">i32</span>);
  }</code></pre></div>
  <p>Alternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with <code>mut</code> so we can mutate them.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="kw">use</span> std::ffi::CString;
  <span class="kw">use</span> std::ptr;
  
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;readline&quot;</span><span class="at">)]</span>
  <span class="kw">extern</span> {
      <span class="kw">static</span> <span class="kw">mut</span> rl_prompt: *<span class="kw">const</span> libc::<span class="dt">c_char</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> prompt = CString::new(<span class="st">&quot;[my-awesome-shell] $&quot;</span>).unwrap();
      <span class="kw">unsafe</span> {
          rl_prompt = prompt.as_ptr();
  
          <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, rl_prompt);
  
          rl_prompt = ptr::null();
      }
  }</code></pre></div>
  <p>Note that all interaction with a <code>static mut</code> is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.</p>
  </section>
  <section id="foreign-calling-conventions" class="level3">
  <h3>Foreign calling conventions</h3>
  <p>Most foreign code exposes a C ABI, and Rust uses the platform‚Äôs C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="at">#[</span>cfg<span class="at">(</span>all<span class="at">(</span>target_os <span class="at">=</span> <span class="st">&quot;win32&quot;</span><span class="at">,</span> target_arch <span class="at">=</span> <span class="st">&quot;x86&quot;</span><span class="at">))]</span>
  <span class="at">#[</span>link<span class="at">(</span>name <span class="at">=</span> <span class="st">&quot;kernel32&quot;</span><span class="at">)]</span>
  <span class="at">#[</span>allow<span class="at">(</span>non_snake_case<span class="at">)]</span>
  <span class="kw">extern</span> <span class="st">&quot;stdcall&quot;</span> {
      <span class="kw">fn</span> SetEnvironmentVariableA(n: *<span class="kw">const</span> <span class="dt">u8</span>, v: *<span class="kw">const</span> <span class="dt">u8</span>) -&gt; libc::<span class="dt">c_int</span>;
  }</code></pre></div>
  <p>This applies to the entire <code>extern</code> block. The list of supported ABI constraints are:</p>
  <ul>
  <li><code>stdcall</code></li>
  <li><code>aapcs</code></li>
  <li><code>cdecl</code></li>
  <li><code>fastcall</code></li>
  <li><code>Rust</code></li>
  <li><code>rust-intrinsic</code></li>
  <li><code>system</code></li>
  <li><code>C</code></li>
  <li><code>win64</code></li>
  </ul>
  <p>Most of the abis in this list are self-explanatory, but the <code>system</code> abi may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target‚Äôs libraries. For example, on win32 with a x86 architecture, this means that the abi used would be <code>stdcall</code>. On x86_64, however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This means that in our previous example, we could have used <code>extern &quot;system&quot; { ... }</code> to define a block for all windows systems, not just x86 ones.</p>
  </section>
  <section id="interoperability-with-foreign-code" class="level3">
  <h3>Interoperability with foreign code</h3>
  <p>Rust guarantees that the layout of a <code>struct</code> is compatible with the platform‚Äôs representation in C only if the <code>#[repr(C)]</code> attribute is applied to it. <code>#[repr(C, packed)]</code> can be used to lay out struct members without padding. <code>#[repr(C)]</code> can also be applied to an enum.</p>
  <p>Rust‚Äôs owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (<code>*</code>) if that‚Äôs needed because the compiler can‚Äôt make as many assumptions about them.</p>
  <p>Vectors and strings share the same basic memory layout, and utilities are available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However, strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code> module.</p>
  <p>The <a href="https://crates.io/crates/libc"><code>libc</code> crate on crates.io</a> includes type aliases and function definitions for the C standard library in the <code>libc</code> module, and Rust links against <code>libc</code> and <code>libm</code> by default.</p>
  </section>
  <section id="the-nullable-pointer-optimization" class="level3">
  <h3>The ‚Äúnullable pointer optimization‚Äù</h3>
  <p>Certain types are defined to not be <code>null</code>. This includes references (<code>&amp;T</code>, <code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern &quot;abi&quot; fn()</code>). When interfacing with C, pointers that might be null are often used. As a special case, a generic <code>enum</code> that contains exactly two variants, one of which contains no data and the other containing a single field, is eligible for the ‚Äúnullable pointer optimization‚Äù. When such an enum is instantiated with one of the non-nullable types, it is represented as a single pointer, and the non-data variant is represented as the null pointer. So <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> is how one represents a nullable function pointer using the C ABI.</p>
  </section>
  <section id="calling-rust-code-from-c" class="level3">
  <h3>Calling Rust code from C</h3>
  <p>You may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>no_mangle<span class="at">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> hello_rust() -&gt; *<span class="kw">const</span> <span class="dt">u8</span> {
      <span class="st">&quot;Hello, world!</span><span class="sc">\</span><span class="er">0</span><span class="st">&quot;</span>.as_ptr()
  }</code></pre></div>
  <p>The <code>extern</code> makes this function adhere to the C calling convention, as discussed above in ‚Äú<a href="#foreign-calling-conventions">Foreign Calling Conventions</a>‚Äù. The <code>no_mangle</code> attribute turns off Rust‚Äôs name mangling, so that it is easier to link to.</p>
  </section>
  <section id="ffi-and-panics" class="level3">
  <h3>FFI and panics</h3>
  <p>It‚Äôs important to be mindful of <code>panic!</code>s when working with FFI. A <code>panic!</code> across an FFI boundary is undefined behavior. If you‚Äôre writing code that may panic, you should run it in another thread, so that the panic doesn‚Äôt bubble up to C:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="at">#[</span>no_mangle<span class="at">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> oh_no() -&gt; <span class="dt">i32</span> {
      <span class="kw">let</span> h = thread::spawn(|| {
          <span class="pp">panic!</span>(<span class="st">&quot;Oops!&quot;</span>);
      });
  
      <span class="kw">match</span> h.join() {
          <span class="cn">Ok</span>(_) =&gt; <span class="dv">1</span>,
          <span class="cn">Err</span>(_) =&gt; <span class="dv">0</span>,
      }
  }</code></pre></div>
  </section>
  <section id="representing-opaque-structs" class="level3">
  <h3>Representing opaque structs</h3>
  <p>Sometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants. The simplest way is to use a <code>void *</code> argument:</p>
  <div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> foo(<span class="dt">void</span> *arg);
  <span class="dt">void</span> bar(<span class="dt">void</span> *arg);</code></pre></div>
  <p>We can represent this in Rust with the <code>c_void</code> type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
      <span class="kw">pub</span> <span class="kw">fn</span> foo(arg: *<span class="kw">mut</span> libc::<span class="dt">c_void</span>);
      <span class="kw">pub</span> <span class="kw">fn</span> bar(arg: *<span class="kw">mut</span> libc::<span class="dt">c_void</span>);
  }</code></pre></div>
  <p>This is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a <code>struct</code>, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‚Äòopaque‚Äô. Here‚Äôs an example, in C:</p>
  <div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> Foo; <span class="co">/* Foo is a structure, but its contents are not part of the public interfa</span>
  <span class="co">‚Ü≥ ce */</span>
  <span class="kw">struct</span> Bar;
  <span class="dt">void</span> foo(<span class="kw">struct</span> Foo *arg);
  <span class="dt">void</span> bar(<span class="kw">struct</span> Bar *arg);</code></pre></div>
  <p>To do this in Rust, let‚Äôs create our own opaque types with <code>enum</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">enum</span> Foo {}
  <span class="kw">pub</span> <span class="kw">enum</span> Bar {}
  
  <span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
      <span class="kw">pub</span> <span class="kw">fn</span> foo(arg: *<span class="kw">mut</span> Foo);
      <span class="kw">pub</span> <span class="kw">fn</span> bar(arg: *<span class="kw">mut</span> Bar);
  }</code></pre></div>
  <p>By using an <code>enum</code> with no variants, we create an opaque type that we can‚Äôt instantiate, as it has no variants. But because our <code>Foo</code> and <code>Bar</code> types are different, we‚Äôll get type safety between the two of them, so we cannot accidentally pass a pointer to <code>Foo</code> to <code>bar()</code>.</p>
  </section>
  </section>
  <section id="sec--borrow-and-asref" class="level2">
  <h2>Borrow and AsRef</h2>
  <p>The <a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> and <a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> traits are very similar, but different. Here‚Äôs a quick refresher on what these two traits mean.</p>
  <section id="borrow" class="level3">
  <h3>Borrow</h3>
  <p>The <code>Borrow</code> trait is used when you‚Äôre writing a datastructure, and you want to use either an owned or borrowed type as synonymous for some purpose.</p>
  <p>For example, <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> has a <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>get</code> method</a> which uses <code>Borrow</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get&lt;Q: ?<span class="bu">Sized</span>&gt;(&amp;<span class="kw">self</span>, k: &amp;Q) -&gt; <span class="dt">Option</span>&lt;&amp;V&gt;
      <span class="kw">where</span> K: Borrow&lt;Q&gt;,
            Q: <span class="bu">Hash</span> + <span class="bu">Eq</span></code></pre></div>
  <p>This signature is pretty complicated. The <code>K</code> parameter is what we‚Äôre interested in here. It refers to a parameter of the <code>HashMap</code> itself:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HashMap&lt;K, V, S = RandomState&gt; {</code></pre></div>
  <p>The <code>K</code> parameter is the type of <em>key</em> the <code>HashMap</code> uses. So, looking at the signature of <code>get()</code> again, we can use <code>get()</code> when the key implements <code>Borrow&lt;Q&gt;</code>. That way, we can make a <code>HashMap</code> which uses <code>String</code> keys, but use <code>&amp;str</code>s when we‚Äôre searching:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::collections::HashMap;
  
  <span class="kw">let</span> <span class="kw">mut</span> map = HashMap::new();
  map.insert(<span class="st">&quot;Foo&quot;</span>.to_string(), <span class="dv">42</span>);
  
  <span class="pp">assert_eq!</span>(map.get(<span class="st">&quot;Foo&quot;</span>), <span class="cn">Some</span>(&amp;<span class="dv">42</span>));</code></pre></div>
  <p>This is because the standard library has <code>impl Borrow&lt;str&gt; for String</code>.</p>
  <p>For most types, when you want to take an owned or borrowed type, a <code>&amp;T</code> is enough. But one area where <code>Borrow</code> is effective is when there‚Äôs more than one kind of borrowed value. This is especially true of references and slices: you can have both an <code>&amp;T</code> or a <code>&amp;mut T</code>. If we wanted to accept both of these types, <code>Borrow</code> is up for it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::borrow::Borrow;
  <span class="kw">use</span> std::fmt::<span class="bu">Display</span>;
  
  <span class="kw">fn</span> foo&lt;T: Borrow&lt;<span class="dt">i32</span>&gt; + <span class="bu">Display</span>&gt;(a: T) {
      <span class="pp">println!</span>(<span class="st">&quot;a is borrowed: {}&quot;</span>, a);
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> i = <span class="dv">5</span>;
  
  foo(&amp;i);
  foo(&amp;<span class="kw">mut</span> i);</code></pre></div>
  <p>This will print out <code>a is borrowed: 5</code> twice.</p>
  </section>
  <section id="asref" class="level3">
  <h3>AsRef</h3>
  <p>The <code>AsRef</code> trait is a conversion trait. It‚Äôs used for converting some value to a reference in generic code. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="kw">fn</span> foo&lt;T: AsRef&lt;<span class="dt">str</span>&gt;&gt;(s: T) {
      <span class="kw">let</span> slice = s.as_ref();
  }</code></pre></div>
  </section>
  <section id="which-should-i-use" class="level3">
  <h3>Which should I use?</h3>
  <p>We can see how they‚Äôre kind of the same: they both deal with owned and borrowed versions of some type. However, they‚Äôre a bit different.</p>
  <p>Choose <code>Borrow</code> when you want to abstract over different kinds of borrowing, or when you‚Äôre building a datastructure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.</p>
  <p>Choose <code>AsRef</code> when you want to convert something to a reference directly, and you‚Äôre writing generic code.</p>
  </section>
  </section>
  <section id="sec--release-channels" class="level2">
  <h2>Release Channels</h2>
  <p>The Rust project uses a concept called ‚Äòrelease channels‚Äô to manage releases. It‚Äôs important to understand this process to choose which version of Rust your project should use.</p>
  <section id="overview" class="level3">
  <h3>Overview</h3>
  <p>There are three channels for Rust releases:</p>
  <ul>
  <li>Nightly</li>
  <li>Beta</li>
  <li>Stable</li>
  </ul>
  <p>New nightly releases are created once a day. Every six weeks, the latest nightly release is promoted to ‚ÄòBeta‚Äô. At that point, it will only receive patches to fix serious errors. Six weeks later, the beta is promoted to ‚ÄòStable‚Äô, and becomes the next release of <code>1.x</code>.</p>
  <p>This process happens in parallel. So every six weeks, on the same day, nightly goes to beta, beta goes to stable. When <code>1.x</code> is released, at the same time, <code>1.(x + 1)-beta</code> is released, and the nightly becomes the first version of <code>1.(x + 2)-nightly</code>.</p>
  </section>
  <section id="choosing-a-version" class="level3">
  <h3>Choosing a version</h3>
  <p>Generally speaking, unless you have a specific reason, you should be using the stable release channel. These releases are intended for a general audience.</p>
  <p>However, depending on your interest in Rust, you may choose to use nightly instead. The basic tradeoff is this: in the nightly channel, you can use unstable, new Rust features. However, unstable features are subject to change, and so any new nightly release may break your code. If you use the stable release, you cannot use experimental features, but the next release of Rust will not cause significant issues through breaking changes.</p>
  </section>
  <section id="helping-the-ecosystem-through-ci" class="level3">
  <h3>Helping the ecosystem through CI</h3>
  <p>What about beta? We encourage all Rust users who use the stable release channel to also test against the beta channel in their continuous integration systems. This will help alert the team in case there‚Äôs an accidental regression.</p>
  <p>Additionally, testing against nightly can catch regressions even sooner, and so if you don‚Äôt mind a third build, we‚Äôd appreciate testing against all channels.</p>
  <p>As an example, many Rust programmers use <a href="https://travis-ci.org/">Travis</a> to test their crates, which is free for open source projects. Travis <a href="http://docs.travis-ci.com/user/languages/rust/">supports Rust directly</a>, and you can use a <code>.travis.yml</code> file like this to test on all channels:</p>
  <div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">language:</span> rust
  <span class="fu">rust:</span>
    <span class="kw">-</span> nightly
    <span class="kw">-</span> beta
    <span class="kw">-</span> stable
  
  <span class="fu">matrix:</span>
    <span class="fu">allow_failures:</span>
      <span class="kw">-</span> <span class="fu">rust:</span> nightly</code></pre></div>
  <p>With this configuration, Travis will test all three channels, but if something breaks on nightly, it won‚Äôt fail your build. A similar configuration is recommended for any CI system, check the documentation of the one you‚Äôre using for more details.</p>
  </section>
  </section>
  </section>
  <section id="sec--syntax-and-semantics" class="level1">
  <h1>Syntax and Semantics</h1>
  <p>This section breaks Rust down into small chunks, one for each concept.</p>
  <p>If you‚Äôd like to learn Rust from the bottom up, reading this in order is a great way to do that.</p>
  <p>These sections also form a reference for each concept, so if you‚Äôre reading another tutorial and find something confusing, you can find it explained somewhere in here.</p>
  <section id="sec--variable-bindings" class="level2">
  <h2>Variable Bindings</h2>
  <p>Virtually every non-‚ÄòHello World‚Äô Rust program uses <em>variable bindings</em>. They look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
  }</code></pre></div>
  <p>Putting <code>fn main() {</code> in each example is a bit tedious, so we‚Äôll leave that out in the future. If you‚Äôre following along, make sure to edit your <code>main()</code> function, rather than leaving it off. Otherwise, you‚Äôll get an error.</p>
  <p>In many languages, this is called a <em>variable</em>, but Rust‚Äôs variable bindings have a few tricks up their sleeves. For example the left-hand side of a <code>let</code> expression is a ‚Äò<a href="#sec--patterns">pattern</a>‚Äô, not just a variable name. This means we can do things like:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y) = (<span class="dv">1</span>, <span class="dv">2</span>);</code></pre></div>
  <p>After this expression is evaluated, <code>x</code> will be one, and <code>y</code> will be two. Patterns are really powerful, and have <a href="#sec--patterns">their own section</a> in the book. We don‚Äôt need those features for now, so we‚Äôll just keep this in the back of our minds as we go forward.</p>
  <p>Rust is a statically typed language, which means that we specify our types up front, and they‚Äôre checked at compile time. So why does our first example compile? Well, Rust has this thing called ‚Äòtype inference‚Äô. If it can figure out what the type of something is, Rust doesn‚Äôt require you to actually type it out.</p>
  <p>We can add the type if we want to, though. Types come after a colon (<code>:</code>):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>If I asked you to read this out loud to the rest of the class, you‚Äôd say ‚Äú<code>x</code> is a binding with the type <code>i32</code> and the value <code>five</code>.‚Äù</p>
  <p>In this case we chose to represent <code>x</code> as a 32-bit signed integer. Rust has many different primitive integer types. They begin with <code>i</code> for signed integers and <code>u</code> for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 bits.</p>
  <p>In future examples, we may annotate the type in a comment. The examples will look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// x: i32</span>
  }</code></pre></div>
  <p>Note the similarities between this annotation and the syntax you use with <code>let</code>. Including these kinds of comments is not idiomatic Rust, but we‚Äôll occasionally include them to help you understand what the types that Rust infers are.</p>
  <p>By default, bindings are <em>immutable</em>. This code will not compile:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">10</span>;</code></pre></div>
  <p>It will give you this error:</p>
  <pre class="text"><code>error: re-assignment of immutable variable `x`
       x = 10;
       ^~~~~~~</code></pre>
  <p>If you want a binding to be mutable, you can use <code>mut</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  x = <span class="dv">10</span>;</code></pre></div>
  <p>There is no single reason that bindings are immutable by default, but we can think about it through one of Rust‚Äôs primary focuses: safety. If you forget to say <code>mut</code>, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you <em>did</em> intend mutation, then the solution is quite easy: add <code>mut</code>.</p>
  <p>There are other good reasons to avoid mutable state when possible, but they‚Äôre out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it‚Äôs not verboten.</p>
  <p>Let‚Äôs get back to bindings. Rust variable bindings have one more aspect that differs from other languages: bindings are required to be initialized with a value before you‚Äôre allowed to use them.</p>
  <p>Let‚Äôs try it out. Change your <code>src/main.rs</code> file to look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="dt">i32</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello world!&quot;</span>);
  }</code></pre></div>
  <p>You can use <code>cargo build</code> on the command line to build it. You‚Äôll get a warning, but it will still print ‚ÄúHello, world!‚Äù:</p>
  <pre class="text"><code>   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
  src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
     on by default
  src/main.rs:2     let x: i32;
                        ^</code></pre>
  <p>Rust warns us that we never use the variable binding, but since we never use it, no harm, no foul. Things change if we try to actually use this <code>x</code>, however. Let‚Äôs do that. Change your program to look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="dt">i32</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;The value of x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>And try to build it. You‚Äôll get an error:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/you/projects/hello_world)
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:39: 4:40 error: use of possibly uninitialized variable: <span class="kw">`x`</span>
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>     println!(<span class="st">&quot;The value of x is: {}&quot;</span>, x);
                                                      ^
  <span class="kw">note</span>: in expansion of format_args!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:2:23: 2:77 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 3:2 note: in expansion of println!
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:5: 4:42 note: expansion site
  <span class="kw">error</span>: aborting due to previous error
  <span class="kw">Could</span> not compile <span class="kw">`hello_world`</span>.</code></pre></div>
  <p>Rust will not let us use a value that has not been initialized. Next, let‚Äôs talk about this stuff we‚Äôve added to <code>println!</code>.</p>
  <p>If you include two curly braces (<code>{}</code>, some call them moustaches‚Ä¶) in your string to print, Rust will interpret this as a request to interpolate some sort of value. <em>String interpolation</em> is a computer science term that means ‚Äústick in the middle of a string.‚Äù We add a comma, and then <code>x</code>, to indicate that we want <code>x</code> to be the value we‚Äôre interpolating. The comma is used to separate arguments we pass to functions and macros, if you‚Äôre passing more than one.</p>
  <p>When you just use the curly braces, Rust will attempt to display the value in a meaningful way by checking out its type. If you want to specify the format in a more detailed manner, there are a <a href="http://doc.rust-lang.org/std/fmt/index.html">wide number of options available</a>. For now, we‚Äôll just stick to the default: integers aren‚Äôt very complicated to print.</p>
  </section>
  <section id="sec--functions" class="level2">
  <h2>Functions</h2>
  <p>Every Rust program has at least one function, the <code>main</code> function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  }</code></pre></div>
  <p>This is the simplest possible function declaration. As we mentioned before, <code>fn</code> says ‚Äòthis is a function‚Äô, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body. Here‚Äôs a function named <code>foo</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
  }</code></pre></div>
  <p>So, what about taking arguments? Here‚Äôs a function that prints a number:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_number(x: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>Here‚Äôs a complete program that uses <code>print_number</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_number(<span class="dv">5</span>);
  }
  
  <span class="kw">fn</span> print_number(x: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, x);
  }</code></pre></div>
  <p>As you can see, function arguments work very similar to <code>let</code> declarations: you add a type to the argument name, after a colon.</p>
  <p>Here‚Äôs a complete program that adds two numbers together and prints them:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_sum(<span class="dv">5</span>, <span class="dv">6</span>);
  }
  
  <span class="kw">fn</span> print_sum(x: <span class="dt">i32</span>, y: <span class="dt">i32</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;sum is: {}&quot;</span>, x + y);
  }</code></pre></div>
  <p>You separate arguments with a comma, both when you call the function, as well as when you declare it.</p>
  <p>Unlike <code>let</code>, you <em>must</em> declare the types of function arguments. This does not work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_sum(x, y) {
      <span class="pp">println!</span>(<span class="st">&quot;sum is: {}&quot;</span>, x + y);
  }</code></pre></div>
  <p>You get this error:</p>
  <pre class="text"><code>expected one of `!`, `:`, or `@`, found `)`
  fn print_number(x, y) {</code></pre>
  <p>This is a deliberate design decision. While full-program inference is possible, languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice. We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.</p>
  <p>What about returning a value? Here‚Äôs a function that adds one to an integer:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Rust functions return exactly one value, and you declare the type after an ‚Äòarrow‚Äô, which is a dash (<code>-</code>) followed by a greater-than sign (<code>&gt;</code>). The last line of a function determines what it returns. You‚Äôll note the lack of a semicolon here. If we added it in:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>;
  }</code></pre></div>
  <p>We would get an error:</p>
  <pre class="text"><code>error: not all control paths return a value
  fn add_one(x: i32) -&gt; i32 {
       x + 1;
  }
  
  help: consider removing this semicolon:
       x + 1;
            ^</code></pre>
  <p>This reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other ‚Äòcurly brace and semicolon‚Äô-based languages. These two things are related.</p>
  <section id="expressions-vs.statements" class="level4">
  <h4>Expressions vs.¬†Statements</h4>
  <p>Rust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.</p>
  <p>So what‚Äôs the difference? Expressions return a value, and statements do not. That‚Äôs why we end up with ‚Äònot all control paths return a value‚Äô here: the statement <code>x + 1;</code> doesn‚Äôt return a value. There are two kinds of statements in Rust: ‚Äòdeclaration statements‚Äô and ‚Äòexpression statements‚Äô. Everything else is an expression. Let‚Äôs talk about declaration statements first.</p>
  <p>In some languages, variable bindings can be written as expressions, not just statements. Like Ruby:</p>
  <div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x = y = <span class="dv">5</span></code></pre></div>
  <p>In Rust, however, using <code>let</code> to introduce a binding is <em>not</em> an expression. The following will produce a compile-time error:</p>
  <pre class="ignore"><code>let x = (let y = 5); // expected identifier, found keyword `let`</code></pre>
  <p>The compiler is telling us here that it was expecting to see the beginning of an expression, and a <code>let</code> can only begin a statement, not an expression.</p>
  <p>Note that assigning to an already-bound variable (e.g. <code>y = 5</code>) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. <code>5</code> in the previous example), in Rust the value of an assignment is an empty tuple <code>()</code> because the assigned value can have <a href="#sec--ownership">just one owner</a>, and any other returned value would be too surprising:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">5</span>;
  
  <span class="kw">let</span> x = (y = <span class="dv">6</span>);  <span class="co">// x has the value `()`, not `6`</span></code></pre></div>
  <p>The second kind of statement in Rust is the <em>expression statement</em>. Its purpose is to turn any expression into a statement. In practical terms, Rust‚Äôs grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.</p>
  <p>What is this exception that makes us say ‚Äúalmost‚Äù? You saw it already, in this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Our function claims to return an <code>i32</code>, but with a semicolon, it would return <code>()</code> instead. Rust realizes this probably isn‚Äôt what we want, and suggests removing the semicolon in the error we saw before.</p>
  </section>
  <section id="early-returns-1" class="level4">
  <h4>Early returns</h4>
  <p>But what about early returns? Rust does have a keyword for that, <code>return</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      <span class="kw">return</span> x;
  
      <span class="co">// we never run this code!</span>
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>Using a <code>return</code> as the last line of a function works, but is considered poor style:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      <span class="kw">return</span> x + <span class="dv">1</span>;
  }</code></pre></div>
  <p>The previous definition without <code>return</code> may look a bit strange if you haven‚Äôt worked in an expression-based language before, but it becomes intuitive over time.</p>
  </section>
  <section id="diverging-functions" class="level4">
  <h4>Diverging functions</h4>
  <p>Rust has some special syntax for ‚Äòdiverging functions‚Äô, which are functions that do not return:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> diverges() -&gt; ! {
      <span class="pp">panic!</span>(<span class="st">&quot;This function never returns!&quot;</span>);
  }</code></pre></div>
  <p><code>panic!</code> is a macro, similar to <code>println!()</code> that we‚Äôve already seen. Unlike <code>println!()</code>, <code>panic!()</code> causes the current thread of execution to crash with the given message. Because this function will cause a crash, it will never return, and so it has the type ‚Äò<code>!</code>‚Äô, which is read ‚Äòdiverges‚Äô.</p>
  <p>If you add a main function that calls <code>diverges()</code> and run it, you‚Äôll get some output that looks like this:</p>
  <pre class="text"><code>thread ‚Äò&lt;main&gt;‚Äô panicked at ‚ÄòThis function never returns!‚Äô, hello.rs:2</code></pre>
  <p>If you want more information, you can get a backtrace by setting the <code>RUST_BACKTRACE</code> environment variable:</p>
  <pre class="text"><code>$ RUST_BACKTRACE=1 ./diverges
  thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
  stack backtrace:
     1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
     2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
     3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
     4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
     5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
     6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
     7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
     8:     0x7f402773d1d8 - __rust_try
     9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
    10:     0x7f4027738a19 - main
    11:     0x7f402694ab44 - __libc_start_main
    12:     0x7f40277386c8 - &lt;unknown&gt;
    13:                0x0 - &lt;unknown&gt;</code></pre>
  <p><code>RUST_BACKTRACE</code> also works with Cargo‚Äôs <code>run</code> command:</p>
  <pre class="text"><code>$ RUST_BACKTRACE=1 cargo run
       Running `target/debug/diverges`
  thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
  stack backtrace:
     1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
     2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
     3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
     4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
     5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
     6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
     7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
     8:     0x7f402773d1d8 - __rust_try
     9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
    10:     0x7f4027738a19 - main
    11:     0x7f402694ab44 - __libc_start_main
    12:     0x7f40277386c8 - &lt;unknown&gt;
    13:                0x0 - &lt;unknown&gt;</code></pre>
  <p>A diverging function can be used as any type:</p>
  <pre class="should_panic"><code># fn diverges() -&gt; ! {
  #    panic!(&quot;This function never returns!&quot;);
  # }
  let x: i32 = diverges();
  let x: String = diverges();</code></pre>
  </section>
  <section id="function-pointers" class="level4">
  <h4>Function pointers</h4>
  <p>We can also create variable bindings which point to functions:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> f: <span class="kw">fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>;</code></pre></div>
  <p><code>f</code> is a variable binding which points to a function that takes an <code>i32</code> as an argument and returns an <code>i32</code>. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> plus_one(i: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      i + <span class="dv">1</span>
  }
  
  <span class="co">// without type inference</span>
  <span class="kw">let</span> f: <span class="kw">fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> = plus_one;
  
  <span class="co">// with type inference</span>
  <span class="kw">let</span> f = plus_one;</code></pre></div>
  <p>We can then use <code>f</code> to call the function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> six = f(<span class="dv">5</span>);</code></pre></div>
  </section>
  </section>
  <section id="sec--primitive-types" class="level2">
  <h2>Primitive Types</h2>
  <p>The Rust language has a number of types that are considered ‚Äòprimitive‚Äô. This means that they‚Äôre built-in to the language. Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.</p>
  <section id="booleans" class="level3">
  <h3>Booleans</h3>
  <p>Rust has a built in boolean type, named <code>bool</code>. It has two values, <code>true</code> and <code>false</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="cn">true</span>;
  
  <span class="kw">let</span> y: <span class="dt">bool</span> = <span class="cn">false</span>;</code></pre></div>
  <p>A common use of booleans is in <a href="#sec--if"><code>if</code> conditionals</a>.</p>
  <p>You can find more documentation for <code>bool</code>s <a href="http://doc.rust-lang.org/std/primitive.bool.html">in the standard library documentation</a>.</p>
  </section>
  <section id="char" class="level3">
  <h3><code>char</code></h3>
  <p>The <code>char</code> type represents a single Unicode scalar value. You can create <code>char</code>s with a single tick: (<code>'</code>)</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'x'</span>;
  <span class="kw">let</span> two_hearts = <span class="ch">'üíï'</span>;</code></pre></div>
  <p>Unlike some other languages, this means that Rust‚Äôs <code>char</code> is not a single byte, but four.</p>
  <p>You can find more documentation for <code>char</code>s <a href="http://doc.rust-lang.org/std/primitive.char.html">in the standard library documentation</a>.</p>
  </section>
  <section id="numeric-types" class="level3">
  <h3>Numeric types</h3>
  <p>Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.</p>
  <p>These types consist of two parts: the category, and the size. For example, <code>u16</code> is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.</p>
  <p>If a number literal has nothing to cause its type to be inferred, it defaults:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">42</span>; <span class="co">// x has type i32</span>
  
  <span class="kw">let</span> y = <span class="dv">1.0</span>; <span class="co">// y has type f64</span></code></pre></div>
  <p>Here‚Äôs a list of the different numeric types, with links to their documentation in the standard library:</p>
  <ul>
  <li><a href="http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
  </ul>
  <p>Let‚Äôs go over them by category:</p>
  <section id="signed-and-unsigned" class="level4">
  <h4>Signed and Unsigned</h4>
  <p>Integer types come in two varieties: signed and unsigned. To understand the difference, let‚Äôs consider a number with four bits of size. A signed, four-bit number would let you store numbers from <code>-8</code> to <code>+7</code>. Signed numbers use ‚Äútwo‚Äôs complement representation‚Äù. An unsigned four bit number, since it does not need to store negatives, can store values from <code>0</code> to <code>+15</code>.</p>
  <p>Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code>. The <code>i</code> is for ‚Äòinteger‚Äô. So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an eight-bit signed number.</p>
  </section>
  <section id="fixed-size-types" class="level4">
  <h4>Fixed size types</h4>
  <p>Fixed size types have a specific number of bits in their representation. Valid bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer, and <code>i64</code> is a signed, 64-bit integer.</p>
  </section>
  <section id="variable-sized-types" class="level4">
  <h4>Variable sized types</h4>
  <p>Rust also provides types whose size depends on the size of a pointer of the underlying machine. These types have ‚Äòsize‚Äô as the category, and come in signed and unsigned varieties. This makes for two types: <code>isize</code> and <code>usize</code>.</p>
  </section>
  <section id="floating-point-types" class="level4">
  <h4>Floating-point types</h4>
  <p>Rust also has two floating point types: <code>f32</code> and <code>f64</code>. These correspond to IEEE-754 single and double precision numbers.</p>
  </section>
  </section>
  <section id="arrays" class="level3">
  <h3>Arrays</h3>
  <p>Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the <em>array</em>, a fixed-size list of elements of the same type. By default, arrays are immutable.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// a: [i32; 3]</span>
  <span class="kw">let</span> <span class="kw">mut</span> m = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// m: [i32; 3]</span></code></pre></div>
  <p>Arrays have type <code>[T; N]</code>. We‚Äôll talk about this <code>T</code> notation <a href="#sec--generics">in the generics section</a>. The <code>N</code> is a compile-time constant, for the length of the array.</p>
  <p>There‚Äôs a shorthand for initializing each element of an array to the same value. In this example, each element of <code>a</code> will be initialized to <code>0</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>; <span class="dv">20</span>]; <span class="co">// a: [i32; 20]</span></code></pre></div>
  <p>You can get the number of elements in an array <code>a</code> with <code>a.len()</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="pp">println!</span>(<span class="st">&quot;a has {} elements&quot;</span>, a.len());</code></pre></div>
  <p>You can access a particular element of an array with <em>subscript notation</em>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> names = [<span class="st">&quot;Graydon&quot;</span>, <span class="st">&quot;Brian&quot;</span>, <span class="st">&quot;Niko&quot;</span>]; <span class="co">// names: [&amp;str; 3]</span>
  
  <span class="pp">println!</span>(<span class="st">&quot;The second name is: {}&quot;</span>, names[<span class="dv">1</span>]);</code></pre></div>
  <p>Subscripts start at zero, like in most programming languages, so the first name is <code>names[0]</code> and the second name is <code>names[1]</code>. The above example prints <code>The second name is: Brian</code>. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.</p>
  <p>You can find more documentation for <code>array</code>s <a href="http://doc.rust-lang.org/std/primitive.array.html">in the standard library documentation</a>.</p>
  </section>
  <section id="slices" class="level3">
  <h3>Slices</h3>
  <p>A ‚Äòslice‚Äô is a reference to (or ‚Äúview‚Äù into) another data structure. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference just one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable. Slices have a length, can be mutable or not, and in many ways behave like arrays:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
  <span class="kw">let</span> middle = &amp;a[<span class="dv">1.</span>.<span class="dv">4</span>]; <span class="co">// A slice of a: just the elements 1, 2, and 3</span>
  <span class="kw">let</span> complete = &amp;a[..]; <span class="co">// A slice containing all of the elements in a</span></code></pre></div>
  <p>Slices have type <code>&amp;[T]</code>. We‚Äôll talk about that <code>T</code> when we cover <a href="#sec--generics">generics</a>.</p>
  <p>You can find more documentation for slices <a href="http://doc.rust-lang.org/std/primitive.slice.html">in the standard library documentation</a>.</p>
  </section>
  <section id="str" class="level3">
  <h3><code>str</code></h3>
  <p>Rust‚Äôs <code>str</code> type is the most primitive string type. As an <a href="#sec--unsized-types">unsized type</a>, it‚Äôs not very useful by itself, but becomes useful when placed behind a reference, like <a href="#sec--strings"><code>&amp;str</code></a>. As such, we‚Äôll just leave it at that.</p>
  <p>You can find more documentation for <code>str</code> <a href="http://doc.rust-lang.org/std/primitive.str.html">in the standard library documentation</a>.</p>
  </section>
  <section id="tuples" class="level3">
  <h3>Tuples</h3>
  <p>A tuple is an ordered list of fixed size. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>);</code></pre></div>
  <p>The parentheses and commas form this two-length tuple. Here‚Äôs the same code, but with the type annotated:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: (<span class="dt">i32</span>, &amp;<span class="dt">str</span>) = (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>);</code></pre></div>
  <p>As you can see, the type of a tuple looks just like the tuple, but with each position having a type name rather than the value. Careful readers will also note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple. In systems programming languages, strings are a bit more complex than in other languages. For now, just read <code>&amp;str</code> as a <em>string slice</em>, and we‚Äôll learn more soon.</p>
  <p>You can assign one tuple into another, if they have the same contained types and <a href="#arity">arity</a>. Tuples have the same arity when they have the same length.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = (<span class="dv">1</span>, <span class="dv">2</span>); <span class="co">// x: (i32, i32)</span>
  <span class="kw">let</span> y = (<span class="dv">2</span>, <span class="dv">3</span>); <span class="co">// y: (i32, i32)</span>
  
  x = y;</code></pre></div>
  <p>You can access the fields in a tuple through a <em>destructuring let</em>. Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y, z) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x);</code></pre></div>
  <p>Remember <a href="#sec--variable-bindings">before</a> when I said the left-hand side of a <code>let</code> statement was more powerful than just assigning a binding? Here we are. We can put a pattern on the left-hand side of the <code>let</code>, and if it matches up to the right-hand side, we can assign multiple bindings at once. In this case, <code>let</code> ‚Äúdestructures‚Äù or ‚Äúbreaks up‚Äù the tuple, and assigns the bits to three bindings.</p>
  <p>This pattern is very powerful, and we‚Äôll see it repeated more later.</p>
  <p>You can disambiguate a single-element tuple from a value in parentheses with a comma:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">0</span>,); <span class="co">// single-element tuple</span>
  (<span class="dv">0</span>); <span class="co">// zero in parentheses</span></code></pre></div>
  <section id="tuple-indexing" class="level4">
  <h4>Tuple Indexing</h4>
  <p>You can also access fields of a tuple with indexing syntax:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> tuple = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="kw">let</span> x = tuple.<span class="dv">0</span>;
  <span class="kw">let</span> y = tuple.<span class="dv">1</span>;
  <span class="kw">let</span> z = tuple.<span class="dv">2</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x);</code></pre></div>
  <p>Like array indexing, it starts at zero, but unlike array indexing, it uses a <code>.</code>, rather than <code>[]</code>s.</p>
  <p>You can find more documentation for tuples <a href="http://doc.rust-lang.org/std/primitive.tuple.html">in the standard library documentation</a>.</p>
  </section>
  </section>
  <section id="functions" class="level3">
  <h3>Functions</h3>
  <p>Functions also have a type! They look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { x }
  
  <span class="kw">let</span> x: <span class="kw">fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> = foo;</code></pre></div>
  <p>In this case, <code>x</code> is a ‚Äòfunction pointer‚Äô to a function that takes an <code>i32</code> and returns an <code>i32</code>.</p>
  </section>
  </section>
  <section id="sec--comments" class="level2">
  <h2>Comments</h2>
  <p>Now that we have some functions, it‚Äôs a good idea to learn about comments. Comments are notes that you leave to other programmers to help explain things about your code. The compiler mostly ignores them.</p>
  <p>Rust has two kinds of comments that you should care about: <em>line comments</em> and <em>doc comments</em>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Line comments are anything after ‚Äò//‚Äô and extend to the end of the line.</span>
  
  <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// this is also a line comment.</span>
  
  <span class="co">// If you have a long explanation for something, you can put line comments next</span>
  <span class="co">// to each other. Put a space between the // and your comment so that it‚Äôs</span>
  <span class="co">// more readable.</span></code></pre></div>
  <p>The other kind of comment is a doc comment. Doc comments use <code>///</code> instead of <code>//</code>, and support Markdown notation inside:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Adds one to the number given.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let five = 5;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(6, add_one(5));</span>
  <span class="co">/// # fn add_one(x: i32) -&gt; i32 {</span>
  <span class="co">/// #     x + 1</span>
  <span class="co">/// # }</span>
  <span class="co">/// ```</span>
  <span class="kw">fn</span> add_one(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre></div>
  <p>There is another style of doc comment, <code>//!</code>, to comment containing items (e.g.¬†crates, modules or functions), instead of the items following it. Commonly used inside crates root (lib.rs) or modules root (mod.rs):</p>
  <pre><code>//! # The Rust Standard Library
  //!
  //! The Rust Standard Library provides the essential runtime
  //! functionality for building portable Rust software.</code></pre>
  <p>When writing doc comments, providing some examples of usage is very, very helpful. You‚Äôll notice we‚Äôve used a new macro here: <code>assert_eq!</code>. This compares two values, and <code>panic!</code>s if they‚Äôre not equal to each other. It‚Äôs very helpful in documentation. There‚Äôs another macro, <code>assert!</code>, which <code>panic!</code>s if the value passed to it is <code>false</code>.</p>
  <p>You can use the <a href="#sec--documentation"><code>rustdoc</code></a> tool to generate HTML documentation from these doc comments, and also to run the code examples as tests!</p>
  </section>
  <section id="sec--if" class="level2">
  <h2>if</h2>
  <p>Rust‚Äôs take on <code>if</code> is not particularly complex, but it‚Äôs much more like the <code>if</code> you‚Äôll find in a dynamically typed language than in a more traditional systems language. So let‚Äôs talk about it, to make sure you grasp the nuances.</p>
  <p><code>if</code> is a specific form of a more general concept, the ‚Äòbranch‚Äô. The name comes from a branch in a tree: a decision point, where depending on a choice, multiple paths can be taken.</p>
  <p>In the case of <code>if</code>, there is one choice that leads down two paths:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  }</code></pre></div>
  <p>If we changed the value of <code>x</code> to something else, this line would not print. More specifically, if the expression after the <code>if</code> evaluates to <code>true</code>, then the block is executed. If it‚Äôs <code>false</code>, then it is not.</p>
  <p>If you want something to happen in the <code>false</code> case, use an <code>else</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is not five :(&quot;</span>);
  }</code></pre></div>
  <p>If there is more than one case, use an <code>else if</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is five!&quot;</span>);
  } <span class="kw">else</span> <span class="kw">if</span> x == <span class="dv">6</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is six!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="pp">println!</span>(<span class="st">&quot;x is not five or six :(&quot;</span>);
  }</code></pre></div>
  <p>This is all pretty standard. However, you can also do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="dv">10</span>
  } <span class="kw">else</span> {
      <span class="dv">15</span>
  }; <span class="co">// y: i32</span></code></pre></div>
  <p>Which we can (and probably should) write like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> { <span class="dv">10</span> } <span class="kw">else</span> { <span class="dv">15</span> }; <span class="co">// y: i32</span></code></pre></div>
  <p>This works because <code>if</code> is an expression. The value of the expression is the value of the last expression in whichever branch was chosen. An <code>if</code> without an <code>else</code> always results in <code>()</code> as the value.</p>
  </section>
  <section id="sec--loops" class="level2">
  <h2>Loops</h2>
  <p>Rust currently provides three approaches to performing some kind of iterative activity. They are: <code>loop</code>, <code>while</code> and <code>for</code>. Each approach has its own set of uses.</p>
  <section id="loop" class="level4">
  <h4>loop</h4>
  <p>The infinite <code>loop</code> is the simplest form of loop available in Rust. Using the keyword <code>loop</code>, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust‚Äôs infinite <code>loop</code>s look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
      <span class="pp">println!</span>(<span class="st">&quot;Loop forever!&quot;</span>);
  }</code></pre></div>
  </section>
  <section id="while" class="level4">
  <h4>while</h4>
  <p>Rust also has a <code>while</code> loop. It looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="cn">false</span>; <span class="co">// mut done: bool</span>
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="cn">true</span>;
      }
  }</code></pre></div>
  <p><code>while</code> loops are the correct choice when you‚Äôre not sure how many times you need to loop.</p>
  <p>If you need an infinite loop, you may be tempted to write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="cn">true</span> {</code></pre></div>
  <p>However, <code>loop</code> is far better suited to handle this case:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {</code></pre></div>
  <p>Rust‚Äôs control-flow analysis treats this construct differently than a <code>while true</code>, since we know that it will always loop. In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer <code>loop</code> when you plan to loop infinitely.</p>
  </section>
  <section id="for" class="level4">
  <h4>for</h4>
  <p>The <code>for</code> loop is used to loop a particular number of times. Rust‚Äôs <code>for</code> loops work a bit differently than in other systems languages, however. Rust‚Äôs <code>for</code> loop doesn‚Äôt look like this ‚ÄúC-style‚Äù <code>for</code> loop:</p>
  <div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">for</span> (x = <span class="dv">0</span>; x &lt; <span class="dv">10</span>; x++) {
      printf( <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, x );
  }</code></pre></div>
  <p>Instead, it looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// x: i32</span>
  }</code></pre></div>
  <p>In slightly more abstract terms,</p>
  <pre class="ignore"><code>for var in expression {
      code
  }</code></pre>
  <p>The expression is an <a href="#sec--iterators">iterator</a>. The iterator gives back a series of elements. Each element is one iteration of the loop. That value is then bound to the name <code>var</code>, which is valid for the loop body. Once the body is over, the next value is fetched from the iterator, and we loop another time. When there are no more values, the <code>for</code> loop is over.</p>
  <p>In our example, <code>0..10</code> is an expression that takes a start and an end position, and gives an iterator over those values. The upper bound is exclusive, though, so our loop will print <code>0</code> through <code>9</code>, not <code>10</code>.</p>
  <p>Rust does not have the ‚ÄúC-style‚Äù <code>for</code> loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.</p>
  <section id="enumerate" class="level5">
  <h5>Enumerate</h5>
  <p>When you need to keep track of how many times you already looped, you can use the <code>.enumerate()</code> function.</p>
  <section id="on-ranges" class="level6">
  <h6>On ranges:</h6>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> (i,j) <span class="kw">in</span> (<span class="dv">5.</span>.<span class="dv">10</span>).enumerate() {
      <span class="pp">println!</span>(<span class="st">&quot;i = {} and j = {}&quot;</span>, i, j);
  }</code></pre></div>
  <p>Outputs:</p>
  <pre class="text"><code>i = 0 and j = 5
  i = 1 and j = 6
  i = 2 and j = 7
  i = 3 and j = 8
  i = 4 and j = 9</code></pre>
  <p>Don‚Äôt forget to add the parentheses around the range.</p>
  </section>
  <section id="on-iterators" class="level6">
  <h6>On iterators:</h6>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> (linenumber, line) <span class="kw">in</span> lines.enumerate() {
      <span class="pp">println!</span>(<span class="st">&quot;{}: {}&quot;</span>, linenumber, line);
  }</code></pre></div>
  <p>Outputs:</p>
  <pre class="text"><code>0: Content of line one
  1: Content of line two
  2: Content of line three
  3: Content of line four</code></pre>
  </section>
  </section>
  </section>
  <section id="ending-iteration-early" class="level4">
  <h4>Ending iteration early</h4>
  <p>Let‚Äôs take a look at that <code>while</code> loop we had earlier:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="cn">false</span>;
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="cn">true</span>;
      }
  }</code></pre></div>
  <p>We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code>, to know when we should exit out of the loop. Rust has two keywords to help us with modifying iteration: <code>break</code> and <code>continue</code>.</p>
  <p>In this case, we can write the loop in a better way with <code>break</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">loop</span> {
      x += x - <span class="dv">3</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> { <span class="kw">break</span>; }
  }</code></pre></div>
  <p>We now loop forever with <code>loop</code> and use <code>break</code> to break out early. Issuing an explicit <code>return</code> statement will also serve to terminate the loop early.</p>
  <p><code>continue</code> is similar, but instead of ending the loop, goes to the next iteration. This will only print the odd numbers:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span>; }
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  </section>
  <section id="loop-labels" class="level4">
  <h4>Loop labels</h4>
  <p>You may also encounter situations where you have nested loops and need to specify which one your <code>break</code> or <code>continue</code> statement is for. Like most other languages, by default a <code>break</code> or <code>continue</code> will apply to innermost loop. In a situation where you would like to a <code>break</code> or <code>continue</code> for one of the outer loops, you can use labels to specify which loop the <code>break</code> or <code>continue</code> statement applies to. This will only print when both <code>x</code> and <code>y</code> are odd:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">'outer</span>: <span class="kw">for</span> x <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="ot">'inner</span>: <span class="kw">for</span> y <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span> <span class="ot">'outer</span>; } <span class="co">// continues the loop over x</span>
          <span class="kw">if</span> y % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span> <span class="ot">'inner</span>; } <span class="co">// continues the loop over y</span>
          <span class="pp">println!</span>(<span class="st">&quot;x: {}, y: {}&quot;</span>, x, y);
      }
  }</code></pre></div>
  </section>
  </section>
  <section id="sec--ownership" class="level2">
  <h2>Ownership</h2>
  <p>This guide is one of three presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <ul>
  <li>ownership, which you‚Äôre reading now</li>
  <li><a href="#sec--references-and-borrowing">borrowing</a>, and their associated feature ‚Äòreferences‚Äô</li>
  <li><a href="#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing</li>
  </ul>
  <p>These three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.</p>
  <section id="meta" class="level3">
  <h3>Meta</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let‚Äôs learn about ownership.</p>
  </section>
  <section id="ownership" class="level3">
  <h3>Ownership</h3>
  <p><a href="#sec--variable-bindings">Variable bindings</a> have a property in Rust: they ‚Äòhave ownership‚Äô of what they‚Äôre bound to. This means that when a binding goes out of scope, Rust will free the bound resources. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  }</code></pre></div>
  <p>When <code>v</code> comes into scope, a new <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is created. In this case, the vector also allocates space on <a href="#sec--the-stack-and-the-heap">the heap</a>, for the three elements. When <code>v</code> goes out of scope at the end of <code>foo()</code>, Rust will clean up everything related to the vector, even the heap-allocated memory. This happens deterministically, at the end of the scope.</p>
  </section>
  <section id="move-semantics" class="level3">
  <h3>Move semantics</h3>
  <p>There‚Äôs some more subtlety here, though: Rust ensures that there is <em>exactly one</em> binding to any given resource. For example, if we have a vector, we can assign it to another binding:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre></div>
  <p>But, if we try to use <code>v</code> afterwards, we get an error:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;
  
  <span class="pp">println!</span>(<span class="st">&quot;v[0] is: {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre></div>
  <p>It looks like this:</p>
  <pre class="text"><code>error: use of moved value: `v`
  println!(&quot;v[0] is: {}&quot;, v[0]);
                          ^</code></pre>
  <p>A similar thing happens if we define a function which takes ownership, and try to use something after we‚Äôve passed it as an argument:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
      <span class="co">// what happens here isn‚Äôt important.</span>
  }
  
  <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  take(v);
  
  <span class="pp">println!</span>(<span class="st">&quot;v[0] is: {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre></div>
  <p>Same error: ‚Äòuse of moved value‚Äô. When we transfer ownership to something else, we say that we‚Äôve ‚Äòmoved‚Äô the thing we refer to. You don‚Äôt need some sort of special annotation here, it‚Äôs the default thing that Rust does.</p>
  <section id="the-details" class="level4">
  <h4>The details</h4>
  <p>The reason that we cannot use a binding after we‚Äôve moved it is subtle, but important. When we write code like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre></div>
  <p>The first line allocates memory for the vector object, <code>v</code>, and for the data it contains. The vector object is stored on the <a href="#sec--the-stack-and-the-heap">stack</a> and contains a pointer to the content (<code>[1, 2, 3]</code>) stored on the <a href="#sec--the-stack-and-the-heap">heap</a>. When we move <code>v</code> to <code>v2</code>, it creates a copy of that pointer, for <code>v2</code>. Which means that there would be two pointers to the content of the vector on the heap. It would violate Rust‚Äôs safety guarantees by introducing a data race. Therefore, Rust forbids using <code>v</code> after we‚Äôve done the move.</p>
  <p>It‚Äôs also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances. So it may not be as inefficient as it initially seems.</p>
  </section>
  <section id="copy-types" class="level4">
  <h4><code>Copy</code> types</h4>
  <p>We‚Äôve established that when ownership is transferred to another binding, you cannot use the original binding. However, there‚Äôs a <a href="#sec--traits">trait</a> that changes this behavior, and it‚Äôs called <code>Copy</code>. We haven‚Äôt discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="dv">1</span>;
  
  <span class="kw">let</span> v2 = v;
  
  <span class="pp">println!</span>(<span class="st">&quot;v is: {}&quot;</span>, v);</code></pre></div>
  <p>In this case, <code>v</code> is an <code>i32</code>, which implements the <code>Copy</code> trait. This means that, just like a move, when we assign <code>v</code> to <code>v2</code>, a copy of the data is made. But, unlike a move, we can still use <code>v</code> afterward. This is because an <code>i32</code> has no pointers to data somewhere else, copying it is a full copy.</p>
  <p>All primitive types implement the <code>Copy</code> trait and their ownership is therefore not moved like one would assume, following the ¬¥ownership rules¬¥. To give an example, the two following snippets of code only compile because the <code>i32</code> and <code>bool</code> types implement the <code>Copy</code> trait.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> a = <span class="dv">5</span>;
  
      <span class="kw">let</span> _y = double(a);
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, a);
  }
  
  <span class="kw">fn</span> double(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      x * <span class="dv">2</span>
  }</code></pre></div>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> a = <span class="cn">true</span>;
  
      <span class="kw">let</span> _y = change_truth(a);
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, a);
  }
  
  <span class="kw">fn</span> change_truth(x: <span class="dt">bool</span>) -&gt; <span class="dt">bool</span> {
      !x
  }</code></pre></div>
  <p>If we would have used types that do not implement the <code>Copy</code> trait, we would have gotten a compile error because we tried to use a moved value.</p>
  <pre class="text"><code>error: use of moved value: `a`
  println!(&quot;{}&quot;, a);
                 ^</code></pre>
  <p>We will discuss how to make your own types <code>Copy</code> in the <a href="#sec--traits">traits</a> section.</p>
  </section>
  </section>
  <section id="more-than-ownership" class="level3">
  <h3>More than ownership</h3>
  <p>Of course, if we had to hand ownership back with every function we wrote:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; {
      <span class="co">// do stuff with v</span>
  
      <span class="co">// hand back ownership</span>
      v
  }</code></pre></div>
  <p>This would get very tedious. It gets worse the more things we want to take ownership of:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">i32</span>) {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// hand back ownership, and the result of our function</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre></div>
  <p>Ugh! The return type, return line, and calling the function gets way more complicated.</p>
  <p>Luckily, Rust offers a feature, borrowing, which helps us solve this problem. It‚Äôs the topic of the next section!</p>
  </section>
  </section>
  <section id="sec--references-and-borrowing" class="level2">
  <h2>References and Borrowing</h2>
  <p>This guide is one of three presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <ul>
  <li><a href="#sec--ownership">ownership</a>, the key concept</li>
  <li>borrowing, which you‚Äôre reading now</li>
  <li><a href="#sec--lifetimes">lifetimes</a>, an advanced concept of borrowing</li>
  </ul>
  <p>These three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.</p>
  <section id="meta-1" class="level3">
  <h3>Meta</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero cost abstraction. All of the analysis we‚Äôll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let‚Äôs learn about borrowing.</p>
  </section>
  <section id="borrowing" class="level3">
  <h3>Borrowing</h3>
  <p>At the end of the <a href="#sec--ownership">ownership</a> section, we had a nasty function that looked like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, <span class="dt">i32</span>) {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// hand back ownership, and the result of our function</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre></div>
  <p>This is not idiomatic Rust, however, as it doesn‚Äôt take advantage of borrowing. Here‚Äôs the first step:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// return the answer</span>
      <span class="dv">42</span>
  }
  
  <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> answer = foo(&amp;v1, &amp;v2);
  
  <span class="co">// we can use v1 and v2 here!</span></code></pre></div>
  <p>Instead of taking <code>Vec&lt;i32&gt;</code>s as our arguments, we take a reference: <code>&amp;Vec&lt;i32&gt;</code>. And instead of passing <code>v1</code> and <code>v2</code> directly, we pass <code>&amp;v1</code> and <code>&amp;v2</code>. We call the <code>&amp;T</code> type a ‚Äòreference‚Äô, and rather than owning the resource, it borrows ownership. A binding that borrows something does not deallocate the resource when it goes out of scope. This means that after the call to <code>foo()</code>, we can use our original bindings again.</p>
  <p>References are immutable, just like bindings. This means that inside of <code>foo()</code>, the vectors can‚Äôt be changed at all:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
       v.push(<span class="dv">5</span>);
  }
  
  <span class="kw">let</span> v = <span class="pp">vec!</span>[];
  
  foo(&amp;v);</code></pre></div>
  <p>errors with:</p>
  <pre class="text"><code>error: cannot borrow immutable borrowed content `*v` as mutable
  v.push(5);
  ^</code></pre>
  <p>Pushing a value mutates the vector, and so we aren‚Äôt allowed to do it.</p>
  </section>
  <section id="mut-references" class="level3">
  <h3>&amp;mut references</h3>
  <p>There‚Äôs a second kind of reference: <code>&amp;mut T</code>. A ‚Äòmutable reference‚Äô allows you to mutate the resource you‚Äôre borrowing. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  {
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
      *y += <span class="dv">1</span>;
  }
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre></div>
  <p>This will print <code>6</code>. We make <code>y</code> a mutable reference to <code>x</code>, then add one to the thing <code>y</code> points at. You‚Äôll notice that <code>x</code> had to be marked <code>mut</code> as well, if it wasn‚Äôt, we couldn‚Äôt take a mutable borrow to an immutable value.</p>
  <p>You‚Äôll also notice we added an asterisk (<code>*</code>) in front of <code>y</code>, making it <code>*y</code>, this is because <code>y</code> is an <code>&amp;mut</code> reference. You‚Äôll also need to use them for accessing the contents of a reference as well.</p>
  <p>Otherwise, <code>&amp;mut</code> references are just like references. There <em>is</em> a large difference between the two, and how they interact, though. You can tell something is fishy in the above example, because we need that extra scope, with the <code>{</code> and <code>}</code>. If we remove them, we get an error:</p>
  <pre class="text"><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^
  note: previous borrow of `x` occurs here; the mutable borrow prevents
  subsequent moves, borrows, or modification of `x` until the borrow ends
          let y = &amp;mut x;
                       ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>As it turns out, there are rules.</p>
  </section>
  <section id="the-rules" class="level3">
  <h3>The Rules</h3>
  <p>Here‚Äôs the rules about borrowing in Rust:</p>
  <p>First, any borrow must last for a scope no greater than that of the owner. Second, you may have one or the other of these two kinds of borrows, but not both at the same time:</p>
  <ul>
  <li>one or more references (<code>&amp;T</code>) to a resource,</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
  </ul>
  <p>You may notice that this is very similar, though not exactly the same as, to the definition of a data race:</p>
  <blockquote>
  <p>There is a ‚Äòdata race‚Äô when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized.</p>
  </blockquote>
  <p>With references, you may have as many as you‚Äôd like, since none of them are writing. If you are writing, you need two or more pointers to the same memory, and you can only have one <code>&amp;mut</code> at a time. This is how Rust prevents data races at compile time: we‚Äôll get errors if we break the rules.</p>
  <p>With this in mind, let‚Äôs consider our example again.</p>
  <section id="thinking-in-scopes" class="level4">
  <h4>Thinking in scopes</h4>
  <p>Here‚Äôs the code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
  
  *y += <span class="dv">1</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre></div>
  <p>This code gives us this error:</p>
  <pre class="text"><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^</code></pre>
  <p>This is because we‚Äôve violated the rules: we have a <code>&amp;mut T</code> pointing to <code>x</code>, and so we aren‚Äôt allowed to create any <code>&amp;T</code>s. One or the other. The note hints at how to think about this problem:</p>
  <pre class="text"><code>note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>In other words, the mutable borrow is held through the rest of our example. What we want is for the mutable borrow to end <em>before</em> we try to call <code>println!</code> and make an immutable borrow. In Rust, borrowing is tied to the scope that the borrow is valid for. And our scopes look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;    <span class="co">// -+ &amp;mut borrow of x starts here</span>
                     <span class="co">//  |</span>
  *y += <span class="dv">1</span>;           <span class="co">//  |</span>
                     <span class="co">//  |</span>
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// -+ - try to borrow x here</span>
                     <span class="co">// -+ &amp;mut borrow of x ends here</span></code></pre></div>
  <p>The scopes conflict: we can‚Äôt make an <code>&amp;x</code> while <code>y</code> is in scope.</p>
  <p>So when we add the curly braces:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  {                   
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x; <span class="co">// -+ &amp;mut borrow starts here</span>
      *y += <span class="dv">1</span>;        <span class="co">//  |</span>
  }                   <span class="co">// -+ ... and ends here</span>
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);  <span class="co">// &lt;- try to borrow x here</span></code></pre></div>
  <p>There‚Äôs no problem. Our mutable borrow goes out of scope before we create an immutable one. But scope is the key to seeing how long a borrow lasts for.</p>
  </section>
  <section id="issues-borrowing-prevents" class="level4">
  <h4>Issues borrowing prevents</h4>
  <p>Why have these restrictive rules? Well, as we noted, these rules prevent data races. What kinds of issues do data races cause? Here‚Äôs a few.</p>
  <section id="iterator-invalidation" class="level5">
  <h5>Iterator invalidation</h5>
  <p>One example is ‚Äòiterator invalidation‚Äô, which happens when you try to mutate a collection that you‚Äôre iterating over. Rust‚Äôs borrow checker prevents this from happening:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre></div>
  <p>This prints out one through three. As we iterate through the vectors, we‚Äôre only given references to the elements. And <code>v</code> is itself borrowed as immutable, which means we can‚Äôt change it while we‚Äôre iterating:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
      v.push(<span class="dv">34</span>);
  }</code></pre></div>
  <p>Here‚Äôs the error:</p>
  <pre class="text"><code>error: cannot borrow `v` as mutable because it is also borrowed as immutable
      v.push(34);
      ^
  note: previous borrow of `v` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `v` until the borrow ends
  for i in &amp;v {
            ^
  note: previous borrow ends here
  for i in &amp;v {
      println!(‚Äú{}‚Äù, i);
      v.push(34);
  }
  ^</code></pre>
  <p>We can‚Äôt modify <code>v</code> because it‚Äôs borrowed by the loop.</p>
  </section>
  <section id="use-after-free" class="level5">
  <h5>use after free</h5>
  <p>References must not live longer than the resource they refer to. Rust will check the scopes of your references to ensure that this is true.</p>
  <p>If Rust didn‚Äôt check this property, we could accidentally use a reference which was invalid. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="dt">i32</span>;
  { 
      <span class="kw">let</span> x = <span class="dv">5</span>;
      y = &amp;x;
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre></div>
  <p>We get this error:</p>
  <pre class="text"><code>error: `x` does not live long enough
      y = &amp;x;
           ^
  note: reference must be valid for the block suffix following statement 0 at
  2:16...
  let y: &amp;i32;
  { 
      let x = 5;
      y = &amp;x;
  }
  
  note: ...but borrowed value is only valid for the block suffix following
  statement 0 at 4:18
      let x = 5;
      y = &amp;x;
  }</code></pre>
  <p>In other words, <code>y</code> is only valid for the scope where <code>x</code> exists. As soon as <code>x</code> goes away, it becomes invalid to refer to it. As such, the error says that the borrow ‚Äòdoesn‚Äôt live long enough‚Äô because it‚Äôs not valid for the right amount of time.</p>
  <p>The same problem occurs when the reference is declared <em>before</em> the variable it refers to. This is because resources within the same scope are freed in the opposite order they were declared:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="dt">i32</span>;
  <span class="kw">let</span> x = <span class="dv">5</span>;
  y = &amp;x;
  
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre></div>
  <p>We get this error:</p>
  <pre class="text"><code>error: `x` does not live long enough
  y = &amp;x;
       ^
  note: reference must be valid for the block suffix following statement 0 at
  2:16...
      let y: &amp;i32;
      let x = 5;
      y = &amp;x;
      
      println!(&quot;{}&quot;, y);
  }
  
  note: ...but borrowed value is only valid for the block suffix following
  statement 1 at 3:14
      let x = 5;
      y = &amp;x;
      
      println!(&quot;{}&quot;, y);
  }</code></pre>
  <p>In the above example, <code>y</code> is declared before <code>x</code>, meaning that <code>y</code> lives longer than <code>x</code>, which is not allowed.</p>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--lifetimes" class="level2">
  <h2>Lifetimes</h2>
  <p>This guide is one of three presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most unique and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
  <ul>
  <li><a href="#sec--ownership">ownership</a>, the key concept</li>
  <li><a href="#sec--references-and-borrowing">borrowing</a>, and their associated feature ‚Äòreferences‚Äô</li>
  <li>lifetimes, which you‚Äôre reading now</li>
  </ul>
  <p>These three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.</p>
  <section id="meta-2" class="level3">
  <h3>Meta</h3>
  <p>Before we get to the details, two important notes about the ownership system.</p>
  <p>Rust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
  <p>However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
  <p>With that in mind, let‚Äôs learn about lifetimes.</p>
  </section>
  <section id="lifetimes" class="level3">
  <h3>Lifetimes</h3>
  <p>Lending out a reference to a resource that someone else owns can be complicated. For example, imagine this set of operations:</p>
  <ul>
  <li>I acquire a handle to some kind of resource.</li>
  <li>I lend you a reference to the resource.</li>
  <li>I decide I‚Äôm done with the resource, and deallocate it, while you still have your reference.</li>
  <li>You decide to use the resource.</li>
  </ul>
  <p>Uh oh! Your reference is pointing to an invalid resource. This is called a dangling pointer or ‚Äòuse after free‚Äô, when the resource is memory.</p>
  <p>To fix this, we have to make sure that step four never happens after step three. The ownership system in Rust does this through a concept called lifetimes, which describe the scope that a reference is valid for.</p>
  <p>When we have a function that takes a reference by argument, we can be implicit or explicit about the lifetime of the reference:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// implicit</span>
  <span class="kw">fn</span> foo(x: &amp;<span class="dt">i32</span>) {
  }
  
  <span class="co">// explicit</span>
  <span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>) {
  }</code></pre></div>
  <p>The <code>'a</code> reads ‚Äòthe lifetime a‚Äô. Technically, every reference has some lifetime associated with it, but the compiler lets you elide them in common cases. Before we get to that, though, let‚Äôs break the explicit example down:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(...)</code></pre></div>
  <p>We previously talked a little about <a href="#sec--functions">function syntax</a>, but we didn‚Äôt discuss the <code>&lt;&gt;</code>s after a function‚Äôs name. A function can have ‚Äògeneric parameters‚Äô between the <code>&lt;&gt;</code>s, of which lifetimes are one kind. We‚Äôll discuss other kinds of generics <a href="#sec--generics">later in the book</a>, but for now, let‚Äôs just focus on the lifetimes aspect.</p>
  <p>We use <code>&lt;&gt;</code> to declare our lifetimes. This says that <code>bar</code> has one lifetime, <code>'a</code>. If we had two reference parameters, it would look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(...)</code></pre></div>
  <p>Then in our parameter list, we use the lifetimes we‚Äôve named:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>)</code></pre></div>
  <p>If we wanted an <code>&amp;mut</code> reference, we‚Äôd do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="dt">i32</span>)</code></pre></div>
  <p>If you compare <code>&amp;mut i32</code> to <code>&amp;'a mut i32</code>, they‚Äôre the same, it‚Äôs just that the lifetime <code>'a</code> has snuck in between the <code>&amp;</code> and the <code>mut i32</code>. We read <code>&amp;mut i32</code> as ‚Äòa mutable reference to an <code>i32</code>‚Äô and <code>&amp;'a mut i32</code> as ‚Äòa mutable reference to an <code>i32</code> with the lifetime <code>'a</code>‚Äô.</p>
  </section>
  <section id="in-structs" class="level3">
  <h3>In <code>struct</code>s</h3>
  <p>You‚Äôll also need explicit lifetimes when working with <a href="#sec--structs"><code>struct</code></a>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>; <span class="co">// this is the same as `let _y = 5; let y = &amp;_y;`</span>
      <span class="kw">let</span> f = Foo { x: y };
  
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f.x);
  }</code></pre></div>
  <p>As you can see, <code>struct</code>s can also have lifetimes. In a similar way to functions,</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {</code></pre></div>
  <p>declares a lifetime, and</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,</code></pre></div>
  <p>uses it. So why do we need a lifetime here? We need to ensure that any reference to a <code>Foo</code> cannot outlive the reference to an <code>i32</code> it contains.</p>
  <section id="impl-blocks" class="level4">
  <h4><code>impl</code> blocks</h4>
  <p>Let‚Äôs implement a method on <code>Foo</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">impl</span>&lt;<span class="ot">'a</span>&gt; Foo&lt;<span class="ot">'a</span>&gt; {
      <span class="kw">fn</span> x(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">i32</span> { <span class="kw">self</span>.x }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>; <span class="co">// this is the same as `let _y = 5; let y = &amp;_y;`</span>
      <span class="kw">let</span> f = Foo { x: y };
  
      <span class="pp">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, f.x());
  }</code></pre></div>
  <p>As you can see, we need to declare a lifetime for <code>Foo</code> in the <code>impl</code> line. We repeat <code>'a</code> twice, just like on functions: <code>impl&lt;'a&gt;</code> defines a lifetime <code>'a</code>, and <code>Foo&lt;'a&gt;</code> uses it.</p>
  </section>
  <section id="multiple-lifetimes" class="level4">
  <h4>Multiple lifetimes</h4>
  <p>If you have multiple references, you can use the same lifetime multiple times:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> x_or_y&lt;<span class="ot">'a</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="dt">str</span>, y: &amp;<span class="ot">'a</span> <span class="dt">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span> {</code></pre></div>
  <p>This says that <code>x</code> and <code>y</code> both are alive for the same scope, and that the return value is also alive for that scope. If you wanted <code>x</code> and <code>y</code> to have different lifetimes, you can use multiple lifetime parameters:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> x_or_y&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="dt">str</span>, y: &amp;<span class="ot">'b</span> <span class="dt">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span> {</code></pre></div>
  <p>In this example, <code>x</code> and <code>y</code> have different valid scopes, but the return value has the same lifetime as <code>x</code>.</p>
  </section>
  <section id="thinking-in-scopes-1" class="level4">
  <h4>Thinking in scopes</h4>
  <p>A way to think about lifetimes is to visualize the scope that a reference is valid for. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;     <span class="co">// -+ y goes into scope</span>
                      <span class="co">//  |</span>
      <span class="co">// stuff        //  |</span>
                      <span class="co">//  |</span>
  }                   <span class="co">// -+ y goes out of scope</span></code></pre></div>
  <p>Adding in our <code>Foo</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// -+ y goes into scope</span>
      <span class="kw">let</span> f = Foo { x: y }; <span class="co">// -+ f goes into scope</span>
      <span class="co">// stuff              //  |</span>
                            <span class="co">//  |</span>
  }                         <span class="co">// -+ f and y go out of scope</span></code></pre></div>
  <p>Our <code>f</code> lives within the scope of <code>y</code>, so everything works. What if it didn‚Äôt? This code won‚Äôt work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x;                    <span class="co">// -+ x goes into scope</span>
                                <span class="co">//  |</span>
      {                         <span class="co">//  |</span>
          <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// ---+ y goes into scope</span>
          <span class="kw">let</span> f = Foo { x: y }; <span class="co">// ---+ f goes into scope</span>
          x = &amp;f.x;             <span class="co">//  | | error here</span>
      }                         <span class="co">// ---+ f and y go out of scope</span>
                                <span class="co">//  |</span>
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);        <span class="co">//  |</span>
  }                             <span class="co">// -+ x goes out of scope</span></code></pre></div>
  <p>Whew! As you can see here, the scopes of <code>f</code> and <code>y</code> are smaller than the scope of <code>x</code>. But when we do <code>x = &amp;f.x</code>, we make <code>x</code> a reference to something that‚Äôs about to go out of scope.</p>
  <p>Named lifetimes are a way of giving these scopes a name. Giving something a name is the first step towards being able to talk about it.</p>
  </section>
  <section id="static" class="level4">
  <h4>‚Äôstatic</h4>
  <p>The lifetime named ‚Äòstatic‚Äô is a special lifetime. It signals that something has the lifetime of the entire program. Most Rust programmers first come across <code>'static</code> when dealing with strings:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="dt">str</span> = <span class="st">&quot;Hello, world.&quot;</span>;</code></pre></div>
  <p>String literals have the type <code>&amp;'static str</code> because the reference is always alive: they are baked into the data segment of the final binary. Another example are globals:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> FOO: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="dt">i32</span> = &amp;FOO;</code></pre></div>
  <p>This adds an <code>i32</code> to the data segment of the binary, and <code>x</code> is a reference to it.</p>
  </section>
  <section id="lifetime-elision" class="level4">
  <h4>Lifetime Elision</h4>
  <p>Rust supports powerful local type inference in function bodies, but it‚Äôs forbidden in item signatures to allow reasoning about the types based on the item signature alone. However, for ergonomic reasons a very restricted secondary inference algorithm called ‚Äúlifetime elision‚Äù applies in function signatures. It infers only based on the signature components themselves and not based on the body of the function, only infers lifetime parameters, and does this with only three easily memorizable and unambiguous rules. This makes lifetime elision a shorthand for writing an item signature, while not hiding away the actual types involved as full local inference would if applied to it.</p>
  <p>When talking about lifetime elision, we use the term <em>input lifetime</em> and <em>output lifetime</em>. An <em>input lifetime</em> is a lifetime associated with a parameter of a function, and an <em>output lifetime</em> is a lifetime associated with the return value of a function. For example, this function has an input lifetime:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="dt">str</span>)</code></pre></div>
  <p>This one has an output lifetime:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;() -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span></code></pre></div>
  <p>This one has a lifetime in both positions:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="dt">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span></code></pre></div>
  <p>Here are the three rules:</p>
  <ul>
  <li><p>Each elided lifetime in a function‚Äôs arguments becomes a distinct lifetime parameter.</p></li>
  <li><p>If there is exactly one input lifetime, elided or not, that lifetime is assigned to all elided lifetimes in the return values of that function.</p></li>
  <li><p>If there are multiple input lifetimes, but one of them is <code>&amp;self</code> or <code>&amp;mut   self</code>, the lifetime of <code>self</code> is assigned to all elided output lifetimes.</p></li>
  </ul>
  <p>Otherwise, it is an error to elide an output lifetime.</p>
  <section id="examples" class="level5">
  <h5>Examples</h5>
  <p>Here are some examples of functions with elided lifetimes. We‚Äôve paired each example of an elided lifetime with its expanded form.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print(s: &amp;<span class="dt">str</span>); <span class="co">// elided</span>
  <span class="kw">fn</span> print&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>); <span class="co">// expanded</span>
  
  <span class="kw">fn</span> debug(lvl: <span class="dt">u32</span>, s: &amp;<span class="dt">str</span>); <span class="co">// elided</span>
  <span class="kw">fn</span> debug&lt;<span class="ot">'a</span>&gt;(lvl: <span class="dt">u32</span>, s: &amp;<span class="ot">'a</span> <span class="dt">str</span>); <span class="co">// expanded</span>
  
  <span class="co">// In the preceding example, `lvl` doesn‚Äôt need a lifetime because it‚Äôs not a</span>
  <span class="co">// reference (`&amp;`). Only things relating to references (such as a `struct`</span>
  <span class="co">// which contains a reference) need lifetimes.</span>
  
  <span class="kw">fn</span> substr(s: &amp;<span class="dt">str</span>, until: <span class="dt">u32</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// elided</span>
  <span class="kw">fn</span> substr&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>, until: <span class="dt">u32</span>) -&gt; &amp;<span class="ot">'a</span> <span class="dt">str</span>; <span class="co">// expanded</span>
  
  <span class="kw">fn</span> get_str() -&gt; &amp;<span class="dt">str</span>; <span class="co">// ILLEGAL, no inputs</span>
  
  <span class="kw">fn</span> frob(s: &amp;<span class="dt">str</span>, t: &amp;<span class="dt">str</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// ILLEGAL, two inputs</span>
  <span class="kw">fn</span> frob&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="dt">str</span>, t: &amp;<span class="ot">'b</span> <span class="dt">str</span>) -&gt; &amp;<span class="dt">str</span>; <span class="co">// Expanded: Output lifetime is ambig</span>
  ‚Ü≥ uous
  
  <span class="kw">fn</span> get_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="kw">mut</span> T; <span class="co">// elided</span>
  <span class="kw">fn</span> get_mut&lt;<span class="ot">'a</span>&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> T; <span class="co">// expanded</span>
  
  <span class="kw">fn</span> args&lt;T:ToCStr&gt;(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: &amp;[T]) -&gt; &amp;<span class="kw">mut</span> Command; <span class="co">// elided</span>
  <span class="kw">fn</span> args&lt;<span class="ot">'a</span>, <span class="ot">'b</span>, T:ToCStr&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>, args: &amp;<span class="ot">'b</span> [T]) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> Command; <span class="co">// expanded</span>
  
  <span class="kw">fn</span> new(buf: &amp;<span class="kw">mut</span> [<span class="dt">u8</span>]) -&gt; BufWriter; <span class="co">// elided</span>
  <span class="kw">fn</span> new&lt;<span class="ot">'a</span>&gt;(buf: &amp;<span class="ot">'a</span> <span class="kw">mut</span> [<span class="dt">u8</span>]) -&gt; BufWriter&lt;<span class="ot">'a</span>&gt;; <span class="co">// expanded</span></code></pre></div>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--mutability" class="level2">
  <h2>Mutability</h2>
  <p>Mutability, the ability to change something, works a bit differently in Rust than in other languages. The first aspect of mutability is its non-default status:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">6</span>; <span class="co">// error!</span></code></pre></div>
  <p>We can introduce mutability with the <code>mut</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  x = <span class="dv">6</span>; <span class="co">// no problem!</span></code></pre></div>
  <p>This is a mutable <a href="#sec--variable-bindings">variable binding</a>. When a binding is mutable, it means you‚Äôre allowed to change what the binding points to. So in the above example, it‚Äôs not so much that the value at <code>x</code> is changing, but that the binding changed from one <code>i32</code> to another.</p>
  <p>If you want to change what the binding points to, you‚Äôll need a <a href="#sec--references-and-borrowing">mutable reference</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;</code></pre></div>
  <p><code>y</code> is an immutable binding to a mutable reference, which means that you can‚Äôt bind <code>y</code> to something else (<code>y = &amp;mut z</code>), but you can mutate the thing that‚Äôs bound to <code>y</code> (<code>*y = 5</code>). A subtle distinction.</p>
  <p>Of course, if you need both:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> y = &amp;<span class="kw">mut</span> x;</code></pre></div>
  <p>Now <code>y</code> can be bound to another value, and the value it‚Äôs referencing can be changed.</p>
  <p>It‚Äôs important to note that <code>mut</code> is part of a <a href="#sec--patterns">pattern</a>, so you can do things like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (<span class="kw">mut</span> x, y) = (<span class="dv">5</span>, <span class="dv">6</span>);
  
  <span class="kw">fn</span> foo(<span class="kw">mut</span> x: <span class="dt">i32</span>) {</code></pre></div>
  <section id="interior-vs.exterior-mutability" class="level3">
  <h3>Interior vs.¬†Exterior Mutability</h3>
  <p>However, when we say something is ‚Äòimmutable‚Äô in Rust, that doesn‚Äôt mean that it‚Äôs not able to be changed: we mean something has ‚Äòexterior mutability‚Äô. Consider, for example, <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Arc;
  
  <span class="kw">let</span> x = Arc::new(<span class="dv">5</span>);
  <span class="kw">let</span> y = x.clone();</code></pre></div>
  <p>When we call <code>clone()</code>, the <code>Arc&lt;T&gt;</code> needs to update the reference count. Yet we‚Äôve not used any <code>mut</code>s here, <code>x</code> is an immutable binding, and we didn‚Äôt take <code>&amp;mut 5</code> or anything. So what gives?</p>
  <p>To understand this, we have to go back to the core of Rust‚Äôs guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the <a href="#sec--ownership">ownership</a> system, and more specifically, <a href="#borrowing">borrowing</a>:</p>
  <blockquote>
  <p>You may have one or the other of these two kinds of borrows, but not both at the same time:</p>
  <ul>
  <li>one or more references (<code>&amp;T</code>) to a resource,</li>
  <li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
  </ul>
  </blockquote>
  <p>So, that‚Äôs the real definition of ‚Äòimmutability‚Äô: is this safe to have two pointers to? In <code>Arc&lt;T&gt;</code>‚Äôs case, yes: the mutation is entirely contained inside the structure itself. It‚Äôs not user facing. For this reason, it hands out <code>&amp;T</code> with <code>clone()</code>. If it handed out <code>&amp;mut T</code>s, though, that would be a problem.</p>
  <p>Other types, like the ones in the <a href="http://doc.rust-lang.org/std/cell/index.html"><code>std::cell</code></a> module, have the opposite: interior mutability. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();</code></pre></div>
  <p>RefCell hands out <code>&amp;mut</code> references to what‚Äôs inside of it with the <code>borrow_mut()</code> method. Isn‚Äôt that dangerous? What if we do:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();
  <span class="kw">let</span> z = x.borrow_mut();</code></pre></div>
  <p>This will in fact panic, at runtime. This is what <code>RefCell</code> does: it enforces Rust‚Äôs borrowing rules at runtime, and <code>panic!</code>s if they‚Äôre violated. This allows us to get around another aspect of Rust‚Äôs mutability rules. Let‚Äôs talk about it first.</p>
  <section id="field-level-mutability" class="level4">
  <h4>Field-level mutability</h4>
  <p>Mutability is a property of either a borrow (<code>&amp;mut</code>) or a binding (<code>let mut</code>). This means that, for example, you cannot have a <a href="#sec--structs"><code>struct</code></a> with some fields mutable and some immutable:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      <span class="kw">mut</span> y: <span class="dt">i32</span>, <span class="co">// nope</span>
  }</code></pre></div>
  <p>The mutability of a struct is in its binding:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> a = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span> };
  
  a.x = <span class="dv">10</span>;
  
  <span class="kw">let</span> b = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span>};
  
  b.x = <span class="dv">10</span>; <span class="co">// error: cannot assign to immutable field `b.x`</span></code></pre></div>
  <p>However, by using <a href="http://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>, you can emulate field-level mutability:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::Cell;
  
  <span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: Cell&lt;<span class="dt">i32</span>&gt;,
  }
  
  <span class="kw">let</span> point = Point { x: <span class="dv">5</span>, y: Cell::new(<span class="dv">6</span>) };
  
  point.y.set(<span class="dv">7</span>);
  
  <span class="pp">println!</span>(<span class="st">&quot;y: {:?}&quot;</span>, point.y);</code></pre></div>
  <p>This will print <code>y: Cell { value: 7 }</code>. We‚Äôve successfully updated <code>y</code>.</p>
  </section>
  </section>
  </section>
  <section id="sec--structs" class="level2">
  <h2>Structs</h2>
  <p><code>struct</code>s are a way of creating more complex data types. For example, if we were doing calculations involving coordinates in 2D space, we would need both an <code>x</code> and a <code>y</code> value:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin_x = <span class="dv">0</span>;
  <span class="kw">let</span> origin_y = <span class="dv">0</span>;</code></pre></div>
  <p>A <code>struct</code> lets us combine these two into a single, unified datatype:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> }; <span class="co">// origin: Point</span>
  
      <span class="pp">println!</span>(<span class="st">&quot;The origin is at ({}, {})&quot;</span>, origin.x, origin.y);
  }</code></pre></div>
  <p>There‚Äôs a lot going on here, so let‚Äôs break it down. We declare a <code>struct</code> with the <code>struct</code> keyword, and then with a name. By convention, <code>struct</code>s begin with a capital letter and are camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>
  <p>We can create an instance of our <code>struct</code> via <code>let</code>, as usual, but we use a <code>key: value</code> style syntax to set each field. The order doesn‚Äôt need to be the same as in the original declaration.</p>
  <p>Finally, because fields have names, we can access the field through dot notation: <code>origin.x</code>.</p>
  <p>The values in <code>struct</code>s are immutable by default, like other bindings in Rust. Use <code>mut</code> to make them mutable:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;The point is at ({}, {})&quot;</span>, point.x, point.y);
  }</code></pre></div>
  <p>This will print <code>The point is at (5, 0)</code>.</p>
  <p>Rust does not support field mutability at the language level, so you cannot write something like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      <span class="kw">mut</span> x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }</code></pre></div>
  <p>Mutability is a property of the binding, not of the structure itself. If you‚Äôre used to field-level mutability, this may seem strange at first, but it significantly simplifies things. It even lets you make things mutable for a short time only:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="kw">let</span> point = point; <span class="co">// this new binding can‚Äôt change now</span>
  
      point.y = <span class="dv">6</span>; <span class="co">// this causes an error</span>
  }</code></pre></div>
  <section id="update-syntax" class="level3">
  <h3>Update syntax</h3>
  <p>A <code>struct</code> can include <code>..</code> to indicate that you want to use a copy of some other <code>struct</code> for some of the values. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point3d {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
      z: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> point = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  point = Point3d { y: <span class="dv">1</span>, .. point };</code></pre></div>
  <p>This gives <code>point</code> a new <code>y</code>, but keeps the old <code>x</code> and <code>z</code> values. It doesn‚Äôt have to be the same <code>struct</code> either, you can use this syntax when making new ones, and it will copy the values you don‚Äôt specify:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  <span class="kw">let</span> point = Point3d { z: <span class="dv">1</span>, x: <span class="dv">2</span>, .. origin };</code></pre></div>
  </section>
  <section id="tuple-structs" class="level3">
  <h3>Tuple structs</h3>
  <p>Rust has another data type that‚Äôs like a hybrid between a <a href="#tuples">tuple</a> and a <code>struct</code>, called a ‚Äòtuple struct‚Äô. Tuple structs have a name, but their fields don‚Äôt:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>);
  <span class="kw">struct</span> Point(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>);</code></pre></div>
  <p>These two will not be equal, even if they have the same values:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> black = Color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
  <span class="kw">let</span> origin = Point(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);</code></pre></div>
  <p>It is almost always better to use a <code>struct</code> than a tuple struct. We would write <code>Color</code> and <code>Point</code> like this instead:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color {
      red: <span class="dt">i32</span>,
      blue: <span class="dt">i32</span>,
      green: <span class="dt">i32</span>,
  }
  
  <span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
      z: <span class="dt">i32</span>,
  }</code></pre></div>
  <p>Now, we have actual names, rather than positions. Good names are important, and with a <code>struct</code>, we have actual names.</p>
  <p>There <em>is</em> one case when a tuple struct is very useful, though, and that‚Äôs a tuple struct with only one element. We call this the ‚Äònewtype‚Äô pattern, because it allows you to create a new type, distinct from that of its contained value and expressing its own semantic meaning:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Inches(<span class="dt">i32</span>);
  
  <span class="kw">let</span> length = Inches(<span class="dv">10</span>);
  
  <span class="kw">let</span> Inches(integer_length) = length;
  <span class="pp">println!</span>(<span class="st">&quot;length is {} inches&quot;</span>, integer_length);</code></pre></div>
  <p>As you can see here, you can extract the inner integer type through a destructuring <code>let</code>, just as with regular tuples. In this case, the <code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>.</p>
  </section>
  <section id="unit-like-structs" class="level3">
  <h3>Unit-like structs</h3>
  <p>You can define a <code>struct</code> with no members at all:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Electron;</code></pre></div>
  <p>Such a <code>struct</code> is called ‚Äòunit-like‚Äô because it resembles the empty tuple, <code>()</code>, sometimes called ‚Äòunit‚Äô. Like a tuple struct, it defines a new type.</p>
  <p>This is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful. For instance, a library may ask you to create a structure that implements a certain <a href="#sec--traits">trait</a> to handle events. If you don‚Äôt have any data you need to store in the structure, you can just create a unit-like <code>struct</code>.</p>
  </section>
  </section>
  <section id="sec--enums" class="level2">
  <h2>Enums</h2>
  <p>An <code>enum</code> in Rust is a type that represents data that could be one of several possible variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>),
      Move { x: <span class="dt">i32</span>, y: <span class="dt">i32</span> },
      Write(<span class="dt">String</span>),
  }</code></pre></div>
  <p>Each variant can optionally have data associated with it. The syntax for defining variants resembles the syntaxes used to define structs: you can have variants with no data (like unit-like structs), variants with named data, and variants with unnamed data (like tuple structs). Unlike separate struct definitions, however, an <code>enum</code> is a single type. A value of the enum can match any of the variants. For this reason, an enum is sometimes called a ‚Äòsum type‚Äô: the set of possible values of the enum is the sum of the sets of possible values for each variant.</p>
  <p>We use the <code>::</code> syntax to use the name of each variant: they‚Äôre scoped by the name of the <code>enum</code> itself. This allows both of these to work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: Message = Message::Move { x: <span class="dv">3</span>, y: <span class="dv">4</span> };
  
  <span class="kw">enum</span> BoardGameTurn {
      Move { squares: <span class="dt">i32</span> },
      Pass,
  }
  
  <span class="kw">let</span> y: BoardGameTurn = BoardGameTurn::Move { squares: <span class="dv">1</span> };</code></pre></div>
  <p>Both variants are named <code>Move</code>, but since they‚Äôre scoped to the name of the enum, they can both be used without conflict.</p>
  <p>A value of an enum type contains information about which variant it is, in addition to any data associated with that variant. This is sometimes referred to as a ‚Äòtagged union‚Äô, since the data includes a ‚Äòtag‚Äô indicating what type it is. The compiler uses this information to enforce that you‚Äôre accessing the data in the enum safely. For instance, you can‚Äôt simply try to destructure a value as if it were one of the possible variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> process_color_change(msg: Message) {
      <span class="kw">let</span> Message::ChangeColor(r, g, b) = msg; <span class="co">// compile-time error</span>
  }</code></pre></div>
  <p>Not supporting these operations may seem rather limiting, but it‚Äôs a limitation which we can overcome. There are two ways: by implementing equality ourselves, or by pattern matching variants with <a href="#sec--match"><code>match</code></a> expressions, which you‚Äôll learn in the next section. We don‚Äôt know enough about Rust to implement equality yet, but we‚Äôll find out in the <a href="#sec--traits"><code>traits</code></a> section.</p>
  <section id="constructors-as-functions" class="level3">
  <h3>Constructors as functions</h3>
  <p>An enum‚Äôs constructors can also be used like functions. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> m = Message::Write(<span class="st">&quot;Hello, world&quot;</span>.to_string());</code></pre></div>
  <p>Is the same as</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="dt">String</span>) -&gt; Message {
      Message::Write(x)
  }
  
  <span class="kw">let</span> x = foo(<span class="st">&quot;Hello, world&quot;</span>.to_string());</code></pre></div>
  <p>This is not immediately useful to us, but when we get to <a href="#sec--closures"><code>closures</code></a>, we‚Äôll talk about passing functions as arguments to other functions. For example, with <a href="#sec--iterators"><code>iterators</code></a>, we can do this to convert a vector of <code>String</code>s into a vector of <code>Message::Write</code>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>.to_string(), <span class="st">&quot;World&quot;</span>.to_string()];
  
  <span class="kw">let</span> v1: <span class="dt">Vec</span>&lt;Message&gt; = v.into_iter().map(Message::Write).collect();</code></pre></div>
  </section>
  </section>
  <section id="sec--match" class="level2">
  <h2>Match</h2>
  <p>Often, a simple <a href="#sec--if"><code>if</code></a>/<code>else</code> isn‚Äôt enough, because you have more than two possible options. Also, conditions can get quite complex. Rust has a keyword, <code>match</code>, that allows you to replace complicated <code>if</code>/<code>else</code> groupings with something more powerful. Check it out:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      <span class="dv">4</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;four&quot;</span>),
      <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;five&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;something else&quot;</span>),
  }</code></pre></div>
  <p><code>match</code> takes an expression and then branches based on its value. Each ‚Äòarm‚Äô of the branch is of the form <code>val =&gt; expression</code>. When the value matches, that arm‚Äôs expression will be evaluated. It‚Äôs called <code>match</code> because of the term ‚Äòpattern matching‚Äô, which <code>match</code> is an implementation of. There‚Äôs an <a href="#sec--patterns">entire section on patterns</a> that covers all the patterns that are possible here.</p>
  <p>So what‚Äôs the big advantage? Well, there are a few. First of all, <code>match</code> enforces ‚Äòexhaustiveness checking‚Äô. Do you see that last arm, the one with the underscore (<code>_</code>)? If we remove that arm, Rust will give us an error:</p>
  <pre class="text"><code>error: non-exhaustive patterns: `_` not covered</code></pre>
  <p>In other words, Rust is trying to tell us we forgot a value. Because <code>x</code> is an integer, Rust knows that it can have a number of different values ‚Äì for example, <code>6</code>. Without the <code>_</code>, however, there is no arm that could match, and so Rust refuses to compile the code. <code>_</code> acts like a ‚Äòcatch-all arm‚Äô. If none of the other arms match, the arm with <code>_</code> will, and since we have this catch-all arm, we now have an arm for every possible value of <code>x</code>, and so our program will compile successfully.</p>
  <p><code>match</code> is also an expression, which means we can use it on the right-hand side of a <code>let</code> binding or directly where an expression is used:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> number = <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="st">&quot;one&quot;</span>,
      <span class="dv">2</span> =&gt; <span class="st">&quot;two&quot;</span>,
      <span class="dv">3</span> =&gt; <span class="st">&quot;three&quot;</span>,
      <span class="dv">4</span> =&gt; <span class="st">&quot;four&quot;</span>,
      <span class="dv">5</span> =&gt; <span class="st">&quot;five&quot;</span>,
      _ =&gt; <span class="st">&quot;something else&quot;</span>,
  };</code></pre></div>
  <p>Sometimes it‚Äôs a nice way of converting something from one type to another.</p>
  <section id="matching-on-enums" class="level3">
  <h3>Matching on enums</h3>
  <p>Another important use of the <code>match</code> keyword is to process the possible variants of an enum:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>),
      Move { x: <span class="dt">i32</span>, y: <span class="dt">i32</span> },
      Write(<span class="dt">String</span>),
  }
  
  <span class="kw">fn</span> quit() { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> change_color(r: <span class="dt">i32</span>, g: <span class="dt">i32</span>, b: <span class="dt">i32</span>) { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> move_cursor(x: <span class="dt">i32</span>, y: <span class="dt">i32</span>) { <span class="co">/* ... */</span> }
  
  <span class="kw">fn</span> process_message(msg: Message) {
      <span class="kw">match</span> msg {
          Message::Quit =&gt; quit(),
          Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
          Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
          Message::Write(s) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s),
      };
  }</code></pre></div>
  <p>Again, the Rust compiler checks exhaustiveness, so it demands that you have a match arm for every variant of the enum. If you leave one off, it will give you a compile-time error unless you use <code>_</code>.</p>
  <p>Unlike the previous uses of <code>match</code>, you can‚Äôt use the normal <code>if</code> statement to do this. You can use the <a href="#sec--if-let"><code>if let</code></a> statement, which can be seen as an abbreviated form of <code>match</code>.</p>
  </section>
  </section>
  <section id="sec--patterns" class="level2">
  <h2>Patterns</h2>
  <p>Patterns are quite common in Rust. We use them in <a href="#sec--variable-bindings">variable bindings</a>, <a href="#sec--match">match statements</a>, and other places, too. Let‚Äôs go on a whirlwind tour of all of the things patterns can do!</p>
  <p>A quick refresher: you can match against literals directly, and <code>_</code> acts as an ‚Äòany‚Äô case:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one</code>.</p>
  <section id="multiple-patterns" class="level3">
  <h3>Multiple patterns</h3>
  <p>You can match multiple patterns with <code>|</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> | <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one or two&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;three&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one or two</code>.</p>
  </section>
  <section id="destructuring" class="level3">
  <h3>Destructuring</h3>
  <p>If you have a compound data type, like a <a href="#sec--structs"><code>struct</code></a>, you can destructure it inside of a pattern:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x, y } =&gt; <span class="pp">println!</span>(<span class="st">&quot;({},{})&quot;</span>, x, y),
  }</code></pre></div>
  <p>We can use <code>:</code> to give a value a different name.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x: x1, y: y1 } =&gt; <span class="pp">println!</span>(<span class="st">&quot;({},{})&quot;</span>, x1, y1),
  }</code></pre></div>
  <p>If we only care about some of the values, we don‚Äôt have to give them all names:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x, .. } =&gt; <span class="pp">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x),
  }</code></pre></div>
  <p>This prints <code>x is 0</code>.</p>
  <p>You can do this kind of match on any member, not just the first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { y, .. } =&gt; <span class="pp">println!</span>(<span class="st">&quot;y is {}&quot;</span>, y),
  }</code></pre></div>
  <p>This prints <code>y is 0</code>.</p>
  <p>This ‚Äòdestructuring‚Äô behavior works on any compound data type, like <a href="#tuples">tuples</a> or <a href="#sec--enums">enums</a>.</p>
  </section>
  <section id="ignoring-bindings" class="level3">
  <h3>Ignoring bindings</h3>
  <p>You can use <code>_</code> in a pattern to disregard the type and value. For example, here‚Äôs a <code>match</code> against a <code>Result&lt;T, E&gt;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> some_value {
      <span class="cn">Ok</span>(value) =&gt; <span class="pp">println!</span>(<span class="st">&quot;got a value: {}&quot;</span>, value),
      <span class="cn">Err</span>(_) =&gt; <span class="pp">println!</span>(<span class="st">&quot;an error occurred&quot;</span>),
  }</code></pre></div>
  <p>In the first arm, we bind the value inside the <code>Ok</code> variant to <code>value</code>. But in the <code>Err</code> arm, we use <code>_</code> to disregard the specific error, and just print a general error message.</p>
  <p><code>_</code> is valid in any pattern that creates a binding. This can be useful to ignore parts of a larger structure:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> coordinate() -&gt; (<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>) {
      <span class="co">// generate and return some sort of triple tuple</span>
  }
  
  <span class="kw">let</span> (x, _, z) = coordinate();</code></pre></div>
  <p>Here, we bind the first and last element of the tuple to <code>x</code> and <code>z</code>, but ignore the middle element.</p>
  <p>Similarly, you can use <code>..</code> in a pattern to disregard multiple values.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalTuple {
      Value(<span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalTuple::Value(<span class="dv">5</span>, -<span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="kw">match</span> x {
      OptionalTuple::Value(..) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got a tuple!&quot;</span>),
      OptionalTuple::Missing =&gt; <span class="pp">println!</span>(<span class="st">&quot;No such luck.&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>Got a tuple!</code>.</p>
  </section>
  <section id="ref-and-ref-mut" class="level3">
  <h3>ref and ref mut</h3>
  <p>If you want to get a <a href="#sec--references-and-borrowing">reference</a>, use the <code>ref</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> r =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got a reference to {}&quot;</span>, r),
  }</code></pre></div>
  <p>This prints <code>Got a reference to 5</code>.</p>
  <p>Here, the <code>r</code> inside the <code>match</code> has the type <code>&amp;i32</code>. In other words, the <code>ref</code> keyword <em>creates</em> a reference, for use in the pattern. If you need a mutable reference, <code>ref mut</code> will work in the same way:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> <span class="kw">mut</span> mr =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got a mutable reference to {}&quot;</span>, mr),
  }</code></pre></div>
  </section>
  <section id="ranges" class="level3">
  <h3>Ranges</h3>
  <p>You can match a range of values with <code>...</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;one through five&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>one through five</code>.</p>
  <p>Ranges are mostly used with integers and <code>char</code>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'üíÖ'</span>;
  
  <span class="kw">match</span> x {
      <span class="ch">'a'</span> ... <span class="ch">'j'</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;early letter&quot;</span>),
      <span class="ch">'k'</span> ... <span class="ch">'z'</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;late letter&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;something else&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>something else</code>.</p>
  </section>
  <section id="bindings" class="level3">
  <h3>Bindings</h3>
  <p>You can bind values to names with <code>@</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;got a range element {}&quot;</span>, e),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>got a range element 1</code>. This is useful when you want to do a complicated match of part of a data structure:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">struct</span> Person {
      name: <span class="dt">Option</span>&lt;<span class="dt">String</span>&gt;,
  }
  
  <span class="kw">let</span> name = <span class="st">&quot;Steve&quot;</span>.to_string();
  <span class="kw">let</span> <span class="kw">mut</span> x: <span class="dt">Option</span>&lt;Person&gt; = <span class="cn">Some</span>(Person { name: <span class="cn">Some</span>(name) });
  <span class="kw">match</span> x {
      <span class="cn">Some</span>(Person { name: <span class="kw">ref</span> a @ <span class="cn">Some</span>(_), .. }) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, a),
      _ =&gt; {}
  }</code></pre></div>
  <p>This prints <code>Some(&quot;Steve&quot;)</code>: we‚Äôve bound the inner <code>name</code> to <code>a</code>.</p>
  <p>If you use <code>@</code> with <code>|</code>, you need to make sure the name is bound in each part of the pattern:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> | e @ <span class="dv">8</span> ... <span class="dv">10</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;got a range element {}&quot;</span>, e),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;anything&quot;</span>),
  }</code></pre></div>
  </section>
  <section id="guards" class="level3">
  <h3>Guards</h3>
  <p>You can introduce ‚Äòmatch guards‚Äô with <code>if</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalInt {
      Value(<span class="dt">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalInt::Value(<span class="dv">5</span>);
  
  <span class="kw">match</span> x {
      OptionalInt::Value(i) <span class="kw">if</span> i &gt; <span class="dv">5</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got an int bigger than five!&quot;</span>),
      OptionalInt::Value(..) =&gt; <span class="pp">println!</span>(<span class="st">&quot;Got an int!&quot;</span>),
      OptionalInt::Missing =&gt; <span class="pp">println!</span>(<span class="st">&quot;No such luck.&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>Got an int!</code>.</p>
  <p>If you‚Äôre using <code>if</code> with multiple patterns, the <code>if</code> applies to both sides:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">4</span>;
  <span class="kw">let</span> y = <span class="cn">false</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">4</span> | <span class="dv">5</span> <span class="kw">if</span> y =&gt; <span class="pp">println!</span>(<span class="st">&quot;yes&quot;</span>),
      _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;no&quot;</span>),
  }</code></pre></div>
  <p>This prints <code>no</code>, because the <code>if</code> applies to the whole of <code>4 | 5</code>, and not to just the <code>5</code>, In other words, the the precedence of <code>if</code> behaves like this:</p>
  <pre class="text"><code>(4 | 5) if y =&gt; ...</code></pre>
  <p>not this:</p>
  <pre class="text"><code>4 | (5 if y) =&gt; ...</code></pre>
  </section>
  <section id="mix-and-match" class="level3">
  <h3>Mix and Match</h3>
  <p>Whew! That‚Äôs a lot of different ways to match things, and they can all be mixed and matched, depending on what you‚Äôre doing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> x {
      Foo { x: <span class="cn">Some</span>(<span class="kw">ref</span> name), y: <span class="cn">None</span> } =&gt; ...
  }</code></pre></div>
  <p>Patterns are very powerful. Make good use of them.</p>
  </section>
  </section>
  <section id="sec--method-syntax" class="level2">
  <h2>Method Syntax</h2>
  <p>Functions are great, but if you want to call a bunch of them on some data, it can be awkward. Consider this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">baz(bar(foo));</code></pre></div>
  <p>We would read this left-to-right, and so we see ‚Äòbaz bar foo‚Äô. But this isn‚Äôt the order that the functions would get called in, that‚Äôs inside-out: ‚Äòfoo bar baz‚Äô. Wouldn‚Äôt it be nice if we could do this instead?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">foo.bar().baz();</code></pre></div>
  <p>Luckily, as you may have guessed with the leading question, you can! Rust provides the ability to use this ‚Äòmethod call syntax‚Äô via the <code>impl</code> keyword.</p>
  <section id="method-calls" class="level3">
  <h3>Method calls</h3>
  <p>Here‚Äôs how it works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">2.0</span> };
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, c.area());
  }</code></pre></div>
  <p>This will print <code>12.566371</code>.</p>
  <p>We‚Äôve made a <code>struct</code> that represents a circle. We then write an <code>impl</code> block, and inside it, define a method, <code>area</code>.</p>
  <p>Methods take a special first parameter, of which there are three variants: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. You can think of this first parameter as being the <code>foo</code> in <code>foo.bar()</code>. The three variants correspond to the three kinds of things <code>foo</code> could be: <code>self</code> if it‚Äôs just a value on the stack, <code>&amp;self</code> if it‚Äôs a reference, and <code>&amp;mut self</code> if it‚Äôs a mutable reference. Because we took the <code>&amp;self</code> parameter to <code>area</code>, we can use it just like any other parameter. Because we know it‚Äôs a <code>Circle</code>, we can access the <code>radius</code> just like we would with any other <code>struct</code>.</p>
  <p>We should default to using <code>&amp;self</code>, as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones. Here‚Äôs an example of all three variants:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> reference(&amp;<span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking self by reference!&quot;</span>);
      }
  
      <span class="kw">fn</span> mutable_reference(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking self by mutable reference!&quot;</span>);
      }
  
      <span class="kw">fn</span> takes_ownership(<span class="kw">self</span>) {
         <span class="pp">println!</span>(<span class="st">&quot;taking ownership of self!&quot;</span>);
      }
  }</code></pre></div>
  </section>
  <section id="chaining-method-calls" class="level3">
  <h3>Chaining method calls</h3>
  <p>So, now we know how to call a method, such as <code>foo.bar()</code>. But what about our original example, <code>foo.bar().baz()</code>? This is called ‚Äòmethod chaining‚Äô. Let‚Äôs look at an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  
      <span class="kw">fn</span> grow(&amp;<span class="kw">self</span>, increment: <span class="dt">f64</span>) -&gt; Circle {
          Circle { x: <span class="kw">self</span>.x, y: <span class="kw">self</span>.y, radius: <span class="kw">self</span>.radius + increment }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">2.0</span> };
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, c.area());
  
      <span class="kw">let</span> d = c.grow(<span class="dv">2.0</span>).area();
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, d);
  }</code></pre></div>
  <p>Check the return type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> grow(&amp;<span class="kw">self</span>, increment: <span class="dt">f64</span>) -&gt; Circle {</code></pre></div>
  <p>We just say we‚Äôre returning a <code>Circle</code>. With this method, we can grow a new <code>Circle</code> to any arbitrary size.</p>
  </section>
  <section id="associated-functions" class="level3">
  <h3>Associated functions</h3>
  <p>You can also define associated functions that do not take a <code>self</code> parameter. Here‚Äôs a pattern that‚Äôs very common in Rust code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> new(x: <span class="dt">f64</span>, y: <span class="dt">f64</span>, radius: <span class="dt">f64</span>) -&gt; Circle {
          Circle {
              x: x,
              y: y,
              radius: radius,
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle::new(<span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">2.0</span>);
  }</code></pre></div>
  <p>This ‚Äòassociated function‚Äô builds a new <code>Circle</code> for us. Note that associated functions are called with the <code>Struct::function()</code> syntax, rather than the <code>ref.method()</code> syntax. Some other languages call associated functions ‚Äòstatic methods‚Äô.</p>
  </section>
  <section id="builder-pattern" class="level3">
  <h3>Builder Pattern</h3>
  <p>Let‚Äôs say that we want our users to be able to create <code>Circle</code>s, but we will allow them to only set the properties they care about. Otherwise, the <code>x</code> and <code>y</code> attributes will be <code>0.0</code>, and the <code>radius</code> will be <code>1.0</code>. Rust doesn‚Äôt have method overloading, named arguments, or variable arguments. We employ the builder pattern instead. It looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">struct</span> CircleBuilder {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> CircleBuilder {
      <span class="kw">fn</span> new() -&gt; CircleBuilder {
          CircleBuilder { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">1.0</span>, }
      }
  
      <span class="kw">fn</span> x(&amp;<span class="kw">mut</span> <span class="kw">self</span>, coordinate: <span class="dt">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.x = coordinate;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> y(&amp;<span class="kw">mut</span> <span class="kw">self</span>, coordinate: <span class="dt">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.y = coordinate;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> radius(&amp;<span class="kw">mut</span> <span class="kw">self</span>, radius: <span class="dt">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.radius = radius;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> finalize(&amp;<span class="kw">self</span>) -&gt; Circle {
          Circle { x: <span class="kw">self</span>.x, y: <span class="kw">self</span>.y, radius: <span class="kw">self</span>.radius }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = CircleBuilder::new()
                  .x(<span class="dv">1.0</span>)
                  .y(<span class="dv">2.0</span>)
                  .radius(<span class="dv">2.0</span>)
                  .finalize();
  
      <span class="pp">println!</span>(<span class="st">&quot;area: {}&quot;</span>, c.area());
      <span class="pp">println!</span>(<span class="st">&quot;x: {}&quot;</span>, c.x);
      <span class="pp">println!</span>(<span class="st">&quot;y: {}&quot;</span>, c.y);
  }</code></pre></div>
  <p>What we‚Äôve done here is make another <code>struct</code>, <code>CircleBuilder</code>. We‚Äôve defined our builder methods on it. We‚Äôve also defined our <code>area()</code> method on <code>Circle</code>. We also made one more method on <code>CircleBuilder</code>: <code>finalize()</code>. This method creates our final <code>Circle</code> from the builder. Now, we‚Äôve used the type system to enforce our concerns: we can use the methods on <code>CircleBuilder</code> to constrain making <code>Circle</code>s in any way we choose.</p>
  </section>
  </section>
  <section id="sec--vectors" class="level2">
  <h2>Vectors</h2>
  <p>A ‚Äòvector‚Äô is a dynamic or ‚Äògrowable‚Äô array, implemented as the standard library type <a href="http://doc.rust-lang.org/std/vec/index.html"><code>Vec&lt;T&gt;</code></a>. The <code>T</code> means that we can have vectors of any type (see the chapter on <a href="#sec--generics">generics</a> for more). Vectors always allocate their data on the heap. You can create them with the <code>vec!</code> macro:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]; <span class="co">// v: Vec&lt;i32&gt;</span></code></pre></div>
  <p>(Notice that unlike the <code>println!</code> macro we‚Äôve used in the past, we use square brackets <code>[]</code> with <code>vec!</code> macro. Rust allows you to use either in either situation, this is just convention.)</p>
  <p>There‚Äôs an alternate form of <code>vec!</code> for repeating an initial value:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">0</span>; <span class="dv">10</span>]; <span class="co">// ten zeroes</span></code></pre></div>
  <section id="accessing-elements" class="level4">
  <h4>Accessing elements</h4>
  <p>To get the value at a particular index in the vector, we use <code>[]</code>s:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="pp">println!</span>(<span class="st">&quot;The third element of v is {}&quot;</span>, v[<span class="dv">2</span>]);</code></pre></div>
  <p>The indices count from <code>0</code>, so the third element is <code>v[2]</code>.</p>
  </section>
  <section id="iterating" class="level4">
  <h4>Iterating</h4>
  <p>Once you have a vector, you can iterate through its elements with <code>for</code>. There are three versions:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;v {
      <span class="pp">println!</span>(<span class="st">&quot;A reference to {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i <span class="kw">in</span> &amp;<span class="kw">mut</span> v {
      <span class="pp">println!</span>(<span class="st">&quot;A mutable reference to {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i <span class="kw">in</span> v {
      <span class="pp">println!</span>(<span class="st">&quot;Take ownership of the vector and its element {}&quot;</span>, i);
  }</code></pre></div>
  <p>Vectors have many more useful methods, which you can read about in <a href="http://doc.rust-lang.org/std/vec/index.html">their API documentation</a>.</p>
  </section>
  </section>
  <section id="sec--strings" class="level2">
  <h2>Strings</h2>
  <p>Strings are an important concept for any programmer to master. Rust‚Äôs string handling system is a bit different from other languages, due to its systems focus. Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure. That being said, Rust‚Äôs strings also work differently than in some other systems languages, such as C.</p>
  <p>Let‚Äôs dig into the details. A ‚Äòstring‚Äô is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally, unlike some systems languages, strings are not null-terminated and can contain null bytes.</p>
  <p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let‚Äôs talk about <code>&amp;str</code> first. These are called ‚Äòstring slices‚Äô. String literals are of the type <code>&amp;'static str</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> greeting = <span class="st">&quot;Hello there.&quot;</span>; <span class="co">// greeting: &amp;'static str</span></code></pre></div>
  <p>This string is statically allocated, meaning that it‚Äôs saved inside our compiled program, and exists for the entire duration it runs. The <code>greeting</code> binding is a reference to this statically allocated string. String slices have a fixed size, and cannot be mutated.</p>
  <p>A <code>String</code>, on the other hand, is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are commonly created by converting from a string slice using the <code>to_string</code> method.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> s = <span class="st">&quot;Hello&quot;</span>.to_string(); <span class="co">// mut s: String</span>
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);
  
  s.push_str(<span class="st">&quot;, world.&quot;</span>);
  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);</code></pre></div>
  <p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_slice(slice: &amp;<span class="dt">str</span>) {
      <span class="pp">println!</span>(<span class="st">&quot;Got: {}&quot;</span>, slice);
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> s = <span class="st">&quot;Hello&quot;</span>.to_string();
      takes_slice(&amp;s);
  }</code></pre></div>
  <p>This coercion does not happen for functions that accept one of <code>&amp;str</code>‚Äôs traits instead of <code>&amp;str</code>. For example, <a href="http://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> has a parameter of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly converted using <code>&amp;*</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::net::TcpStream;
  
  TcpStream::connect(<span class="st">&quot;192.168.0.1:3000&quot;</span>); <span class="co">// &amp;str parameter</span>
  
  <span class="kw">let</span> addr_string = <span class="st">&quot;192.168.0.1:3000&quot;</span>.to_string();
  TcpStream::connect(&amp;*addr_string); <span class="co">// convert addr_string to &amp;str</span></code></pre></div>
  <p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a <code>String</code> involves allocating memory. No reason to do that unless you have to!</p>
  <section id="indexing" class="level4">
  <h4>Indexing</h4>
  <p>Because strings are valid UTF-8, strings do not support indexing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;hello&quot;</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;The first letter of s is {}&quot;</span>, s[<span class="dv">0</span>]); <span class="co">// ERROR!!!</span></code></pre></div>
  <p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the n·µó ∞ letter of a string. This is a significantly more expensive operation, and we don‚Äôt want to be misleading. Furthermore, ‚Äòletter‚Äô isn‚Äôt something defined in Unicode, exactly. We can choose to look at a string as individual bytes, or as codepoints:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hachiko = <span class="st">&quot;Âø†Áä¨„Éè„ÉÅÂÖ¨&quot;</span>;
  
  <span class="kw">for</span> b <span class="kw">in</span> hachiko.as_bytes() {
      <span class="pp">print!</span>(<span class="st">&quot;{}, &quot;</span>, b);
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;&quot;</span>);
  
  <span class="kw">for</span> c <span class="kw">in</span> hachiko.chars() {
      <span class="pp">print!</span>(<span class="st">&quot;{}, &quot;</span>, c);
  }
  
  <span class="pp">println!</span>(<span class="st">&quot;&quot;</span>);</code></pre></div>
  <p>This prints:</p>
  <pre class="text"><code>229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
  Âø†, Áä¨, „Éè, „ÉÅ, ÂÖ¨, </code></pre>
  <p>As you can see, there are more bytes than <code>char</code>s.</p>
  <p>You can get something similar to an index like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = hachiko.chars().nth(<span class="dv">1</span>); <span class="co">// kinda like hachiko[1]</span></code></pre></div>
  <p>This emphasizes that we have to walk from the beginning of the list of <code>chars</code>.</p>
  </section>
  <section id="slicing" class="level4">
  <h4>Slicing</h4>
  <p>You can get a slice of a string with slicing syntax:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = <span class="st">&quot;hachiko&quot;</span>;
  <span class="kw">let</span> hachi = &amp;dog[<span class="dv">0.</span>.<span class="dv">5</span>];</code></pre></div>
  <p>But note that these are <em>byte</em> offsets, not <em>character</em> offsets. So this will fail at runtime:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = <span class="st">&quot;Âø†Áä¨„Éè„ÉÅÂÖ¨&quot;</span>;
  <span class="kw">let</span> hachi = &amp;dog[<span class="dv">0.</span>.<span class="dv">2</span>];</code></pre></div>
  <p>with this error:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'index 0 and/or 2 in `Âø†Áä¨„Éè„ÉÅÂÖ¨` do not lie on
  character boundary'</code></pre>
  </section>
  <section id="concatenation" class="level4">
  <h4>Concatenation</h4>
  <p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>;
  
  <span class="kw">let</span> hello_world = hello + world;</code></pre></div>
  <p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>.to_string();
  
  <span class="kw">let</span> hello_world = hello + &amp;world;</code></pre></div>
  <p>This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a feature called ‚Äò<a href="#sec--deref-coercions"><code>Deref</code> coercions</a>‚Äô.</p>
  </section>
  </section>
  <section id="sec--generics" class="level2">
  <h2>Generics</h2>
  <p>Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics. Generics are called ‚Äòparametric polymorphism‚Äô in type theory, which means that they are types or functions that have multiple forms (‚Äòpoly‚Äô is multiple, ‚Äòmorph‚Äô is form) over a given parameter (‚Äòparametric‚Äô).</p>
  <p>Anyway, enough type theory, let‚Äôs check out some generic code. Rust‚Äôs standard library provides a type, <code>Option&lt;T&gt;</code>, that‚Äôs generic:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; {
      <span class="cn">Some</span>(T),
      <span class="cn">None</span>,
  }</code></pre></div>
  <p>The <code>&lt;T&gt;</code> part, which you‚Äôve seen a few times before, indicates that this is a generic data type. Inside the declaration of our <code>enum</code>, wherever we see a <code>T</code>, we substitute that type for the same type used in the generic. Here‚Äôs an example of using <code>Option&lt;T&gt;</code>, with some extra type annotations:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);</code></pre></div>
  <p>In the type declaration, we say <code>Option&lt;i32&gt;</code>. Note how similar this looks to <code>Option&lt;T&gt;</code>. So, in this particular <code>Option</code>, <code>T</code> has the value of <code>i32</code>. On the right-hand side of the binding, we make a <code>Some(T)</code>, where <code>T</code> is <code>5</code>. Since that‚Äôs an <code>i32</code>, the two sides match, and Rust is happy. If they didn‚Äôt match, we‚Äôd get an error:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);
  <span class="co">// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,</span>
  <span class="co">// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)</span></code></pre></div>
  <p>That doesn‚Äôt mean we can‚Äôt make <code>Option&lt;T&gt;</code>s that hold an <code>f64</code>! They just have to match up:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">5</span>);
  <span class="kw">let</span> y: <span class="dt">Option</span>&lt;<span class="dt">f64</span>&gt; = <span class="cn">Some</span>(<span class="dv">5.0f64</span>);</code></pre></div>
  <p>This is just fine. One definition, multiple uses.</p>
  <p>Generics don‚Äôt have to only be generic over one type. Consider another type from Rust‚Äôs standard library that‚Äôs similar, <code>Result&lt;T, E&gt;</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; {
      <span class="cn">Ok</span>(T),
      <span class="cn">Err</span>(E),
  }</code></pre></div>
  <p>This type is generic over <em>two</em> types: <code>T</code> and <code>E</code>. By the way, the capital letters can be any letter you‚Äôd like. We could define <code>Result&lt;T, E&gt;</code> as:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Result</span>&lt;A, Z&gt; {
      <span class="cn">Ok</span>(A),
      <span class="cn">Err</span>(Z),
  }</code></pre></div>
  <p>if we wanted to. Convention says that the first generic parameter should be <code>T</code>, for ‚Äòtype‚Äô, and that we use <code>E</code> for ‚Äòerror‚Äô. Rust doesn‚Äôt care, however.</p>
  <p>The <code>Result&lt;T, E&gt;</code> type is intended to be used to return the result of a computation, and to have the ability to return an error if it didn‚Äôt work out.</p>
  <section id="generic-functions" class="level4">
  <h4>Generic functions</h4>
  <p>We can write functions that take generic types with a similar syntax:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_anything&lt;T&gt;(x: T) {
      <span class="co">// do something with x</span>
  }</code></pre></div>
  <p>The syntax has two parts: the <code>&lt;T&gt;</code> says ‚Äúthis function is generic over one type, <code>T</code>‚Äù, and the <code>x: T</code> says ‚Äúx has the type <code>T</code>.‚Äù</p>
  <p>Multiple arguments can have the same generic type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
      <span class="co">// ...</span>
  }</code></pre></div>
  <p>We could write a version that takes multiple types:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_things&lt;T, U&gt;(x: T, y: U) {
      <span class="co">// ...</span>
  }</code></pre></div>
  </section>
  <section id="generic-structs" class="level4">
  <h4>Generic structs</h4>
  <p>You can store a generic type in a <code>struct</code> as well:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point&lt;T&gt; {
      x: T,
      y: T,
  }
  
  <span class="kw">let</span> int_origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  <span class="kw">let</span> float_origin = Point { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span> };</code></pre></div>
  <p>Similar to functions, the <code>&lt;T&gt;</code> is where we declare the generic parameters, and we then use <code>x: T</code> in the type declaration, too.</p>
  <p>When you want to add an implementation for the generic <code>struct</code>, you just declare the type parameter after the <code>impl</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T&gt; Point&lt;T&gt; {
      <span class="kw">fn</span> swap(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          std::mem::swap(&amp;<span class="kw">mut</span> <span class="kw">self</span>.x, &amp;<span class="kw">mut</span> <span class="kw">self</span>.y);
      }
  }</code></pre></div>
  <p>So far you‚Äôve seen generics that take absolutely any type. These are useful in many cases: you‚Äôve already seen <code>Option&lt;T&gt;</code>, and later you‚Äôll meet universal container types like <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>. On the other hand, often you want to trade that flexibility for increased expressive power. Read about <a href="#sec--traits">trait bounds</a> to see why and how.</p>
  </section>
  </section>
  <section id="sec--traits" class="level2">
  <h2>Traits</h2>
  <p>A trait is a language feature that tells the Rust compiler about functionality a type must provide.</p>
  <p>Do you remember the <code>impl</code> keyword, used to call a function with <a href="#sec--method-syntax">method syntax</a>?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>Traits are similar, except that we define a trait with just the method signature, then implement the trait for that struct. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre></div>
  <p>As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block, but we don‚Äôt define a body, just a type signature. When we <code>impl</code> a trait, we use <code>impl Trait for Item</code>, rather than just <code>impl Item</code>.</p>
  <section id="traits-bounds-for-generic-functions" class="level4">
  <h4>Traits bounds for generic functions</h4>
  <p>Traits are useful because they allow a type to make certain promises about its behavior. Generic functions can exploit this to constrain the types they accept. Consider this function, which does not compile:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre></div>
  <p>Rust complains:</p>
  <pre class="text"><code>error: no method named `area` found for type `T` in the current scope</code></pre>
  <p>Because <code>T</code> can be any type, we can‚Äôt be sure that it implements the <code>area</code> method. But we can add a ‚Äòtrait constraint‚Äô to our generic <code>T</code>, ensuring that it does:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre></div>
  <p>The syntax <code>&lt;T: HasArea&gt;</code> means ‚Äúany type that implements the <code>HasArea</code> trait.‚Äù Because traits define function type signatures, we can be sure that any type which implements <code>HasArea</code> will have an <code>.area()</code> method.</p>
  <p>Here‚Äôs an extended example of how this works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">struct</span> Circle {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      radius: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          std::<span class="dt">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">struct</span> Square {
      x: <span class="dt">f64</span>,
      y: <span class="dt">f64</span>,
      side: <span class="dt">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Square {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          <span class="kw">self</span>.side * <span class="kw">self</span>.side
      }
  }
  
  <span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="pp">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          radius: <span class="dv">1.0f64</span>,
      };
  
      <span class="kw">let</span> s = Square {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          side: <span class="dv">1.0f64</span>,
      };
  
      print_area(c);
      print_area(s);
  }</code></pre></div>
  <p>This program outputs:</p>
  <pre class="text"><code>This shape has an area of 3.141593
  This shape has an area of 1</code></pre>
  <p>As you can see, <code>print_area</code> is now generic, but also ensures that we have passed in the correct types. If we pass in an incorrect type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">print_area(<span class="dv">5</span>);</code></pre></div>
  <p>We get a compile-time error:</p>
  <pre class="text"><code>error: the trait `HasArea` is not implemented for the type `_` [E0277]</code></pre>
  </section>
  <section id="traits-bounds-for-generic-structs" class="level4">
  <h4>Traits bounds for generic structs</h4>
  <p>Your generic structs can also benefit from trait constraints. All you need to do is append the constraint when you declare type parameters. Here is a new type <code>Rectangle&lt;T&gt;</code> and its operation <code>is_square()</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Rectangle&lt;T&gt; {
      x: T,
      y: T,
      width: T,
      height: T,
  }
  
  <span class="kw">impl</span>&lt;T: <span class="bu">PartialEq</span>&gt; Rectangle&lt;T&gt; {
      <span class="kw">fn</span> is_square(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> {
          <span class="kw">self</span>.width == <span class="kw">self</span>.height
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> r = Rectangle {
          x: <span class="dv">0</span>,
          y: <span class="dv">0</span>,
          width: <span class="dv">47</span>,
          height: <span class="dv">47</span>,
      };
  
      <span class="pp">assert!</span>(r.is_square());
  
      r.height = <span class="dv">42</span>;
      <span class="pp">assert!</span>(!r.is_square());
  }</code></pre></div>
  <p><code>is_square()</code> needs to check that the sides are equal, so the sides must be of a type that implements the <a href="http://doc.rust-lang.org/core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> trait:</p>
  <pre class="ignore"><code>impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }</code></pre>
  <p>Now, a rectangle can be defined in terms of any type that can be compared for equality.</p>
  <p>Here we defined a new struct <code>Rectangle</code> that accepts numbers of any precision‚Äîreally, objects of pretty much any type‚Äîas long as they can be compared for equality. Could we do the same for our <code>HasArea</code> structs, <code>Square</code> and <code>Circle</code>? Yes, but they need multiplication, and to work with that we need to know more about <a href="#sec--operators-and-overloading">operator traits</a>.</p>
  </section>
  <section id="rules-for-implementing-traits" class="level3">
  <h3>Rules for implementing traits</h3>
  <p>So far, we‚Äôve only added trait implementations to structs, but you can implement a trait for any type. So technically, we <em>could</em> implement <code>HasArea</code> for <code>i32</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> <span class="dt">i32</span> {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="dt">f64</span> {
          <span class="pp">println!</span>(<span class="st">&quot;this is silly&quot;</span>);
  
          *<span class="kw">self</span> <span class="kw">as</span> <span class="dt">f64</span>
      }
  }
  
  <span class="dv">5.</span>area();</code></pre></div>
  <p>It is considered poor style to implement methods on such primitive types, even though it is possible.</p>
  <p>This may seem like the Wild West, but there are two restrictions around implementing traits that prevent this from getting out of hand. The first is that if the trait isn‚Äôt defined in your scope, it doesn‚Äôt apply. Here‚Äôs an example: the standard library provides a <a href="http://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> trait which adds extra functionality to <code>File</code>s, for doing file I/O. By default, a <code>File</code> won‚Äôt have its methods:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Couldn‚Äôt open foo.txt&quot;</span>);
  <span class="kw">let</span> buf = b<span class="st">&quot;whatever&quot;</span>; <span class="co">// byte string literal. buf: &amp;[u8; 8]</span>
  <span class="kw">let</span> result = f.write(buf);</code></pre></div>
  <p>Here‚Äôs the error:</p>
  <pre class="text"><code>error: type `std::fs::File` does not implement any method in scope named `write`
  let result = f.write(buf);
                 ^~~~~~~~~~</code></pre>
  <p>We need to <code>use</code> the <code>Write</code> trait first:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::Write;
  
  <span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Couldn‚Äôt open foo.txt&quot;</span>);
  <span class="kw">let</span> buf = b<span class="st">&quot;whatever&quot;</span>;
  <span class="kw">let</span> result = f.write(buf);</code></pre></div>
  <p>This will compile without error.</p>
  <p>This means that even if someone does something bad like add methods to <code>i32</code>, it won‚Äôt affect you, unless you <code>use</code> that trait.</p>
  <p>There‚Äôs one more restriction on implementing traits: either the trait, or the type you‚Äôre writing the <code>impl</code> for, must be defined by you. So, we could implement the <code>HasArea</code> type for <code>i32</code>, because <code>HasArea</code> is in our code. But if we tried to implement <code>ToString</code>, a trait provided by Rust, for <code>i32</code>, we could not, because neither the trait nor the type are in our code.</p>
  <p>One last thing about traits: generic functions with a trait bound use ‚Äòmonomorphization‚Äô (mono: one, morph: form), so they are statically dispatched. What‚Äôs that mean? Check out the chapter on <a href="#sec--trait-objects">trait objects</a> for more details.</p>
  </section>
  <section id="multiple-trait-bounds" class="level3">
  <h3>Multiple trait bounds</h3>
  <p>You‚Äôve seen that you can bound a generic type parameter with a trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span>&gt;(x: T) {
      x.clone();
  }</code></pre></div>
  <p>If you need more than one bound, you can use <code>+</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::<span class="bu">Debug</span>;
  
  <span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span> + <span class="bu">Debug</span>&gt;(x: T) {
      x.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, x);
  }</code></pre></div>
  <p><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code>.</p>
  </section>
  <section id="where-clause" class="level3">
  <h3>Where clause</h3>
  <p>Writing functions with only a few generic types and a small number of trait bounds isn‚Äôt too bad, but as the number increases, the syntax gets increasingly awkward:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::<span class="bu">Debug</span>;
  
  <span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span>, K: <span class="bu">Clone</span> + <span class="bu">Debug</span>&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }</code></pre></div>
  <p>The name of the function is on the far left, and the parameter list is on the far right. The bounds are getting in the way.</p>
  <p>Rust has a solution, and it‚Äôs called a ‚Äò<code>where</code> clause‚Äô:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::<span class="bu">Debug</span>;
  
  <span class="kw">fn</span> foo&lt;T: <span class="bu">Clone</span>, K: <span class="bu">Clone</span> + <span class="bu">Debug</span>&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }
  
  <span class="kw">fn</span> bar&lt;T, K&gt;(x: T, y: K) <span class="kw">where</span> T: <span class="bu">Clone</span>, K: <span class="bu">Clone</span> + <span class="bu">Debug</span> {
      x.clone();
      y.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }
  
  <span class="kw">fn</span> main() {
      foo(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
      bar(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre></div>
  <p><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause. All you need to do is leave off the bounds when defining your type parameters, and then add <code>where</code> after the parameter list. For longer lists, whitespace can be added:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::<span class="bu">Debug</span>;
  
  <span class="kw">fn</span> bar&lt;T, K&gt;(x: T, y: K)
      <span class="kw">where</span> T: <span class="bu">Clone</span>,
            K: <span class="bu">Clone</span> + <span class="bu">Debug</span> {
  
      x.clone();
      y.clone();
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }</code></pre></div>
  <p>This flexibility can add clarity in complex situations.</p>
  <p><code>where</code> is also more powerful than the simpler syntax. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> ConvertTo&lt;Output&gt; {
      <span class="kw">fn</span> convert(&amp;<span class="kw">self</span>) -&gt; Output;
  }
  
  <span class="kw">impl</span> ConvertTo&lt;<span class="dt">i64</span>&gt; <span class="kw">for</span> <span class="dt">i32</span> {
      <span class="kw">fn</span> convert(&amp;<span class="kw">self</span>) -&gt; <span class="dt">i64</span> { *<span class="kw">self</span> <span class="kw">as</span> <span class="dt">i64</span> }
  }
  
  <span class="co">// can be called with T == i32</span>
  <span class="kw">fn</span> normal&lt;T: ConvertTo&lt;<span class="dt">i64</span>&gt;&gt;(x: &amp;T) -&gt; <span class="dt">i64</span> {
      x.convert()
  }
  
  <span class="co">// can be called with T == i64</span>
  <span class="kw">fn</span> inverse&lt;T&gt;() -&gt; T
          <span class="co">// this is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;</span>
          <span class="kw">where</span> <span class="dt">i32</span>: ConvertTo&lt;T&gt; {
      <span class="dv">42.</span>convert()
  }</code></pre></div>
  <p>This shows off the additional feature of <code>where</code> clauses: they allow bounds where the left-hand side is an arbitrary type (<code>i32</code> in this case), not just a plain type parameter (like <code>T</code>).</p>
  </section>
  <section id="default-methods" class="level3">
  <h3>Default methods</h3>
  <p>If you already know how a typical implementor will define a method, you can let your trait supply a default:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span>;
  
      <span class="kw">fn</span> is_invalid(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> { !<span class="kw">self</span>.is_valid() }
  }</code></pre></div>
  <p>Implementors of the <code>Foo</code> trait need to implement <code>is_valid()</code>, but they don‚Äôt need to implement <code>is_invalid()</code>. They‚Äôll get this default behavior. They can override the default if they so choose:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> UseDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> UseDefault {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Called UseDefault.is_valid.&quot;</span>);
          <span class="cn">true</span>
      }
  }
  
  <span class="kw">struct</span> OverrideDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> OverrideDefault {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Called OverrideDefault.is_valid.&quot;</span>);
          <span class="cn">true</span>
      }
  
      <span class="kw">fn</span> is_invalid(&amp;<span class="kw">self</span>) -&gt; <span class="dt">bool</span> {
          <span class="pp">println!</span>(<span class="st">&quot;Called OverrideDefault.is_invalid!&quot;</span>);
          <span class="cn">true</span> <span class="co">// this implementation is a self-contradiction!</span>
      }
  }
  
  <span class="kw">let</span> default = UseDefault;
  <span class="pp">assert!</span>(!default.is_invalid()); <span class="co">// prints &quot;Called UseDefault.is_valid.&quot;</span>
  
  <span class="kw">let</span> over = OverrideDefault;
  <span class="pp">assert!</span>(over.is_invalid()); <span class="co">// prints &quot;Called OverrideDefault.is_invalid!&quot;</span></code></pre></div>
  </section>
  <section id="inheritance" class="level3">
  <h3>Inheritance</h3>
  <p>Sometimes, implementing a trait requires implementing another trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> FooBar : Foo {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>);
  }</code></pre></div>
  <p>Implementors of <code>FooBar</code> must also implement <code>Foo</code>, like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> FooBar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;foobar&quot;</span>); }
  }</code></pre></div>
  <p>If we forget to implement <code>Foo</code>, Rust will tell us:</p>
  <pre class="text"><code>error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]</code></pre>
  </section>
  </section>
  <section id="sec--drop" class="level2">
  <h2>Drop</h2>
  <p>Now that we‚Äôve discussed traits, let‚Äôs talk about a particular trait provided by the Rust standard library, <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>. The <code>Drop</code> trait provides a way to run some code when a value goes out of scope. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HasDrop;
  
  <span class="kw">impl</span> <span class="bu">Drop</span> <span class="kw">for</span> HasDrop {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;Dropping!&quot;</span>);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = HasDrop;
  
      <span class="co">// do stuff</span>
  
  } <span class="co">// x goes out of scope here</span></code></pre></div>
  <p>When <code>x</code> goes out of scope at the end of <code>main()</code>, the code for <code>Drop</code> will run. <code>Drop</code> has one method, which is also called <code>drop()</code>. It takes a mutable reference to <code>self</code>.</p>
  <p>That‚Äôs it! The mechanics of <code>Drop</code> are very simple, but there are some subtleties. For example, values are dropped in the opposite order they are declared. Here‚Äôs another example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Firework {
      strength: <span class="dt">i32</span>,
  }
  
  <span class="kw">impl</span> <span class="bu">Drop</span> <span class="kw">for</span> Firework {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;BOOM times {}!!!&quot;</span>, <span class="kw">self</span>.strength);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> firecracker = Firework { strength: <span class="dv">1</span> };
      <span class="kw">let</span> tnt = Firework { strength: <span class="dv">100</span> };
  }</code></pre></div>
  <p>This will output:</p>
  <pre class="text"><code>BOOM times 100!!!
  BOOM times 1!!!</code></pre>
  <p>The TNT goes off before the firecracker does, because it was declared afterwards. Last in, first out.</p>
  <p>So what is <code>Drop</code> good for? Generally, <code>Drop</code> is used to clean up any resources associated with a <code>struct</code>. For example, the <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code> type</a> is a reference-counted type. When <code>Drop</code> is called, it will decrement the reference count, and if the total number of references is zero, will clean up the underlying value.</p>
  </section>
  <section id="sec--if-let" class="level2">
  <h2>if let</h2>
  <p><code>if let</code> allows you to combine <code>if</code> and <code>let</code> together to reduce the overhead of certain kinds of pattern matches.</p>
  <p>For example, let‚Äôs say we have some sort of <code>Option&lt;T&gt;</code>. We want to call a function on it if it‚Äôs <code>Some&lt;T&gt;</code>, but do nothing if it‚Äôs <code>None</code>. That looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> option {
      <span class="cn">Some</span>(x) =&gt; { foo(x) },
      <span class="cn">None</span> =&gt; {},
  }</code></pre></div>
  <p>We don‚Äôt have to use <code>match</code> here, for example, we could use <code>if</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> option.is_some() {
      <span class="kw">let</span> x = option.unwrap();
      foo(x);
  }</code></pre></div>
  <p>Neither of these options is particularly appealing. We can use <code>if let</code> to do the same thing in a nicer way:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      foo(x);
  }</code></pre></div>
  <p>If a <a href="#sec--patterns">pattern</a> matches successfully, it binds any appropriate parts of the value to the identifiers in the pattern, then evaluates the expression. If the pattern doesn‚Äôt match, nothing happens.</p>
  <p>If you‚Äôd rather to do something else when the pattern does not match, you can use <code>else</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      foo(x);
  } <span class="kw">else</span> {
      bar();
  }</code></pre></div>
  <section id="while-let" class="level4">
  <h4><code>while let</code></h4>
  <p>In a similar fashion, <code>while let</code> can be used when you want to conditionally loop as long as a value matches a certain pattern. It turns code like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
      <span class="kw">match</span> option {
          <span class="cn">Some</span>(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
          _ =&gt; <span class="kw">break</span>,
      }
  }</code></pre></div>
  <p>Into code like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="kw">let</span> <span class="cn">Some</span>(x) = option {
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  </section>
  </section>
  <section id="sec--trait-objects" class="level2">
  <h2>Trait Objects</h2>
  <p>When code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run. This is called ‚Äòdispatch‚Äô. There are two major forms of dispatch: static dispatch and dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects‚Äô.</p>
  <section id="background" class="level4">
  <h4>Background</h4>
  <p>For the rest of this chapter, we‚Äôll need a trait and some implementations. Let‚Äôs make a simple one, <code>Foo</code>. It has one method that is expected to return a <code>String</code>.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span>;
  }</code></pre></div>
  <p>We‚Äôll also implement this trait for <code>u8</code> and <code>String</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">u8</span> {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span> { <span class="pp">format!</span>(<span class="st">&quot;u8: {}&quot;</span>, *<span class="kw">self</span>) }
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">String</span> {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; <span class="dt">String</span> { <span class="pp">format!</span>(<span class="st">&quot;string: {}&quot;</span>, *<span class="kw">self</span>) }
  }</code></pre></div>
  </section>
  <section id="static-dispatch" class="level4">
  <h4>Static dispatch</h4>
  <p>We can use this trait to perform static dispatch with trait bounds:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something&lt;T: Foo&gt;(x: T) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something(x);
      do_something(y);
  }</code></pre></div>
  <p>Rust uses ‚Äòmonomorphization‚Äô to perform static dispatch here. This means that Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and <code>String</code>, and then replace the call sites with calls to these specialized functions. In other words, Rust generates something like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something_u8(x: <span class="dt">u8</span>) {
      x.method();
  }
  
  <span class="kw">fn</span> do_something_string(x: <span class="dt">String</span>) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something_u8(x);
      do_something_string(y);
  }</code></pre></div>
  <p>This has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization. Static dispatch is fast, but it comes at a tradeoff: ‚Äòcode bloat‚Äô, due to many copies of the same function existing in the binary, one for each type.</p>
  <p>Furthermore, compilers aren‚Äôt perfect and may ‚Äúoptimize‚Äù code to become slower. For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us). This is part of the reason that <code>#[inline]</code> and <code>#[inline(always)]</code> should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.</p>
  <p>However, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible. The standard library tries to be statically dispatched where possible for this reason.</p>
  </section>
  <section id="dynamic-dispatch" class="level4">
  <h4>Dynamic dispatch</h4>
  <p>Rust provides dynamic dispatch through a feature called ‚Äòtrait objects‚Äô. Trait objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store a value of <em>any</em> type that implements the given trait, where the precise type can only be known at runtime.</p>
  <p>A trait object can be obtained from a pointer to a concrete type that implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo</code>) or <em>coercing</em> it (e.g.¬†using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code>).</p>
  <p>These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that‚Äôs all at the moment. Coercions and casts are identical.</p>
  <p>This operation can be seen as ‚Äòerasing‚Äô the compiler‚Äôs knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as ‚Äòtype erasure‚Äô.</p>
  <p>Coming back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      do_something(&amp;x <span class="kw">as</span> &amp;Foo);
  }</code></pre></div>
  <p>or by coercing:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="st">&quot;Hello&quot;</span>.to_string();
      do_something(&amp;x);
  }</code></pre></div>
  <p>A function that takes a trait object is not specialized to each of the types that implements <code>Foo</code>: only one copy is generated, often (but not always) resulting in less code bloat. However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.</p>
  <section id="why-pointers" class="level5">
  <h5>Why pointers?</h5>
  <p>Rust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes. Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.</p>
  <p>For <code>Foo</code>, we would need to have a value that could be at least either a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which dependent crates may implement <code>Foo</code> (any number of bytes at all). There‚Äôs no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.</p>
  <p>Putting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.</p>
  </section>
  <section id="representation" class="level5">
  <h5>Representation</h5>
  <p>The methods of the trait can be called on a trait object via a special record of function pointers traditionally called a ‚Äòvtable‚Äô (created and managed by the compiler).</p>
  <p>Trait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.</p>
  <p>Let‚Äôs start simple, with the runtime representation of a trait object. The <code>std::raw</code> module contains structs with layouts that are the same as the complicated built-in types, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">including trait objects</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> TraitObject {
      <span class="kw">pub</span> data: *<span class="kw">mut</span> (),
      <span class="kw">pub</span> vtable: *<span class="kw">mut</span> (),
  }</code></pre></div>
  <p>That is, a trait object like <code>&amp;Foo</code> consists of a ‚Äòdata‚Äô pointer and a ‚Äòvtable‚Äô pointer.</p>
  <p>The data pointer addresses the data (of some unknown type <code>T</code>) that the trait object is storing, and the vtable pointer points to the vtable (‚Äòvirtual method table‚Äô) corresponding to the implementation of <code>Foo</code> for <code>T</code>.</p>
  <p>A vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation. A method call like <code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and then do a dynamic call of it. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> FooVtable {
      destructor: <span class="kw">fn</span>(*<span class="kw">mut</span> ()),
      size: <span class="dt">usize</span>,
      align: <span class="dt">usize</span>,
      method: <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  }
  
  <span class="co">// u8:</span>
  
  <span class="kw">fn</span> call_method_on_u8(x: *<span class="kw">const</span> ()) -&gt; <span class="dt">String</span> {
      <span class="co">// the compiler guarantees that this function is only called</span>
      <span class="co">// with `x` pointing to a u8</span>
      <span class="kw">let</span> byte: &amp;<span class="dt">u8</span> = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u8</span>) };
  
      byte.method()
  }
  
  <span class="kw">static</span> Foo_for_u8_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* compiler magic */</span>,
      size: <span class="dv">1</span>,
      align: <span class="dv">1</span>,
  
      <span class="co">// cast to a function pointer</span>
      method: call_method_on_u8 <span class="kw">as</span> <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  };
  
  
  <span class="co">// String:</span>
  
  <span class="kw">fn</span> call_method_on_String(x: *<span class="kw">const</span> ()) -&gt; <span class="dt">String</span> {
      <span class="co">// the compiler guarantees that this function is only called</span>
      <span class="co">// with `x` pointing to a String</span>
      <span class="kw">let</span> string: &amp;<span class="dt">String</span> = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">String</span>) };
  
      string.method()
  }
  
  <span class="kw">static</span> Foo_for_String_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* compiler magic */</span>,
      <span class="co">// values for a 64-bit computer, halve them for 32-bit ones</span>
      size: <span class="dv">24</span>,
      align: <span class="dv">8</span>,
  
      method: call_method_on_String <span class="kw">as</span> <span class="kw">fn</span>(*<span class="kw">const</span> ()) -&gt; <span class="dt">String</span>,
  };</code></pre></div>
  <p>The <code>destructor</code> field in each vtable points to a function that will clean up any resources of the vtable‚Äôs type: for <code>u8</code> it is trivial, but for <code>String</code> it will free the memory. This is necessary for owning trait objects like <code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code> allocation as well as the internal type when they go out of scope. The <code>size</code> and <code>align</code> fields store the size of the erased type, and its alignment requirements; these are essentially unused at the moment since the information is embedded in the destructor, but will be used in the future, as trait objects are progressively made more flexible.</p>
  <p>Suppose we‚Äôve got some values that implement <code>Foo</code>. The explicit form of construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the type mismatches: they‚Äôre all just pointers anyway):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a: <span class="dt">String</span> = <span class="st">&quot;foo&quot;</span>.to_string();
  <span class="kw">let</span> x: <span class="dt">u8</span> = <span class="dv">1</span>;
  
  <span class="co">// let b: &amp;Foo = &amp;a;</span>
  <span class="kw">let</span> b = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;a,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_String_vtable
  };
  
  <span class="co">// let y: &amp;Foo = x;</span>
  <span class="kw">let</span> y = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;x,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_u8_vtable
  };
  
  <span class="co">// b.method();</span>
  (b.vtable.method)(b.data);
  
  <span class="co">// y.method();</span>
  (y.vtable.method)(y.data);</code></pre></div>
  </section>
  </section>
  <section id="object-safety" class="level4">
  <h4>Object Safety</h4>
  <p>Not every trait can be used to make a trait object. For example, vectors implement <code>Clone</code>, but if we try to make a trait object:</p>
  <pre class="ignore"><code>let v = vec![1, 2, 3];
  let o = &amp;v as &amp;Clone;</code></pre>
  <p>We get an error:</p>
  <pre class="text"><code>error: cannot convert to a trait object because trait `core::clone::Clone` is not obje
  ‚Ü≥ ct-safe [E0038]
  let o = &amp;v as &amp;Clone;
          ^~
  note: the trait cannot require that `Self : Sized`
  let o = &amp;v as &amp;Clone;
          ^~</code></pre>
  <p>The error says that <code>Clone</code> is not ‚Äòobject-safe‚Äô. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true:</p>
  <ul>
  <li>the trait does not require that <code>Self: Sized</code></li>
  <li>all of its methods are object-safe</li>
  </ul>
  <p>So what makes a method object-safe? Each method must require that <code>Self: Sized</code> or all of the following:</p>
  <ul>
  <li>must not have any type parameters</li>
  <li>must not use <code>Self</code></li>
  </ul>
  <p>Whew! As we can see, almost all of these rules talk about <code>Self</code>. A good intuition is ‚Äúexcept in special circumstances, if your trait‚Äôs method uses <code>Self</code>, it is not object-safe.‚Äù</p>
  </section>
  </section>
  <section id="sec--closures" class="level2">
  <h2>Closures</h2>
  <p>Rust not only has named functions, but anonymous functions as well. Anonymous functions that have an associated environment are called ‚Äòclosures‚Äô, because they close over an environment. Rust has a really great implementation of them, as we‚Äôll see.</p>
  <section id="syntax" class="level3">
  <h3>Syntax</h3>
  <p>Closures look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="dt">i32</span>| x + <span class="dv">1</span>;
  
  <span class="pp">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre></div>
  <p>We create a binding, <code>plus_one</code>, and assign it to a closure. The closure‚Äôs arguments go between the pipes (<code>|</code>), and the body is an expression, in this case, <code>x + 1</code>. Remember that <code>{ }</code> is an expression, so we can have multi-line closures too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_two = |x| {
      <span class="kw">let</span> <span class="kw">mut</span> result: <span class="dt">i32</span> = x;
  
      result += <span class="dv">1</span>;
      result += <span class="dv">1</span>;
  
      result
  };
  
  <span class="pp">assert_eq!</span>(<span class="dv">4</span>, plus_two(<span class="dv">2</span>));</code></pre></div>
  <p>You‚Äôll notice a few things about closures that are a bit different from regular functions defined with <code>fn</code>. The first is that we did not need to annotate the types of arguments the closure takes or the values it returns. We can:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="dt">i32</span>| -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> };
  
  <span class="pp">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre></div>
  <p>But we don‚Äôt have to. Why is this? Basically, it was chosen for ergonomic reasons. While specifying the full type for named functions is helpful with things like documentation and type inference, the types of closures are rarely documented since they‚Äôre anonymous, and they don‚Äôt cause the kinds of error-at-a-distance problems that inferring named function types can.</p>
  <p>The second is that the syntax is similar, but a bit different. I‚Äôve added spaces here for easier comparison:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span>  plus_one_v1   (x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> }
  <span class="kw">let</span> plus_one_v2 = |x: <span class="dt">i32</span>| -&gt; <span class="dt">i32</span> { x + <span class="dv">1</span> };
  <span class="kw">let</span> plus_one_v3 = |x: <span class="dt">i32</span>|          x + <span class="dv">1</span>  ;</code></pre></div>
  <p>Small differences, but they‚Äôre similar.</p>
  </section>
  <section id="closures-and-their-environment" class="level3">
  <h3>Closures and their environment</h3>
  <p>Closures are called such because they ‚Äòclose over their environment‚Äô. It looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  <span class="pp">assert_eq!</span>(<span class="dv">10</span>, plus_num(<span class="dv">5</span>));</code></pre></div>
  <p>This closure, <code>plus_num</code>, refers to a <code>let</code> binding in its scope: <code>num</code>. More specifically, it borrows the binding. If we do something that would conflict with that binding, we get an error. Like this one:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre></div>
  <p>Which errors with:</p>
  <pre class="text"><code>error: cannot borrow `num` as mutable because it is also borrowed as immutable
      let y = &amp;mut num;
                   ^~~
  note: previous borrow of `num` occurs here due to use in closure; the immutable
    borrow prevents subsequent moves or mutable borrows of `num` until the borrow
    ends
      let plus_num = |x| x + num;
                     ^~~~~~~~~~~
  note: previous borrow ends here
  fn main() {
      let mut num = 5;
      let plus_num = |x| x + num;
  
      let y = &amp;mut num;
  }
  ^</code></pre>
  <p>A verbose yet helpful error message! As it says, we can‚Äôt take a mutable borrow on <code>num</code> because the closure is already borrowing it. If we let the closure go out of scope, we can:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  {
      <span class="kw">let</span> plus_num = |x: <span class="dt">i32</span>| x + num;
  
  } <span class="co">// plus_num goes out of scope, borrow of num ends</span>
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre></div>
  <p>If your closure requires it, however, Rust will take ownership and move the environment instead. This doesn‚Äôt work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> takes_nums = || nums;
  
  <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, nums);</code></pre></div>
  <p>We get this error:</p>
  <pre class="text"><code>note: `nums` moved into closure environment here because it has type
    `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
  let takes_nums = || nums;
                   ^~~~~~~</code></pre>
  <p><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of <code>nums</code>. It‚Äôs the same as if we‚Äôd passed <code>nums</code> to a function that took ownership of it.</p>
  <section id="move-closures" class="level4">
  <h4><code>move</code> closures</h4>
  <p>We can force our closure to take ownership of its environment with the <code>move</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  
  <span class="kw">let</span> owns_num = <span class="kw">move</span> |x: <span class="dt">i32</span>| x + num;</code></pre></div>
  <p>Now, even though the keyword is <code>move</code>, the variables follow normal move semantics. In this case, <code>5</code> implements <code>Copy</code>, and so <code>owns_num</code> takes ownership of a copy of <code>num</code>. So what‚Äôs the difference?</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> add_num = |x: <span class="dt">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="pp">assert_eq!</span>(<span class="dv">10</span>, num);</code></pre></div>
  <p>So in this case, our closure took a mutable reference to <code>num</code>, and then when we called <code>add_num</code>, it mutated the underlying value, as we‚Äôd expect. We also needed to declare <code>add_num</code> as <code>mut</code> too, because we‚Äôre mutating its environment.</p>
  <p>If we change to a <code>move</code> closure, it‚Äôs different:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> add_num = <span class="kw">move</span> |x: <span class="dt">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, num);</code></pre></div>
  <p>We only get <code>5</code>. Rather than taking a mutable borrow out on our <code>num</code>, we took ownership of a copy.</p>
  <p>Another way to think about <code>move</code> closures: they give a closure its own stack frame. Without <code>move</code>, a closure may be tied to the stack frame that created it, while a <code>move</code> closure is self-contained. This means that you cannot generally return a non-<code>move</code> closure from a function, for example.</p>
  <p>But before we talk about taking and returning closures, we should talk some more about the way that closures are implemented. As a systems language, Rust gives you tons of control over what your code does, and closures are no different.</p>
  </section>
  </section>
  <section id="closure-implementation" class="level3">
  <h3>Closure implementation</h3>
  <p>Rust‚Äôs implementation of closures is a bit different than other languages. They are effectively syntax sugar for traits. You‚Äôll want to make sure to have read the <a href="#sec--traits">traits chapter</a> before this one, as well as the chapter on <a href="#sec--trait-objects">trait objects</a>.</p>
  <p>Got all that? Good.</p>
  <p>The key to understanding how closures work under the hood is something a bit strange: Using <code>()</code> to call a function, like <code>foo()</code>, is an overloadable operator. From this, everything else clicks into place. In Rust, we use the trait system to overload operators. Calling functions is no different. We have three separate traits to overload with:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">Fn</span>&lt;Args&gt; : <span class="bu">FnMut</span>&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call(&amp;<span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">FnMut</span>&lt;Args&gt; : <span class="bu">FnOnce</span>&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">FnOnce</span>&lt;Args&gt; {
      <span class="kw">type</span> Output;
  
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call_once(<span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }</code></pre></div>
  <p>You‚Äôll notice a few differences between these traits, but a big one is <code>self</code>: <code>Fn</code> takes <code>&amp;self</code>, <code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code> takes <code>self</code>. This covers all three kinds of <code>self</code> via the usual method call syntax. But we‚Äôve split them up into three traits, rather than having a single one. This gives us a large amount of control over what kind of closures we can take.</p>
  <p>The <code>|| {}</code> syntax for closures is sugar for these three traits. Rust will generate a struct for the environment, <code>impl</code> the appropriate trait, and then use it.</p>
  </section>
  <section id="taking-closures-as-arguments" class="level3">
  <h3>Taking closures as arguments</h3>
  <p>Now that we know that closures are traits, we already know how to accept and return closures: just like any other trait!</p>
  <p>This also means that we can choose static vs dynamic dispatch as well. First, let‚Äôs write a function which takes something callable, calls it, and returns the result:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="dt">i32</span>
      <span class="kw">where</span> F : <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
  
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(|x| x + <span class="dv">2</span>);
  
  <span class="pp">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre></div>
  <p>We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</code>. It just does what it suggests: it calls the closure, giving it <code>1</code> as an argument.</p>
  <p>Let‚Äôs examine the signature of <code>call_with_one</code> in more depth:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="dt">i32</span></code></pre></div>
  <p>We take one parameter, and it has the type <code>F</code>. We also return a <code>i32</code>. This part isn‚Äôt interesting. The next part is:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">where</span> F : <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {</code></pre></div>
  <p>Because <code>Fn</code> is a trait, we can bound our generic with it. In this case, our closure takes a <code>i32</code> as an argument and returns an <code>i32</code>, and so the generic bound we use is <code>Fn(i32) -&gt; i32</code>.</p>
  <p>There‚Äôs one other key point here: because we‚Äôre bounding a generic with a trait, this will get monomorphized, and therefore, we‚Äôll be doing static dispatch into the closure. That‚Äôs pretty neat. In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch. In Rust, we can stack allocate our closure environment, and statically dispatch the call. This happens quite often with iterators and their adapters, which often take closures as arguments.</p>
  <p>Of course, if we want dynamic dispatch, we can get that too. A trait object handles this case, as usual:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one(some_closure: &amp;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(&amp;|x| x + <span class="dv">2</span>);
  
  <span class="pp">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre></div>
  <p>Now we take a trait object, a <code>&amp;Fn</code>. And we have to make a reference to our closure when we pass it to <code>call_with_one</code>, so we use <code>&amp;||</code>.</p>
  </section>
  <section id="function-pointers-and-closures" class="level3">
  <h3>Function pointers and closures</h3>
  <p>A function pointer is kind of like a closure that has no environment. As such, you can pass a function pointer to any function expecting a closure argument, and it will work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one(some_closure: &amp;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">fn</span> add_one(i: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      i + <span class="dv">1</span>
  }
  
  <span class="kw">let</span> f = add_one;
  
  <span class="kw">let</span> answer = call_with_one(&amp;f);
  
  <span class="pp">assert_eq!</span>(<span class="dv">2</span>, answer);</code></pre></div>
  <p>In this example, we don‚Äôt strictly need the intermediate variable <code>f</code>, the name of the function works just fine too:</p>
  <pre class="ignore"><code>let answer = call_with_one(&amp;add_one);</code></pre>
  </section>
  <section id="returning-closures" class="level3">
  <h3>Returning closures</h3>
  <p>It‚Äôs very common for functional-style code to return closures in various situations. If you try to return a closure, you may run into an error. At first, it may seem strange, but we‚Äôll figure it out. Here‚Äôs how you‚Äôd probably try to return a closure from a function:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; (<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>This gives us these long, related errors:</p>
  <pre class="text"><code>error: the trait `core::marker::Sized` is not implemented for the type
  `core::ops::Fn(i32) -&gt; i32` [E0277]
  fn factory() -&gt; (Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~
  note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
  fn factory() -&gt; (Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~
  error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(
  ‚Ü≥ i32) -&gt; i32` [E0277]
  let f = factory();
      ^
  note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
  let f = factory();
      ^</code></pre>
  <p>In order to return something from a function, Rust needs to know what size the return type is. But since <code>Fn</code> is a trait, it could be various things of various sizes: many different types can implement <code>Fn</code>. An easy way to give something a size is to take a reference to it, as references have a known size. So we‚Äôd write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;(<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>But we get another error:</p>
  <pre class="text"><code>error: missing lifetime specifier [E0106]
  fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~~</code></pre>
  <p>Right. Because we have a reference, we need to give it a lifetime. But our <code>factory()</code> function takes no arguments, so <a href="#lifetime-elision">elision</a> doesn‚Äôt kick in here. Then what choices do we have? Try <code>'static</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;<span class="ot">'static</span> (<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>But we get another error:</p>
  <pre class="text"><code>error: mismatched types:
   expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
      found `[closure@&lt;anon&gt;:7:9: 7:20]`
  (expected &amp;-ptr,
      found closure) [E0308]
           |x| x + num
           ^~~~~~~~~~~
  </code></pre>
  <p>This error is letting us know that we don‚Äôt have a <code>&amp;'static Fn(i32) -&gt; i32</code>, we have a <code>[closure@&lt;anon&gt;:7:9: 7:20]</code>. Wait, what?</p>
  <p>Because each closure generates its own environment <code>struct</code> and implementation of <code>Fn</code> and friends, these types are anonymous. They exist just solely for this closure. So Rust shows them as <code>closure@&lt;anon&gt;</code>, rather than some autogenerated name.</p>
  <p>The error also points out that the return type is expected to be a reference, but what we are trying to return is not. Further, we cannot directly assign a <code>'static</code> lifetime to an object. So we‚Äôll take a different approach and return a ‚Äútrait object‚Äù by <code>Box</code>ing up the <code>Fn</code>. This <em>almost</em> works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; <span class="dt">Box</span>&lt;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      <span class="dt">Box</span>::new(|x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>There‚Äôs just one last problem:</p>
  <pre class="text"><code>error: closure may outlive the current function, but it borrows `num`,
  which is owned by the current function [E0373]
  Box::new(|x| x + num)
           ^~~~~~~~~~~</code></pre>
  <p>Well, as we discussed before, closures borrow their environment. And in this case, our environment is based on a stack-allocated <code>5</code>, the <code>num</code> variable binding. So the borrow has a lifetime of the stack frame. So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory! With one last fix, we can make this work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; <span class="dt">Box</span>&lt;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      <span class="dt">Box</span>::new(<span class="kw">move</span> |x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre></div>
  <p>By making the inner closure a <code>move Fn</code>, we create a new stack frame for our closure. By <code>Box</code>ing it up, we‚Äôve given it a known size, and allowing it to escape our stack frame.</p>
  </section>
  </section>
  <section id="sec--ufcs" class="level2">
  <h2>Universal Function Call Syntax</h2>
  <p>Sometimes, functions can have the same names. Consider this code:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> Bar {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Baz‚Äôs impl of Foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> Bar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Baz‚Äôs impl of Bar&quot;</span>); }
  }
  
  <span class="kw">let</span> b = Baz;</code></pre></div>
  <p>If we were to try to call <code>b.f()</code>, we‚Äôd get an error:</p>
  <pre class="text"><code>error: multiple applicable methods in scope [E0034]
  b.f();
    ^~~
  note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz‚Äôs impl of Foo&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz‚Äôs impl of Bar&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  </code></pre>
  <p>We need a way to disambiguate which method we need. This feature is called ‚Äòuniversal function call syntax‚Äô, and it looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Foo::f(&amp;b);
  Bar::f(&amp;b);</code></pre></div>
  <p>Let‚Äôs break it down.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Foo::
  Bar::</code></pre></div>
  <p>These halves of the invocation are the types of the two traits: <code>Foo</code> and <code>Bar</code>. This is what ends up actually doing the disambiguation between the two: Rust calls the one from the trait name you use.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">f(&amp;b)</code></pre></div>
  <p>When we call a method like <code>b.f()</code> using <a href="#sec--method-syntax">method syntax</a>, Rust will automatically borrow <code>b</code> if <code>f()</code> takes <code>&amp;self</code>. In this case, Rust will not, and so we need to pass an explicit <code>&amp;b</code>.</p>
  <section id="angle-bracket-form" class="level3">
  <h3>Angle-bracket Form</h3>
  <p>The form of UFCS we just talked about:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Trait::method(args);</code></pre></div>
  <p>Is a short-hand. There‚Äôs an expanded form of this that‚Äôs needed in some situations:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">&lt;Type <span class="kw">as</span> Trait&gt;::method(args);</code></pre></div>
  <p>The <code>&lt;&gt;::</code> syntax is a means of providing a type hint. The type goes inside the <code>&lt;&gt;</code>s. In this case, the type is <code>Type as Trait</code>, indicating that we want <code>Trait</code>‚Äôs version of <code>method</code> to be called here. The <code>as Trait</code> part is optional if it‚Äôs not ambiguous. Same with the angle brackets, hence the shorter form.</p>
  <p>Here‚Äôs an example of using the longer form.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>);
  }
  
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span>
  <span class="kw">struct</span> Bar;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Bar {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) {
          <span class="pp">println!</span>(<span class="st">&quot;Making a clone of Bar&quot;</span>);
  
          &lt;Bar <span class="kw">as</span> <span class="bu">Clone</span>&gt;::clone(<span class="kw">self</span>);
      }
  }</code></pre></div>
  <p>This will call the <code>Clone</code> trait‚Äôs <code>clone()</code> method, rather than <code>Foo</code>‚Äôs.</p>
  </section>
  </section>
  <section id="sec--crates-and-modules" class="level2">
  <h2>Crates and Modules</h2>
  <p>When a project starts getting large, it‚Äôs considered good software engineering practice to split it up into a bunch of smaller pieces, and then fit them together. It‚Äôs also important to have a well-defined interface, so that some of your functionality is private, and some is public. To facilitate these kinds of things, Rust has a module system.</p>
  <section id="basic-terminology-crates-and-modules" class="level3">
  <h3>Basic terminology: Crates and Modules</h3>
  <p>Rust has two distinct terms that relate to the module system: ‚Äòcrate‚Äô and ‚Äòmodule‚Äô. A crate is synonymous with a ‚Äòlibrary‚Äô or ‚Äòpackage‚Äô in other languages. Hence ‚ÄúCargo‚Äù as the name of Rust‚Äôs package management tool: you ship your crates to others with Cargo. Crates can produce an executable or a library, depending on the project.</p>
  <p>Each crate has an implicit <em>root module</em> that contains the code for that crate. You can then define a tree of sub-modules under that root module. Modules allow you to partition your code within the crate itself.</p>
  <p>As an example, let‚Äôs make a <em>phrases</em> crate, which will give us various phrases in different languages. To keep things simple, we‚Äôll stick to ‚Äògreetings‚Äô and ‚Äòfarewells‚Äô as two kinds of phrases, and use English and Japanese (Êó•Êú¨Ë™û) as two languages for those phrases to be in. We‚Äôll use this module layout:</p>
  <pre class="text"><code>                                    +-----------+
                                  +---| greetings |
                                  |   +-----------+
                    +---------+   |
                +---| english |---+
                |   +---------+   |   +-----------+
                |                 +---| farewells |
  +---------+   |                     +-----------+
  | phrases |---+
  +---------+   |                     +-----------+
                |                 +---| greetings |
                |   +----------+  |   +-----------+
                +---| japanese |--+
                    +----------+  |
                                  |   +-----------+
                                  +---| farewells |
                                      +-----------+</code></pre>
  <p>In this example, <code>phrases</code> is the name of our crate. All of the rest are modules. You can see that they form a tree, branching out from the crate <em>root</em>, which is the root of the tree: <code>phrases</code> itself.</p>
  <p>Now that we have a plan, let‚Äôs define these modules in code. To start, generate a new crate with Cargo:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new phrases
  $ <span class="kw">cd</span> phrases</code></pre></div>
  <p>If you remember, this generates a simple project for us:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tree</span> .
  <span class="kw">.</span>
  ‚îú‚îÄ‚îÄ <span class="kw">Cargo.toml</span>
  ‚îî‚îÄ‚îÄ <span class="kw">src</span>
      ‚îî‚îÄ‚îÄ <span class="kw">lib.rs</span>
  
  <span class="kw">1</span> directory, 2 files</code></pre></div>
  <p><code>src/lib.rs</code> is our crate root, corresponding to the <code>phrases</code> in our diagram above.</p>
  </section>
  <section id="defining-modules" class="level3">
  <h3>Defining Modules</h3>
  <p>To define each of our modules, we use the <code>mod</code> keyword. Let‚Äôs make our <code>src/lib.rs</code> look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english {
      <span class="kw">mod</span> greetings {
      }
  
      <span class="kw">mod</span> farewells {
      }
  }
  
  <span class="kw">mod</span> japanese {
      <span class="kw">mod</span> greetings {
      }
  
      <span class="kw">mod</span> farewells {
      }
  }</code></pre></div>
  <p>After the <code>mod</code> keyword, you give the name of the module. Module names follow the conventions for other Rust identifiers: <code>lower_snake_case</code>. The contents of each module are within curly braces (<code>{}</code>).</p>
  <p>Within a given <code>mod</code>, you can declare sub-<code>mod</code>s. We can refer to sub-modules with double-colon (<code>::</code>) notation: our four nested modules are <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code>, and <code>japanese::farewells</code>. Because these sub-modules are namespaced under their parent module, the names don‚Äôt conflict: <code>english::greetings</code> and <code>japanese::greetings</code> are distinct, even though their names are both <code>greetings</code>.</p>
  <p>Because this crate does not have a <code>main()</code> function, and is called <code>lib.rs</code>, Cargo will build this crate as a library:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  $ <span class="kw">ls</span> target/debug
  <span class="kw">build</span>  deps  examples  libphrases-a7448e02a0468eaa.rlib  native</code></pre></div>
  <p><code>libphrases-hash.rlib</code> is the compiled crate. Before we see how to use this crate from another crate, let‚Äôs break it up into multiple files.</p>
  </section>
  <section id="multiple-file-crates" class="level3">
  <h3>Multiple file crates</h3>
  <p>If each crate were just one file, these files would get very large. It‚Äôs often easier to split up crates into multiple files, and Rust supports this in two ways.</p>
  <p>Instead of declaring a module like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english {
      <span class="co">// contents of our module go here</span>
  }</code></pre></div>
  <p>We can instead declare our module like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;</code></pre></div>
  <p>If we do that, Rust will expect to find either a <code>english.rs</code> file, or a <code>english/mod.rs</code> file with the contents of our module.</p>
  <p>Note that in these files, you don‚Äôt need to re-declare the module: that‚Äôs already been done with the initial <code>mod</code> declaration.</p>
  <p>Using these two techniques, we can break up our crate into two directories and seven files:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tree</span> .
  <span class="kw">.</span>
  ‚îú‚îÄ‚îÄ <span class="kw">Cargo.lock</span>
  ‚îú‚îÄ‚îÄ <span class="kw">Cargo.toml</span>
  ‚îú‚îÄ‚îÄ <span class="kw">src</span>
  ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">english</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">farewells.rs</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">greetings.rs</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <span class="kw">mod.rs</span>
  ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">japanese</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">farewells.rs</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <span class="kw">greetings.rs</span>
  ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <span class="kw">mod.rs</span>
  ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <span class="kw">lib.rs</span>
  ‚îî‚îÄ‚îÄ <span class="kw">target</span>
      ‚îî‚îÄ‚îÄ <span class="kw">debug</span>
          ‚îú‚îÄ‚îÄ <span class="kw">build</span>
          ‚îú‚îÄ‚îÄ <span class="kw">deps</span>
          ‚îú‚îÄ‚îÄ <span class="kw">examples</span>
          ‚îú‚îÄ‚îÄ <span class="kw">libphrases-a7448e02a0468eaa.rlib</span>
          ‚îî‚îÄ‚îÄ <span class="kw">native</span></code></pre></div>
  <p><code>src/lib.rs</code> is our crate root, and looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre></div>
  <p>These two declarations tell Rust to look for either <code>src/english.rs</code> and <code>src/japanese.rs</code>, or <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code>, depending on our preference. In this case, because our modules have sub-modules, we‚Äôve chosen the second. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code> look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre></div>
  <p>Again, these declarations tell Rust to look for either <code>src/english/greetings.rs</code> and <code>src/japanese/greetings.rs</code> or <code>src/english/farewells/mod.rs</code> and <code>src/japanese/farewells/mod.rs</code>. Because these sub-modules don‚Äôt have their own sub-modules, we‚Äôve chosen to make them <code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code>. Whew!</p>
  <p>The contents of <code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code> are both empty at the moment. Let‚Äôs add some functions.</p>
  <p>Put this in <code>src/english/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/english/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre></div>
  <p>Put this in <code>src/japanese/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;</span>.to_string()
  }</code></pre></div>
  <p>Of course, you can copy and paste this from this web page, or just type something else. It‚Äôs not important that you actually put ‚Äòkonnichiwa‚Äô to learn about the module system.</p>
  <p>Put this in <code>src/japanese/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;„Åï„Çà„ÅÜ„Å™„Çâ&quot;</span>.to_string()
  }</code></pre></div>
  <p>(This is ‚ÄòSay≈çnara‚Äô, if you‚Äôre curious.)</p>
  <p>Now that we have some functionality in our crate, let‚Äôs try to use it from another crate.</p>
  </section>
  <section id="importing-external-crates" class="level3">
  <h3>Importing External Crates</h3>
  <p>We have a library crate. Let‚Äôs make an executable crate that imports and uses our library.</p>
  <p>Make a <code>src/main.rs</code> and put this in it (it won‚Äôt quite compile yet):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, phrases::japanese::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, phrases::japanese::farewells::goodbye());
  }</code></pre></div>
  <p>The <code>extern crate</code> declaration tells Rust that we need to compile and link to the <code>phrases</code> crate. We can then use <code>phrases</code>‚Äô modules in this one. As we mentioned earlier, you can use double colons to refer to sub-modules and the functions inside of them.</p>
  <p>(Note: when importing a crate that has dashes in its name ‚Äúlike-this‚Äù, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code>.)</p>
  <p>Also, Cargo assumes that <code>src/main.rs</code> is the crate root of a binary crate, rather than a library crate. Our package now has two crates: <code>src/lib.rs</code> and <code>src/main.rs</code>. This pattern is quite common for executable crates: most functionality is in a library crate, and the executable crate uses that library. This way, other programs can also use the library crate, and it‚Äôs also a nice separation of concerns.</p>
  <p>This doesn‚Äôt quite work yet, though. We get four errors that look similar to this:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:38: 4:72 error: function <span class="kw">`hello`</span> is private
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>     println!(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello(
  ‚Ü≥ ));
                                                     ^<span class="kw">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
  <span class="kw">note</span>: in expansion of format_args!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:2:25: 2:58 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 2:62 note: in expansion of print!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:3:1: 3:54 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 3:58 note: in expansion of println!
  <span class="kw">phrases/src</span>/main.rs:<span class="kw">4</span>:5: 4:76 note: expansion site</code></pre></div>
  <p>By default, everything is private in Rust. Let‚Äôs talk about this in some more depth.</p>
  </section>
  <section id="exporting-a-public-interface" class="level3">
  <h3>Exporting a Public Interface</h3>
  <p>Rust allows you to precisely control which aspects of your interface are public, and so private is the default. To make things public, you use the <code>pub</code> keyword. Let‚Äôs focus on the <code>english</code> module first, so let‚Äôs reduce our <code>src/main.rs</code> to just this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  }</code></pre></div>
  <p>In our <code>src/lib.rs</code>, let‚Äôs add <code>pub</code> to the <code>english</code> module declaration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre></div>
  <p>And in our <code>src/english/mod.rs</code>, let‚Äôs make both <code>pub</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> greetings;
  <span class="kw">pub</span> <span class="kw">mod</span> farewells;</code></pre></div>
  <p>In our <code>src/english/greetings.rs</code>, let‚Äôs add <code>pub</code> to our <code>fn</code> declaration:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre></div>
  <p>And also in <code>src/english/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre></div>
  <p>Now, our crate compiles, albeit with warnings about not using the <code>japanese</code> functions:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">1</span>:1: 3:2 warning: function is never used: <span class="kw">`hello`</span>, <span class="co">#[warn(de</span>
  ‚Ü≥ <span class="kw">ad_code</span>)] <span class="kw">on</span> by default
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">1</span> fn hello() <span class="kw">-&gt;</span> String {
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">2</span>     <span class="st">&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;</span>.to_string()
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">3</span> }
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">1</span>:1: 3:2 warning: function is never used: <span class="kw">`goodbye`</span>, <span class="co">#[warn(</span>
  ‚Ü≥ <span class="kw">dead_code</span>)] <span class="kw">on</span> by default
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">1</span> fn goodbye() <span class="kw">-&gt;</span> String {
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">2</span>     <span class="st">&quot;„Åï„Çà„ÅÜ„Å™„Çâ&quot;</span>.to_string()
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">3</span> }
       <span class="kw">Running</span> <span class="kw">`target/debug/phrases`</span>
  <span class="kw">Hello</span> in English: Hello!
  <span class="kw">Goodbye</span> in English: Goodbye.</code></pre></div>
  <p><code>pub</code> also applies to <code>struct</code>s and their member fields. In keeping with Rust‚Äôs tendency toward safety, simply making a <code>struct</code> public won‚Äôt automatically make its members public: you must mark the fields individually with <code>pub</code>.</p>
  <p>Now that our functions are public, we can use them. Great! However, typing out <code>phrases::english::greetings::hello()</code> is very long and repetitive. Rust has another keyword for importing names into the current scope, so that you can refer to them with shorter names. Let‚Äôs talk about <code>use</code>.</p>
  </section>
  <section id="importing-modules-with-use" class="level3">
  <h3>Importing Modules with <code>use</code></h3>
  <p>Rust has a <code>use</code> keyword, which allows us to import names into our local scope. Let‚Äôs change our <code>src/main.rs</code> to look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  }</code></pre></div>
  <p>The two <code>use</code> lines import each module into the local scope, so we can refer to the functions by a much shorter name. By convention, when importing functions, it‚Äôs considered best practice to import the module, rather than the function directly. In other words, you <em>can</em> do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::english::farewells::goodbye;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, goodbye());
  }</code></pre></div>
  <p>But it is not idiomatic. This is significantly more likely to introduce a naming conflict. In our short program, it‚Äôs not a big deal, but as it grows, it becomes a problem. If we have conflicting names, Rust will give a compilation error. For example, if we made the <code>japanese</code> functions public, and tried to do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::japanese::greetings::hello;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, hello());
  }</code></pre></div>
  <p>Rust will give us a compile-time error:</p>
  <pre class="text"><code>   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this m
  ‚Ü≥ odule [E0252]
  src/main.rs:4 use phrases::japanese::greetings::hello;
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `phrases`.</code></pre>
  <p>If we‚Äôre importing multiple names from the same module, we don‚Äôt have to type it out twice. Instead of this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;</code></pre></div>
  <p>We can use this shortcut:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::{greetings, farewells};</code></pre></div>
  <section id="re-exporting-with-pub-use" class="level4">
  <h4>Re-exporting with <code>pub use</code></h4>
  <p>You don‚Äôt just use <code>use</code> to shorten identifiers. You can also use it inside of your crate to re-export a function inside another module. This allows you to present an external interface that may not directly map to your internal code organization.</p>
  <p>Let‚Äôs look at an example. Modify your <code>src/main.rs</code> to read like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases;
  
  <span class="kw">use</span> phrases::english::{greetings,farewells};
  <span class="kw">use</span> phrases::japanese;
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  
      <span class="pp">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, japanese::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, japanese::goodbye());
  }</code></pre></div>
  <p>Then, modify your <code>src/lib.rs</code> to make the <code>japanese</code> mod public:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">pub</span> <span class="kw">mod</span> japanese;</code></pre></div>
  <p>Next, make the two functions public, first in <code>src/japanese/greetings.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;</span>.to_string()
  }</code></pre></div>
  <p>And then in <code>src/japanese/farewells.rs</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; <span class="dt">String</span> {
      <span class="st">&quot;„Åï„Çà„ÅÜ„Å™„Çâ&quot;</span>.to_string()
  }</code></pre></div>
  <p>Finally, modify your <code>src/japanese/mod.rs</code> to read like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::greetings::hello;
  <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::farewells::goodbye;
  
  <span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre></div>
  <p>The <code>pub use</code> declaration brings the function into scope at this part of our module hierarchy. Because we‚Äôve <code>pub use</code>d this inside of our <code>japanese</code> module, we now have a <code>phrases::japanese::hello()</code> function and a <code>phrases::japanese::goodbye()</code> function, even though the code for them lives in <code>phrases::japanese::greetings::hello()</code> and <code>phrases::japanese::farewells::goodbye()</code>. Our internal organization doesn‚Äôt define our external interface.</p>
  <p>Here we have a <code>pub use</code> for each function we want to bring into the <code>japanese</code> scope. We could alternatively use the wildcard syntax to include everything from <code>greetings</code> into the current scope: <code>pub use self::greetings::*</code>.</p>
  <p>What about the <code>self</code>? Well, by default, <code>use</code> declarations are absolute paths, starting from your crate root. <code>self</code> makes that path relative to your current place in the hierarchy instead. There‚Äôs one more special form of <code>use</code>: you can <code>use super::</code> to reach one level up the tree from your current location. Some people like to think of <code>self</code> as <code>.</code> and <code>super</code> as <code>..</code>, from many shells‚Äô display for the current directory and the parent directory.</p>
  <p>Outside of <code>use</code>, paths are relative: <code>foo::bar()</code> refers to a function inside of <code>foo</code> relative to where we are. If that‚Äôs prefixed with <code>::</code>, as in <code>::foo::bar()</code>, it refers to a different <code>foo</code>, an absolute path from your crate root.</p>
  <p>This will build and run:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
       <span class="kw">Running</span> <span class="kw">`target/debug/phrases`</span>
  <span class="kw">Hello</span> in English: Hello!
  <span class="kw">Goodbye</span> in English: Goodbye.
  <span class="kw">Hello</span> in Japanese: „Åì„Çì„Å´„Å°„ÅØ
  <span class="kw">Goodbye</span> in Japanese: „Åï„Çà„ÅÜ„Å™„Çâ</code></pre></div>
  </section>
  <section id="complex-imports" class="level4">
  <h4>Complex imports</h4>
  <p>Rust offers several advanced options that can add compactness and convenience to your <code>extern crate</code> and <code>use</code> statements. Here is an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> phrases <span class="kw">as</span> sayings;
  
  <span class="kw">use</span> sayings::japanese::greetings <span class="kw">as</span> ja_greetings;
  <span class="kw">use</span> sayings::japanese::farewells::*;
  <span class="kw">use</span> sayings::english::{<span class="kw">self</span>, greetings <span class="kw">as</span> en_greetings, farewells <span class="kw">as</span> en_farewells};
  
  <span class="kw">fn</span> main() {
      <span class="pp">println!</span>(<span class="st">&quot;Hello in English; {}&quot;</span>, en_greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;And in Japanese: {}&quot;</span>, ja_greetings::hello());
      <span class="pp">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, english::farewells::goodbye());
      <span class="pp">println!</span>(<span class="st">&quot;Again: {}&quot;</span>, en_farewells::goodbye());
      <span class="pp">println!</span>(<span class="st">&quot;And in Japanese: {}&quot;</span>, goodbye());
  }</code></pre></div>
  <p>What‚Äôs going on here?</p>
  <p>First, both <code>extern crate</code> and <code>use</code> allow renaming the thing that is being imported. So the crate is still called ‚Äúphrases‚Äù, but here we will refer to it as ‚Äúsayings‚Äù. Similarly, the first <code>use</code> statement pulls in the <code>japanese::farewells</code> module from the crate, but makes it available as <code>jp_farewells</code> as opposed to simply <code>farewells</code>. This can help to avoid ambiguity when importing similarly-named items from different places.</p>
  <p>The second <code>use</code> statement uses a star glob to bring in <em>all</em> symbols from the <code>sayings::japanese::farewells</code> module. As you can see we can later refer to the Japanese <code>goodbye</code> function with no module qualifiers. This kind of glob should be used sparingly.</p>
  <p>The third <code>use</code> statement bears more explanation. It‚Äôs using ‚Äúbrace expansion‚Äù globbing to compress three <code>use</code> statements into one (this sort of syntax may be familiar if you‚Äôve written Linux shell scripts before). The uncompressed form of this statement would be:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> sayings::english;
  <span class="kw">use</span> sayings::english::greetings <span class="kw">as</span> en_greetings;
  <span class="kw">use</span> sayings::english::farewells <span class="kw">as</span> en_farewells;</code></pre></div>
  <p>As you can see, the curly brackets compress <code>use</code> statements for several items under the same path, and in this context <code>self</code> just refers back to that path. Note: The curly brackets cannot be nested or mixed with star globbing.</p>
  </section>
  </section>
  </section>
  <section id="sec--const-and-static" class="level2">
  <h2><code>const</code> and <code>static</code></h2>
  <p>Rust has a way of defining constants with the <code>const</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Unlike <a href="#sec--variable-bindings"><code>let</code></a> bindings, you must annotate the type of a <code>const</code>.</p>
  <p>Constants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they‚Äôre effectively inlined to each place that they‚Äôre used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.</p>
  <section id="static-1" class="level3">
  <h3><code>static</code></h3>
  <p>Rust provides a ‚Äòglobal variable‚Äô sort of facility in static items. They‚Äôre similar to constants, but static items aren‚Äôt inlined upon use. This means that there is only one instance for each value, and it‚Äôs at a fixed location in memory.</p>
  <p>Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Unlike <a href="#sec--variable-bindings"><code>let</code></a> bindings, you must annotate the type of a <code>static</code>.</p>
  <p>Statics live for the entire lifetime of a program, and therefore any reference stored in a constant has a <a href="#sec--lifetimes"><code>'static</code> lifetime</a>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> NAME: &amp;<span class="ot">'static</span> <span class="dt">str</span> = <span class="st">&quot;Steve&quot;</span>;</code></pre></div>
  <section id="mutability" class="level4">
  <h4>Mutability</h4>
  <p>You can introduce mutability with the <code>mut</code> keyword:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> <span class="kw">mut</span> N: <span class="dt">i32</span> = <span class="dv">5</span>;</code></pre></div>
  <p>Because this is mutable, one thread could be updating <code>N</code> while another is reading it, causing memory unsafety. As such both accessing and mutating a <code>static mut</code> is <a href="#sec--unsafe"><code>unsafe</code></a>, and so must be done in an <code>unsafe</code> block:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">unsafe</span> {
      N += <span class="dv">1</span>;
  
      <span class="pp">println!</span>(<span class="st">&quot;N: {}&quot;</span>, N);
  }</code></pre></div>
  <p>Furthermore, any type stored in a <code>static</code> must be <code>Sync</code>, and may not have a <a href="#sec--drop"><code>Drop</code></a> implementation.</p>
  </section>
  </section>
  <section id="initializing" class="level3">
  <h3>Initializing</h3>
  <p>Both <code>const</code> and <code>static</code> have requirements for giving them a value. They may only be given a value that‚Äôs a constant expression. In other words, you cannot use the result of a function call or anything similarly complex or at runtime.</p>
  </section>
  <section id="which-construct-should-i-use" class="level3">
  <h3>Which construct should I use?</h3>
  <p>Almost always, if you can choose between the two, choose <code>const</code>. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but downstream crates.</p>
  </section>
  </section>
  <section id="sec--attributes" class="level2">
  <h2>Attributes</h2>
  <p>Declarations can be annotated with ‚Äòattributes‚Äô in Rust. They look like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span></code></pre></div>
  <p>or like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>test<span class="at">]</span></code></pre></div>
  <p>The difference between the two is the <code>!</code>, which changes what the attribute applies to:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>foo<span class="at">]</span>
  <span class="kw">struct</span> Foo;
  
  <span class="kw">mod</span> bar {
      <span class="at">#![</span>bar<span class="at">]</span>
  }</code></pre></div>
  <p>The <code>#[foo]</code> attribute applies to the next item, which is the <code>struct</code> declaration. The <code>#![bar]</code> attribute applies to the item enclosing it, which is the <code>mod</code> declaration. Otherwise, they‚Äôre the same. Both change the meaning of the item they‚Äôre attached to somehow.</p>
  <p>For example, consider a function like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
  <span class="kw">fn</span> check() {
      <span class="pp">assert_eq!</span>(<span class="dv">2</span>, <span class="dv">1</span> + <span class="dv">1</span>);
  }</code></pre></div>
  <p>It is marked with <code>#[test]</code>. This means it‚Äôs special: when you run <a href="#sec--testing">tests</a>, this function will execute. When you compile as usual, it won‚Äôt even be included. This function is now a test function.</p>
  <p>Attributes may also have additional data:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>inline<span class="at">(</span>always<span class="at">)]</span>
  <span class="kw">fn</span> super_fast_fn() {</code></pre></div>
  <p>Or even keys and values:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>cfg<span class="at">(</span>target_os <span class="at">=</span> <span class="st">&quot;macos&quot;</span><span class="at">)]</span>
  <span class="kw">mod</span> macos_only {</code></pre></div>
  <p>Rust attributes are used for a number of different things. There is a full list of attributes <a href="http://doc.rust-lang.org/reference.html#attributes">in the reference</a>. Currently, you are not allowed to create your own attributes, the Rust compiler defines them.</p>
  </section>
  <section id="sec--type-aliases" class="level2">
  <h2><code>type</code> aliases</h2>
  <p>The <code>type</code> keyword lets you declare an alias of another type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = <span class="dt">String</span>;</code></pre></div>
  <p>You can then use this type as if it were a real type:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = <span class="dt">String</span>;
  
  <span class="kw">let</span> x: Name = <span class="st">&quot;Hello&quot;</span>.to_string();</code></pre></div>
  <p>Note, however, that this is an <em>alias</em>, not a new type entirely. In other words, because Rust is strongly typed, you‚Äôd expect a comparison between two different types to fail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: <span class="dt">i64</span> = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre></div>
  <p>this gives</p>
  <pre class="text"><code>error: mismatched types:
   expected `i32`,
      found `i64`
  (expected i32,
      found i64) [E0308]
       if x == y {
               ^</code></pre>
  <p>But, if we had an alias:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Num = <span class="dt">i32</span>;
  
  <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: Num = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre></div>
  <p>This compiles without error. Values of a <code>Num</code> type are the same as a value of type <code>i32</code>, in every way.</p>
  <p>You can also use type aliases with generics:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::result;
  
  <span class="kw">enum</span> ConcreteError {
      Foo,
      Bar,
  }
  
  <span class="kw">type</span> Result&lt;T&gt; = result::<span class="dt">Result</span>&lt;T, ConcreteError&gt;;</code></pre></div>
  <p>This creates a specialized version of the <code>Result</code> type, which always has a <code>ConcreteError</code> for the <code>E</code> part of <code>Result&lt;T, E&gt;</code>. This is commonly used in the standard library to create custom errors for each subsection. For example, <a href="http://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
  </section>
  <section id="sec--casting-between-types" class="level2">
  <h2>Casting between types</h2>
  <p>Rust, with its focus on safety, provides two different ways of casting different types between each other. The first, <code>as</code>, is for safe casts. In contrast, <code>transmute</code> allows for arbitrary casting, and is one of the most dangerous features of Rust!</p>
  <section id="as" class="level3">
  <h3><code>as</code></h3>
  <p>The <code>as</code> keyword does basic casting:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = x <span class="kw">as</span> <span class="dt">i64</span>;</code></pre></div>
  <p>It only allows certain kinds of casting, however:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
  <span class="kw">let</span> b = a <span class="kw">as</span> <span class="dt">u32</span>; <span class="co">// four eights makes 32</span></code></pre></div>
  <p>This errors with:</p>
  <pre class="text"><code>error: non-scalar cast: `[u8; 4]` as `u32`
  let b = a as u32; // four eights makes 32
          ^~~~~~~~</code></pre>
  <p>It‚Äôs a ‚Äònon-scalar cast‚Äô because we have multiple values here: the four elements of the array. These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented. For this, we need something more dangerous.</p>
  </section>
  <section id="transmute" class="level3">
  <h3><code>transmute</code></h3>
  <p>The <code>transmute</code> function is provided by a <a href="#sec--intrinsics">compiler intrinsic</a>, and what it does is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and just completely trusts you.</p>
  <p>In our previous example, we know that an array of four <code>u8</code>s represents a <code>u32</code> properly, and so we want to do the cast. Using <code>transmute</code> instead of <code>as</code>, Rust lets us:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="dt">u8</span>; <span class="dv">4</span>], <span class="dt">u32</span>&gt;(a);
  }</code></pre></div>
  <p>We have to wrap the operation in an <code>unsafe</code> block for this to compile successfully. Technically, only the <code>mem::transmute</code> call itself needs to be in the block, but it‚Äôs nice in this case to enclose everything related, so you know where to look. In this case, the details about <code>a</code> are also important, and so they‚Äôre in the block. You‚Äôll see code in either style, sometimes the context is too far away, and wrapping all of the code in <code>unsafe</code> isn‚Äôt a great idea.</p>
  <p>While <code>transmute</code> does very little checking, it will at least make sure that the types are the same size. This errors:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="dt">u8</span>; <span class="dv">4</span>], <span class="dt">u64</span>&gt;(a);
  }</code></pre></div>
  <p>with:</p>
  <pre class="text"><code>error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
  (64 bits)</code></pre>
  <p>Other than that, you‚Äôre on your own!</p>
  </section>
  </section>
  <section id="sec--associated-types" class="level2">
  <h2>Associated Types</h2>
  <p>Associated types are a powerful part of Rust‚Äôs type system. They‚Äôre related to the idea of a ‚Äòtype family‚Äô, in other words, grouping multiple types together. That description is a bit abstract, so let‚Äôs dive right into an example. If you want to write a <code>Graph</code> trait, you have two types to be generic over: the node type and the edge type. So you might write a trait, <code>Graph&lt;N, E&gt;</code>, that looks like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph&lt;N, E&gt; {
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;N, &amp;N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;N) -&gt; <span class="dt">Vec</span>&lt;E&gt;;
      <span class="co">// etc</span>
  }</code></pre></div>
  <p>While this sort of works, it ends up being awkward. For example, any function that wants to take a <code>Graph</code> as a parameter now <em>also</em> needs to be generic over the <code>N</code>ode and <code>E</code>dge types too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class="dt">u32</span> { ... }</code></pre></div>
  <p>Our distance calculation works regardless of our <code>Edge</code> type, so the <code>E</code> stuff in this signature is just a distraction.</p>
  <p>What we really want to say is that a certain <code>E</code>dge and <code>N</code>ode type come together to form each kind of <code>Graph</code>. We can do that with associated types:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
      <span class="co">// etc</span>
  }</code></pre></div>
  <p>Now, our clients can be abstract over a given <code>Graph</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; <span class="dt">u32</span> { ... }</code></pre></div>
  <p>No need to deal with the <code>E</code>dge type here!</p>
  <p>Let‚Äôs go over all this in more detail.</p>
  <section id="defining-associated-types" class="level4">
  <h4>Defining associated types</h4>
  <p>Let‚Äôs build that <code>Graph</code> trait. Here‚Äôs the definition:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre></div>
  <p>Simple enough. Associated types use the <code>type</code> keyword, and go inside the body of the trait, with the functions.</p>
  <p>These <code>type</code> declarations can have all the same thing as functions do. For example, if we wanted our <code>N</code> type to implement <code>Display</code>, so we can print the nodes out, we could do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt;
  
  <span class="kw">trait</span> Graph {
      <span class="kw">type</span> N: fmt::Display;
      <span class="kw">type</span> E;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;<span class="kw">Self</span>::N) -&gt; <span class="dt">Vec</span>&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre></div>
  </section>
  <section id="implementing-associated-types" class="level4">
  <h4>Implementing associated types</h4>
  <p>Just like any trait, traits that use associated types use the <code>impl</code> keyword to provide implementations. Here‚Äôs a simple implementation of Graph:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Node;
  
  <span class="kw">struct</span> Edge;
  
  <span class="kw">struct</span> MyGraph;
  
  <span class="kw">impl</span> Graph <span class="kw">for</span> MyGraph {
      <span class="kw">type</span> N = Node;
      <span class="kw">type</span> E = Edge;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="dt">bool</span> {
          <span class="cn">true</span>
      }
  
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, n: &amp;Node) -&gt; <span class="dt">Vec</span>&lt;Edge&gt; {
          <span class="dt">Vec</span>::new()
      }
  }</code></pre></div>
  <p>This silly implementation always returns <code>true</code> and an empty <code>Vec&lt;Edge&gt;</code>, but it gives you an idea of how to implement this kind of thing. We first need three <code>struct</code>s, one for the graph, one for the node, and one for the edge. If it made more sense to use a different type, that would work as well, we‚Äôre just going to use <code>struct</code>s for all three here.</p>
  <p>Next is the <code>impl</code> line, which is just like implementing any other trait.</p>
  <p>From here, we use <code>=</code> to define our associated types. The name the trait uses goes on the left of the <code>=</code>, and the concrete type we‚Äôre <code>impl</code>ementing this for goes on the right. Finally, we use the concrete types in our function declarations.</p>
  </section>
  <section id="trait-objects-with-associated-types" class="level4">
  <h4>Trait objects with associated types</h4>
  <p>There‚Äôs one more bit of syntax we should talk about: trait objects. If you try to create a trait object from an associated type, like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = <span class="dt">Box</span>::new(graph) <span class="kw">as</span> <span class="dt">Box</span>&lt;Graph&gt;;</code></pre></div>
  <p>You‚Äôll get two errors:</p>
  <pre class="text"><code>error: the value of the associated type `E` (from the trait `main::Graph`) must
  be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  24:44 error: the value of the associated type `N` (from the trait
  `main::Graph`) must be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>We can‚Äôt create a trait object like this, because we don‚Äôt know the associated types. Instead, we can write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = <span class="dt">Box</span>::new(graph) <span class="kw">as</span> <span class="dt">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</code></pre></div>
  <p>The <code>N=Node</code> syntax allows us to provide a concrete type, <code>Node</code>, for the <code>N</code> type parameter. Same with <code>E=Edge</code>. If we didn‚Äôt provide this constraint, we couldn‚Äôt be sure which <code>impl</code> to match this trait object to.</p>
  </section>
  </section>
  <section id="sec--unsized-types" class="level2">
  <h2>Unsized Types</h2>
  <p>Most types have a particular size, in bytes, that is knowable at compile time. For example, an <code>i32</code> is thirty-two bits big, or four bytes. However, there are some types which are useful to express, but do not have a defined size. These are called ‚Äòunsized‚Äô or ‚Äòdynamically sized‚Äô types. One example is <code>[T]</code>. This type represents a certain number of <code>T</code> in sequence. But we don‚Äôt know how many there are, so the size is not known.</p>
  <p>Rust understands a few of these types, but they have some restrictions. There are three:</p>
  <ol type="1">
  <li>We can only manipulate an instance of an unsized type via a pointer. An <code>&amp;[T]</code> works just fine, but a <code>[T]</code> does not.</li>
  <li>Variables and arguments cannot have dynamically sized types.</li>
  <li>Only the last field in a <code>struct</code> may have a dynamically sized type; the other fields must not. Enum variants must not have dynamically sized types as data.</li>
  </ol>
  <p>So why bother? Well, because <code>[T]</code> can only be used behind a pointer, if we didn‚Äôt have language support for unsized types, it would be impossible to write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">str</span> {</code></pre></div>
  <p>or</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T&gt; Foo <span class="kw">for</span> [T] {</code></pre></div>
  <p>Instead, you would have to write:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> &amp;<span class="dt">str</span> {</code></pre></div>
  <p>Meaning, this implementation would only work for <a href="#sec--references-and-borrowing">references</a>, and not other types of pointers. With the <code>impl for str</code>, all pointers, including (at some point, there are some bugs to fix first) user-defined custom smart pointers, can use this <code>impl</code>.</p>
  <section id="sized" class="level3">
  <h3>?Sized</h3>
  <p>If you want to write a function that accepts a dynamically sized type, you can use the special bound, <code>?Sized</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;T: ?<span class="bu">Sized</span>&gt; {
      f: T,
  }</code></pre></div>
  <p>This <code>?</code>, read as ‚ÄúT may be <code>Sized</code>‚Äù, means that this bound is special: it lets us match more kinds, not less. It‚Äôs almost like every <code>T</code> implicitly has <code>T: Sized</code>, and the <code>?</code> undoes this default.</p>
  </section>
  </section>
  <section id="sec--operators-and-overloading" class="level2">
  <h2>Operators and Overloading</h2>
  <p>Rust allows for a limited form of operator overloading. There are certain operators that are able to be overloaded. To support a particular operator between types, there‚Äôs a specific trait that you can implement, which then overloads the operator.</p>
  <p>For example, the <code>+</code> operator can be overloaded with the <code>Add</code> trait:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Add;
  
  <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
  <span class="kw">struct</span> Point {
      x: <span class="dt">i32</span>,
      y: <span class="dt">i32</span>,
  }
  
  <span class="kw">impl</span> Add <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = Point;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, other: Point) -&gt; Point {
          Point { x: <span class="kw">self</span>.x + other.x, y: <span class="kw">self</span>.y + other.y }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Point { x: <span class="dv">1</span>, y: <span class="dv">0</span> };
      <span class="kw">let</span> p2 = Point { x: <span class="dv">2</span>, y: <span class="dv">3</span> };
  
      <span class="kw">let</span> p3 = p1 + p2;
  
      <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, p3);
  }</code></pre></div>
  <p>In <code>main</code>, we can use <code>+</code> on our two <code>Point</code>s, since we‚Äôve implemented <code>Add&lt;Output=Point&gt;</code> for <code>Point</code>.</p>
  <p>There are a number of operators that can be overloaded this way, and all of their associated traits live in the <a href="http://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module. Check out its documentation for the full list.</p>
  <p>Implementing these traits follows a pattern. Let‚Äôs look at <a href="http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a> in more detail:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> Add&lt;RHS = <span class="kw">Self</span>&gt; {
      <span class="kw">type</span> Output;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, rhs: RHS) -&gt; <span class="kw">Self</span>::Output;
  }</code></pre></div>
  <p>There‚Äôs three types in total involved here: the type you <code>impl Add</code> for, <code>RHS</code>, which defaults to <code>Self</code>, and <code>Output</code>. For an expression <code>let z = x + y</code>, <code>x</code> is the <code>Self</code> type, <code>y</code> is the RHS, and <code>z</code> is the <code>Self::Output</code> type.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Add&lt;<span class="dt">i32</span>&gt; <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = <span class="dt">f64</span>;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, rhs: <span class="dt">i32</span>) -&gt; <span class="dt">f64</span> {
          <span class="co">// add an i32 to a Point and get an f64</span>
      }
  }</code></pre></div>
  <p>will let you do this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> p: Point = <span class="co">// ...</span>
  <span class="kw">let</span> x: <span class="dt">f64</span> = p + <span class="dv">2i32</span>;</code></pre></div>
  <section id="using-operator-traits-in-generic-structs" class="level3">
  <h3>Using operator traits in generic structs</h3>
  <p>Now that we know how operator traits are defined, we can define our <code>HasArea</code> trait and <code>Square</code> struct from the <a href="#sec--traits">traits chapter</a> more generically:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Mul;
  
  <span class="kw">trait</span> HasArea&lt;T&gt; {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; T;
  }
  
  <span class="kw">struct</span> Square&lt;T&gt; {
      x: T,
      y: T,
      side: T,
  }
  
  <span class="kw">impl</span>&lt;T&gt; HasArea&lt;T&gt; <span class="kw">for</span> Square&lt;T&gt;
          <span class="kw">where</span> T: Mul&lt;Output=T&gt; + <span class="bu">Copy</span> {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; T {
          <span class="kw">self</span>.side * <span class="kw">self</span>.side
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> s = Square {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          side: <span class="dv">12.0f64</span>,
      };
  
      <span class="pp">println!</span>(<span class="st">&quot;Area of s: {}&quot;</span>, s.area());
  }</code></pre></div>
  <p>For <code>HasArea</code> and <code>Square</code>, we just declare a type parameter <code>T</code> and replace <code>f64</code> with it. The <code>impl</code> needs more involved modifications:</p>
  <pre class="ignore"><code>impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
          where T: Mul&lt;Output=T&gt; + Copy { ... }</code></pre>
  <p>The <code>area</code> method requires that we can multiply the sides, so we declare that type <code>T</code> must implement <code>std::ops::Mul</code>. Like <code>Add</code>, mentioned above, <code>Mul</code> itself takes an <code>Output</code> parameter: since we know that numbers don‚Äôt change type when multiplied, we also set it to <code>T</code>. <code>T</code> must also support copying, so Rust doesn‚Äôt try to move <code>self.side</code> into the return value.</p>
  </section>
  </section>
  <section id="sec--deref-coercions" class="level2">
  <h2>Deref coercions</h2>
  <p>The standard library provides a special trait, <a href="http://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>. It‚Äôs normally used to overload <code>*</code>, the dereference operator:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Deref;
  
  <span class="kw">struct</span> DerefExample&lt;T&gt; {
      value: T,
  }
  
  <span class="kw">impl</span>&lt;T&gt; Deref <span class="kw">for</span> DerefExample&lt;T&gt; {
      <span class="kw">type</span> Target = T;
  
      <span class="kw">fn</span> deref(&amp;<span class="kw">self</span>) -&gt; &amp;T {
          &amp;<span class="kw">self</span>.value
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = DerefExample { value: <span class="ch">'a'</span> };
      <span class="pp">assert_eq!</span>(<span class="ch">'a'</span>, *x);
  }</code></pre></div>
  <p>This is useful for writing custom pointer types. However, there‚Äôs a language feature related to <code>Deref</code>: ‚Äòderef coercions‚Äô. Here‚Äôs the rule: If you have a type <code>U</code>, and it implements <code>Deref&lt;Target=T&gt;</code>, values of <code>&amp;U</code> will automatically coerce to a <code>&amp;T</code>. Here‚Äôs an example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;<span class="dt">str</span>) {
      <span class="co">// borrow a string for a second</span>
  }
  
  <span class="co">// String implements Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="co">// therefore, this works:</span>
  foo(&amp;owned);</code></pre></div>
  <p>Using an ampersand in front of a value takes a reference to it. So <code>owned</code> is a <code>String</code>, <code>&amp;owned</code> is an <code>&amp;String</code>, and since <code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> will deref to <code>&amp;str</code>, which <code>foo()</code> takes.</p>
  <p>That‚Äôs it. This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility. For example, the <code>Rc&lt;T&gt;</code> type implements <code>Deref&lt;Target=T&gt;</code>, so this works:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::rc::Rc;
  
  <span class="kw">fn</span> foo(s: &amp;<span class="dt">str</span>) {
      <span class="co">// borrow a string for a second</span>
  }
  
  <span class="co">// String implements Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  <span class="kw">let</span> counted = Rc::new(owned);
  
  <span class="co">// therefore, this works:</span>
  foo(&amp;counted);</code></pre></div>
  <p>All we‚Äôve done is wrap our <code>String</code> in an <code>Rc&lt;T&gt;</code>. But we can now pass the <code>Rc&lt;String&gt;</code> around anywhere we‚Äôd have a <code>String</code>. The signature of <code>foo</code> didn‚Äôt change, but works just as well with either type. This example has two conversions: <code>Rc&lt;String&gt;</code> to <code>String</code> and then <code>String</code> to <code>&amp;str</code>. Rust will do this as many times as possible until the types match.</p>
  <p>Another very common implementation provided by the standard library is:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;[<span class="dt">i32</span>]) {
      <span class="co">// borrow a slice for a second</span>
  }
  
  <span class="co">// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;</span>
  <span class="kw">let</span> owned = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  foo(&amp;owned);</code></pre></div>
  <p>Vectors can <code>Deref</code> to a slice.</p>
  <section id="deref-and-method-calls" class="level4">
  <h4>Deref and method calls</h4>
  <p><code>Deref</code> will also kick in when calling a method. Consider the following example.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="pp">println!</span>(<span class="st">&quot;Foo&quot;</span>); }
  }
  
  <span class="kw">let</span> f = &amp;&amp;Foo;
  
  f.foo();</code></pre></div>
  <p>Even though <code>f</code> is a <code>&amp;&amp;Foo</code> and <code>foo</code> takes <code>&amp;self</code>, this works. That‚Äôs because these things are the same:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">f.foo();
  (&amp;f).foo();
  (&amp;&amp;f).foo();
  (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();</code></pre></div>
  <p>A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined on <code>Foo</code> called, because the compiler will insert as many * operations as necessary to get it right. And since it‚Äôs inserting <code>*</code>s, that uses <code>Deref</code>.</p>
  </section>
  </section>
  <section id="sec--macros" class="level2">
  <h2>Macros</h2>
  <p>By now you‚Äôve learned about many of the tools Rust provides for abstracting and reusing code. These units of code reuse have a rich semantic structure. For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.</p>
  <p>This structure means that Rust‚Äôs core abstractions have powerful compile-time correctness checking. But this comes at the price of reduced flexibility. If you visually identify a pattern of repeated code, you may find it‚Äôs difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust‚Äôs semantics.</p>
  <p>Macros allow us to abstract at a syntactic level. A macro invocation is shorthand for an ‚Äúexpanded‚Äù syntactic form. This expansion happens early in compilation, before any static checking. As a result, macros can capture many patterns of code reuse that Rust‚Äôs core abstractions cannot.</p>
  <p>The drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply. Like an ordinary function, a well-behaved macro can be used without understanding its implementation. However, it can be difficult to design a well-behaved macro! Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.</p>
  <p>These drawbacks make macros something of a ‚Äúfeature of last resort‚Äù. That‚Äôs not to say that macros are bad; they are part of Rust because sometimes they‚Äôre needed for truly concise, well-abstracted code. Just keep this tradeoff in mind.</p>
  <section id="defining-a-macro" class="level3">
  <h3>Defining a macro</h3>
  <p>You may have seen the <code>vec!</code> macro, used to initialize a <a href="#sec--vectors">vector</a> with any number of elements.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];</code></pre></div>
  <p>This can‚Äôt be an ordinary function, because it takes any number of arguments. But we can imagine it as syntactic shorthand for</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Vec</span>&lt;<span class="dt">u32</span>&gt; = {
      <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
      temp_vec.push(<span class="dv">1</span>);
      temp_vec.push(<span class="dv">2</span>);
      temp_vec.push(<span class="dv">3</span>);
      temp_vec
  };</code></pre></div>
  <p>We can implement this shorthand, using a macro: <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> vec {
      ( $( $x:expr ),* ) =&gt; {
          {
              <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
              $(
                  temp_vec.push($x);
              )*
              temp_vec
          }
      };
  }</code></pre></div>
  <p>Whoa, that‚Äôs a lot of new syntax! Let‚Äôs break it down.</p>
  <pre class="ignore"><code>macro_rules! vec { ... }</code></pre>
  <p>This says we‚Äôre defining a macro named <code>vec</code>, much as <code>fn vec</code> would define a function named <code>vec</code>. In prose, we informally write a macro‚Äôs name with an exclamation point, e.g. <code>vec!</code>. The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.</p>
  <section id="matching" class="level4">
  <h4>Matching</h4>
  <p>The macro is defined through a series of rules, which are pattern-matching cases. Above, we had</p>
  <pre class="ignore"><code>( $( $x:expr ),* ) =&gt; { ... };</code></pre>
  <p>This is like a <code>match</code> expression arm, but the matching happens on Rust syntax trees, at compile time. The semicolon is optional on the last (here, only) case. The ‚Äúpattern‚Äù on the left-hand side of <code>=&gt;</code> is known as a ‚Äòmatcher‚Äô. These have [their own little grammar] within the language.</p>
  <p>The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree to the ‚Äòmetavariable‚Äô <code>$x</code>. The identifier <code>expr</code> is a ‚Äòfragment specifier‚Äô; the full possibilities are enumerated later in this chapter. Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions, separated by commas.</p>
  <p>Aside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly. For example,</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      (x =&gt; $e:expr) =&gt; (<span class="pp">println!</span>(<span class="st">&quot;mode X: {}&quot;</span>, $e));
      (y =&gt; $e:expr) =&gt; (<span class="pp">println!</span>(<span class="st">&quot;mode Y: {}&quot;</span>, $e));
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>(y =&gt; <span class="dv">3</span>);
  }</code></pre></div>
  <p>will print</p>
  <pre class="text"><code>mode Y: 3</code></pre>
  <p>With</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">foo!</span>(z =&gt; <span class="dv">3</span>);</code></pre></div>
  <p>we get the compiler error</p>
  <pre class="text"><code>error: no rules expected the token `z`</code></pre>
  </section>
  <section id="expansion" class="level4">
  <h4>Expansion</h4>
  <p>The right-hand side of a macro rule is ordinary Rust syntax, for the most part. But we can splice in bits of syntax captured by the matcher. From the original example:</p>
  <pre class="ignore"><code>$(
      temp_vec.push($x);
  )*</code></pre>
  <p>Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the macro expansion. The repetition in the expansion proceeds in ‚Äúlockstep‚Äù with repetition in the matcher (more on this in a moment).</p>
  <p>Because <code>$x</code> was already declared as matching an expression, we don‚Äôt repeat <code>:expr</code> on the right-hand side. Also, we don‚Äôt include a separating comma as part of the repetition operator. Instead, we have a terminating semicolon within the repeated block.</p>
  <p>Another detail: the <code>vec!</code> macro has <em>two</em> pairs of braces on the right-hand side. They are often combined like so:</p>
  <pre class="ignore"><code>macro_rules! foo {
      () =&gt; {{
          ...
      }}
  }</code></pre>
  <p>The outer braces are part of the syntax of <code>macro_rules!</code>. In fact, you can use <code>()</code> or <code>[]</code> instead. They simply delimit the right-hand side as a whole.</p>
  <p>The inner braces are part of the expanded syntax. Remember, the <code>vec!</code> macro is used in an expression context. To write an expression with multiple statements, including <code>let</code>-bindings, we use a block. If your macro expands to a single expression, you don‚Äôt need this extra layer of braces.</p>
  <p>Note that we never <em>declared</em> that the macro produces an expression. In fact, this is not determined until we use the macro as an expression. With care, you can write a macro whose expansion works in several contexts. For example, shorthand for a data type could be valid as either an expression or a pattern.</p>
  </section>
  <section id="repetition" class="level4">
  <h4>Repetition</h4>
  <p>The repetition operator follows two principal rules:</p>
  <ol type="1">
  <li><code>$(...)*</code> walks through one ‚Äúlayer‚Äù of repetitions, for all of the <code>$name</code>s it contains, in lockstep, and</li>
  <li>each <code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched against. If it is under more, it‚Äôll be duplicated, as appropriate.</li>
  </ol>
  <p>This baroque macro illustrates the duplication of variables from outer repetition levels.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> o_O {
      (
          $(
              $x:expr; [ $( $y:expr ),* ]
          );*
      ) =&gt; {
          &amp;[ $($( $x + $y ),*),* ]
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> a: &amp;[<span class="dt">i32</span>]
          = <span class="pp">o_O!</span>(<span class="dv">10</span>; [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
                 <span class="dv">20</span>; [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]);
  
      <span class="pp">assert_eq!</span>(a, [<span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>]);
  }</code></pre></div>
  <p>That‚Äôs most of the matcher syntax. These examples use <code>$(...)*</code>, which is a ‚Äúzero or more‚Äù match. Alternatively you can write <code>$(...)+</code> for a ‚Äúone or more‚Äù match. Both forms optionally include a separator, which can be any token except <code>+</code> or <code>*</code>.</p>
  <p>This system is based on ‚Äú<a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>‚Äù (PDF link).</p>
  </section>
  </section>
  <section id="hygiene" class="level3">
  <h3>Hygiene</h3>
  <p>Some languages implement macros using simple text substitution, which leads to various problems. For example, this C program prints <code>13</code> instead of the expected <code>25</code>.</p>
  <pre class="text"><code>#define FIVE_TIMES(x) 5 * x
  
  int main() {
      printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
      return 0;
  }</code></pre>
  <p>After expansion we have <code>5 * 2 + 3</code>, and multiplication has greater precedence than addition. If you‚Äôve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others. In Rust, we don‚Äôt have to worry about it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> five_times {
      ($x:expr) =&gt; (<span class="dv">5</span> * $x);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">25</span>, <span class="pp">five_times!</span>(<span class="dv">2</span> + <span class="dv">3</span>));
  }</code></pre></div>
  <p>The metavariable <code>$x</code> is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.</p>
  <p>Another common problem in macro systems is ‚Äòvariable capture‚Äô. Here‚Äôs a C macro, using [a GNU C extension] to emulate Rust‚Äôs expression blocks.</p>
  <pre class="text"><code>#define LOG(msg) ({ \
      int state = get_log_state(); \
      if (state &gt; 0) { \
          printf(&quot;log(%d): %s\n&quot;, state, msg); \
      } \
  })</code></pre>
  <p>Here‚Äôs a simple use case that goes terribly wrong:</p>
  <pre class="text"><code>const char *state = &quot;reticulating splines&quot;;
  LOG(state)</code></pre>
  <p>This expands to</p>
  <pre class="text"><code>const char *state = &quot;reticulating splines&quot;;
  int state = get_log_state();
  if (state &gt; 0) {
      printf(&quot;log(%d): %s\n&quot;, state, state);
  }</code></pre>
  <p>The second variable named <code>state</code> shadows the first one. This is a problem because the print statement should refer to both of them.</p>
  <p>The equivalent Rust macro has the desired behavior.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> log {
      ($msg:expr) =&gt; {{
          <span class="kw">let</span> state: <span class="dt">i32</span> = get_log_state();
          <span class="kw">if</span> state &gt; <span class="dv">0</span> {
              <span class="pp">println!</span>(<span class="st">&quot;log({}): {}&quot;</span>, state, $msg);
          }
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> state: &amp;<span class="dt">str</span> = <span class="st">&quot;reticulating splines&quot;</span>;
      <span class="pp">log!</span>(state);
  }</code></pre></div>
  <p>This works because Rust has a [hygienic macro system]. Each macro expansion happens in a distinct ‚Äòsyntax context‚Äô, and each variable is tagged with the syntax context where it was introduced. It‚Äôs as though the variable <code>state</code> inside <code>main</code> is painted a different ‚Äúcolor‚Äù from the variable <code>state</code> inside the macro, and therefore they don‚Äôt conflict.</p>
  <p>This also restricts the ability of macros to introduce new bindings at the invocation site. Code such as the following will not work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      () =&gt; (<span class="kw">let</span> x = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>();
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>Instead you need to pass the variable name into the invocation, so it‚Äôs tagged with the right syntax context.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      ($v:ident) =&gt; (<span class="kw">let</span> $v = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>(x);
      <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre></div>
  <p>This holds for <code>let</code> bindings and loop labels, but not for <a href="http://doc.rust-lang.org/reference.html#items">items</a>. So the following code does compile:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> foo {
      () =&gt; (<span class="kw">fn</span> x() { });
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">foo!</span>();
      x();
  }</code></pre></div>
  </section>
  <section id="recursive-macros" class="level3">
  <h3>Recursive macros</h3>
  <p>A macro‚Äôs expansion can include more macro invocations, including invocations of the very same macro being expanded. These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> write_html {
      ($w:expr, ) =&gt; (());
  
      ($w:expr, $e:tt) =&gt; (<span class="pp">write!</span>($w, <span class="st">&quot;{}&quot;</span>, $e));
  
      ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
          <span class="pp">write!</span>($w, <span class="st">&quot;&lt;{}&gt;&quot;</span>, <span class="pp">stringify!</span>($tag));
          <span class="pp">write_html!</span>($w, $($inner)*);
          <span class="pp">write!</span>($w, <span class="st">&quot;&lt;/{}&gt;&quot;</span>, <span class="pp">stringify!</span>($tag));
          <span class="pp">write_html!</span>($w, $($rest)*);
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">use</span> std::fmt::Write;
      <span class="kw">let</span> <span class="kw">mut</span> out = <span class="dt">String</span>::new();
  
      <span class="pp">write_html!</span>(&amp;<span class="kw">mut</span> out,
          html[
              head[title[<span class="st">&quot;Macros guide&quot;</span>]]
              body[h1[<span class="st">&quot;Macros are the best!&quot;</span>]]
          ]);
  
      <span class="pp">assert_eq!</span>(out,
          <span class="st">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;</span><span class="sc">\</span>
  <span class="st">         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
  }</code></pre></div>
  </section>
  <section id="debugging-macro-code" class="level3">
  <h3>Debugging macro code</h3>
  <p>To see the results of expanding macros, run <code>rustc --pretty expanded</code>. The output represents a whole crate, so you can also feed it back in to <code>rustc</code>, which will sometimes produce better error messages than the original compilation. Note that the <code>--pretty expanded</code> output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope. In this case <code>--pretty expanded,hygiene</code> will tell you about the syntax contexts.</p>
  <p><code>rustc</code> provides two syntax extensions that help with macro debugging. For now, they are unstable and require feature gates.</p>
  <ul>
  <li><p><code>log_syntax!(...)</code> will print its arguments to standard output, at compile time, and ‚Äúexpand‚Äù to nothing.</p></li>
  <li><p><code>trace_macros!(true)</code> will enable a compiler message every time a macro is expanded. Use <code>trace_macros!(false)</code> later in expansion to turn it off.</p></li>
  </ul>
  </section>
  <section id="syntactic-requirements" class="level3">
  <h3>Syntactic requirements</h3>
  <p>Even when Rust code contains un-expanded macros, it can be parsed as a full <a href="#abstract-syntax-tree">syntax tree</a>. This property can be very useful for editors and other tools that process code. It also has a few consequences for the design of Rust‚Äôs macro system.</p>
  <p>One consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for</p>
  <ul>
  <li>zero or more items,</li>
  <li>zero or more methods,</li>
  <li>an expression,</li>
  <li>a statement, or</li>
  <li>a pattern.</li>
  </ul>
  <p>A macro invocation within a block could stand for some items, or for an expression / statement. Rust uses a simple rule to resolve this ambiguity. A macro invocation that stands for items must be either</p>
  <ul>
  <li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
  <li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
  </ul>
  <p>Another consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation. For example, <code>foo!([)</code> is forbidden. This allows Rust to know where the macro invocation ends.</p>
  <p>More formally, the macro invocation body must be a sequence of ‚Äòtoken trees‚Äô. A token tree is defined recursively as either</p>
  <ul>
  <li>a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>, or</li>
  <li>any other single token.</li>
  </ul>
  <p>Within a matcher, each metavariable has a ‚Äòfragment specifier‚Äô, identifying which syntactic form it matches.</p>
  <ul>
  <li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>foo</code>.</li>
  <li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code>.</li>
  <li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
  <li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
  <li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
  <li><code>stmt</code>: a single statement. Example: <code>let x = 3</code>.</li>
  <li><code>block</code>: a brace-delimited sequence of statements. Example: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
  <li><code>item</code>: an <a href="http://doc.rust-lang.org/reference.html#items">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
  <li><code>meta</code>: a ‚Äúmeta item‚Äù, as found in attributes. Example: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
  <li><code>tt</code>: a single token tree.</li>
  </ul>
  <p>There are additional rules regarding the next token after a metavariable:</p>
  <ul>
  <li><code>expr</code> variables may only be followed by one of: <code>=&gt; , ;</code></li>
  <li><code>ty</code> and <code>path</code> variables may only be followed by one of: <code>=&gt; , : = &gt; as</code></li>
  <li><code>pat</code> variables may only be followed by one of: <code>=&gt; , = if in</code></li>
  <li>Other variables may be followed by any token.</li>
  </ul>
  <p>These rules provide some flexibility for Rust‚Äôs syntax to evolve without breaking existing macros.</p>
  <p>The macro system does not deal with parse ambiguity at all. For example, the grammar <code>$($t:ty)* $e:expr</code> will always fail to parse, because the parser would be forced to choose between parsing <code>$t</code> and parsing <code>$e</code>. Changing the invocation syntax to put a distinctive token in front can solve the problem. In this case, you can write <code>$(T $t:ty)* E $e:exp</code>.</p>
  </section>
  <section id="scoping-and-macro-importexport" class="level3">
  <h3>Scoping and macro import/export</h3>
  <p>Macros are expanded at an early stage in compilation, before name resolution. One downside is that scoping works differently for macros, compared to other constructs in the language.</p>
  <p>Definition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate‚Äôs source. So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child <code>mod</code> items.</p>
  <p>A macro defined within the body of a single <code>fn</code>, or anywhere else not at module scope, is visible only within that item.</p>
  <p>If a module has the <code>macro_use</code> attribute, its macros are also visible in its parent module after the child‚Äôs <code>mod</code> item. If the parent also has <code>macro_use</code> then the macros will be visible in the grandparent after the parent‚Äôs <code>mod</code> item, and so forth.</p>
  <p>The <code>macro_use</code> attribute can also appear on <code>extern crate</code>. In this context it controls which macros are loaded from the external crate, e.g.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>macro_use<span class="at">(</span>foo<span class="at">,</span> bar<span class="at">)]</span>
  <span class="kw">extern</span> <span class="kw">crate</span> baz;</code></pre></div>
  <p>If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded. If there is no <code>#[macro_use]</code> attribute then no macros are loaded. Only macros defined with the <code>#[macro_export]</code> attribute may be loaded.</p>
  <p>To load a crate‚Äôs macros without linking it into the output, use <code>#[no_link]</code> as well.</p>
  <p>An example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> m1 { () =&gt; (()) }
  
  <span class="co">// visible here: m1</span>
  
  <span class="kw">mod</span> foo {
      <span class="co">// visible here: m1</span>
  
      <span class="at">#[</span>macro_export<span class="at">]</span>
      <span class="pp">macro_rules!</span> m2 { () =&gt; (()) }
  
      <span class="co">// visible here: m1, m2</span>
  }
  
  <span class="co">// visible here: m1</span>
  
  <span class="pp">macro_rules!</span> m3 { () =&gt; (()) }
  
  <span class="co">// visible here: m1, m3</span>
  
  <span class="at">#[</span>macro_use<span class="at">]</span>
  <span class="kw">mod</span> bar {
      <span class="co">// visible here: m1, m3</span>
  
      <span class="pp">macro_rules!</span> m4 { () =&gt; (()) }
  
      <span class="co">// visible here: m1, m3, m4</span>
  }
  
  <span class="co">// visible here: m1, m3, m4</span></code></pre></div>
  <p>When this library is loaded with <code>#[macro_use] extern crate</code>, only <code>m2</code> will be imported.</p>
  <p>The Rust Reference has a <a href="http://doc.rust-lang.org/reference.html#macro-related-attributes">listing of macro-related attributes</a>.</p>
  </section>
  <section id="the-variable-crate" class="level3">
  <h3>The variable <code>$crate</code></h3>
  <p>A further difficulty occurs when a macro is used in multiple crates. Say that <code>mylib</code> defines</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> increment(x: <span class="dt">u32</span>) -&gt; <span class="dt">u32</span> {
      x + <span class="dv">1</span>
  }
  
  <span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc_a {
      ($x:expr) =&gt; ( ::increment($x) )
  }
  
  <span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc_b {
      ($x:expr) =&gt; ( ::mylib::increment($x) )
  }</code></pre></div>
  <p><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the library. Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under another name.</p>
  <p>Rust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem. Within a macro imported from a crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>. By contrast, when a macro is defined and then used in the same crate, <code>$crate</code> will expand to nothing. This means we can write</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>macro_export<span class="at">]</span>
  <span class="pp">macro_rules!</span> inc {
      ($x:expr) =&gt; ( $crate::increment($x) )
  }</code></pre></div>
  <p>to define a single macro that works both inside and outside our library. The function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>
  <p>To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may only appear at the root of your crate, not inside <code>mod</code>. This ensures that <code>$crate</code> is a single identifier.</p>
  </section>
  <section id="the-deep-end" class="level3">
  <h3>The deep end</h3>
  <p>The introductory chapter mentioned recursive macros, but it did not give the full story. Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro‚Äôs arguments.</p>
  <p>As an extreme example, it is possible, though hardly advisable, to implement the <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> automaton within Rust‚Äôs macro system.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> bct {
      <span class="co">// cmd 0:  d ... =&gt; ...</span>
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">0</span> ; ));
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">0</span> ; $($ds),*));
  
      <span class="co">// cmd 1p:  1 ... =&gt; 1 ... p</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $p));
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>, $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $($ds),*, $p));
  
      <span class="co">// cmd 1p:  0 ... =&gt; 0 ...</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; $($ds:tt),*)
          =&gt; (<span class="pp">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; $($ds),*));
  
      <span class="co">// halt on empty data string</span>
      ( $($ps:tt),* ; )
          =&gt; (());
  }</code></pre></div>
  <p>Exercise: use macros to reduce duplication in the above definition of the <code>bct!</code> macro.</p>
  </section>
  <section id="common-macros" class="level3">
  <h3>Common macros</h3>
  <p>Here are some common macros you‚Äôll see in Rust code.</p>
  <section id="panic" class="level4">
  <h4>panic!</h4>
  <p>This macro causes the current thread to panic. You can give it a message to panic with:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">panic!</span>(<span class="st">&quot;oh no!&quot;</span>);</code></pre></div>
  </section>
  <section id="vec" class="level4">
  <h4>vec!</h4>
  <p>The <code>vec!</code> macro is used throughout the book, so you‚Äôve probably seen it already. It creates <code>Vec&lt;T&gt;</code>s with ease:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];</code></pre></div>
  <p>It also lets you make vectors with repeating values. For example, a hundred zeroes:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">0</span>; <span class="dv">100</span>];</code></pre></div>
  </section>
  <section id="assert-and-assert_eq" class="level4">
  <h4>assert! and assert_eq!</h4>
  <p>These two macros are used in tests. <code>assert!</code> takes a boolean. <code>assert_eq!</code> takes two values and checks them for equality. <code>true</code> passes, <code>false</code> <code>panic!</code>s. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// A-ok!</span>
  
  <span class="pp">assert!</span>(<span class="cn">true</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span> + <span class="dv">2</span>);
  
  <span class="co">// nope :(</span>
  
  <span class="pp">assert!</span>(<span class="dv">5</span> &lt; <span class="dv">3</span>);
  <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span>);</code></pre></div>
  </section>
  <section id="try" class="level4">
  <h4>try!</h4>
  <p><code>try!</code> is used for error handling. It takes something that can return a <code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if it‚Äôs a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the <code>Err(E)</code> if it‚Äôs that. Like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = <span class="pp">try!</span>(File::create(<span class="st">&quot;foo.txt&quot;</span>));
  
      <span class="cn">Ok</span>(())
  }</code></pre></div>
  <p>This is cleaner than doing this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="dt">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = File::create(<span class="st">&quot;foo.txt&quot;</span>);
  
      <span class="kw">let</span> f = <span class="kw">match</span> f {
          <span class="cn">Ok</span>(t) =&gt; t,
          <span class="cn">Err</span>(e) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(e),
      };
  
      <span class="cn">Ok</span>(())
  }</code></pre></div>
  </section>
  <section id="unreachable" class="level4">
  <h4>unreachable!</h4>
  <p>This macro is used when you think some code should never execute:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="cn">false</span> {
      <span class="pp">unreachable!</span>();
  }</code></pre></div>
  <p>Sometimes, the compiler may make you have a different branch that you know will never, ever run. In these cases, use this macro, so that if you end up wrong, you‚Äôll get a <code>panic!</code> about it.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">None</span>;
  
  <span class="kw">match</span> x {
      <span class="cn">Some</span>(_) =&gt; <span class="pp">unreachable!</span>(),
      <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;I know x is None!&quot;</span>),
  }</code></pre></div>
  </section>
  <section id="unimplemented" class="level4">
  <h4>unimplemented!</h4>
  <p>The <code>unimplemented!</code> macro can be used when you‚Äôre trying to get your functions to typecheck, and don‚Äôt want to worry about writing out the body of the function. One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time. Define the others as <code>unimplemented!</code> until you‚Äôre ready to write them.</p>
  </section>
  </section>
  <section id="procedural-macros" class="level3">
  <h3>Procedural macros</h3>
  <p>If Rust‚Äôs macro system can‚Äôt do what you need, you may want to write a <a href="#sec--compiler-plugins">compiler plugin</a> instead. Compared to <code>macro_rules!</code> macros, this is significantly more work, the interfaces are much less stable, and bugs can be much harder to track down. In exchange you get the flexibility of running arbitrary Rust code within the compiler. Syntax extension plugins are sometimes called ‚Äòprocedural macros‚Äô for this reason.</p>
  </section>
  </section>
  <section id="sec--raw-pointers" class="level2">
  <h2>Raw Pointers</h2>
  <p>Rust has a number of different smart pointer types in its standard library, but there are two types that are extra-special. Much of Rust‚Äôs safety comes from compile-time checks, but raw pointers don‚Äôt have such guarantees, and are <a href="#sec--unsafe">unsafe</a> to use.</p>
  <p><code>*const T</code> and <code>*mut T</code> are called ‚Äòraw pointers‚Äô in Rust. Sometimes, when writing certain kinds of libraries, you‚Äôll need to get around Rust‚Äôs safety guarantees for some reason. In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users. For example, <code>*</code> pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</p>
  <p>Here are some things to remember about raw pointers that are different than other pointer types. They:</p>
  <ul>
  <li>are not guaranteed to point to valid memory and are not even guaranteed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</li>
  <li>do not have any automatic clean-up, unlike <code>Box</code>, and so require manual resource management;</li>
  <li>are plain-old-data, that is, they don‚Äôt move ownership, again unlike <code>Box</code>, hence the Rust compiler cannot protect against bugs like use-after-free;</li>
  <li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot reason about dangling pointers; and</li>
  <li>have no guarantees about aliasing or mutability other than mutation not being allowed directly through a <code>*const T</code>.</li>
  </ul>
  <section id="basics" class="level3">
  <h3>Basics</h3>
  <p>Creating a raw pointer is perfectly safe:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">10</span>;
  <span class="kw">let</span> raw_mut = &amp;<span class="kw">mut</span> y <span class="kw">as</span> *<span class="kw">mut</span> <span class="dt">i32</span>;</code></pre></div>
  <p>However, dereferencing one is not. This won‚Äôt work:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="pp">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, *raw);</code></pre></div>
  <p>It gives this error:</p>
  <pre class="text"><code>error: dereference of raw pointer requires unsafe function or block [E0133]
       println!(&quot;raw points at {}&quot;, *raw);
                                    ^~~~</code></pre>
  <p>When you dereference a raw pointer, you‚Äôre taking responsibility that it‚Äôs not pointing somewhere that would be incorrect. As such, you need <code>unsafe</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
  
  <span class="kw">let</span> points_at = <span class="kw">unsafe</span> { *raw };
  
  <span class="pp">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, points_at);</code></pre></div>
  <p>For more operations on raw pointers, see <a href="http://doc.rust-lang.org/std/primitive.pointer.html">their API documentation</a>.</p>
  </section>
  <section id="ffi" class="level3">
  <h3>FFI</h3>
  <p>Raw pointers are useful for FFI: Rust‚Äôs <code>*const T</code> and <code>*mut T</code> are similar to C‚Äôs <code>const T*</code> and <code>T*</code>, respectively. For more about this use, consult the <a href="#sec--ffi">FFI chapter</a>.</p>
  </section>
  <section id="references-and-raw-pointers" class="level3">
  <h3>References and raw pointers</h3>
  <p>At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of data have an identical representation. In fact, an <code>&amp;T</code> reference will implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for the <code>mut</code> variants (both coercions can be performed explicitly with, respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>
  <p>Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not safe. A <code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to point to a valid instance of type <code>T</code>. Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references. The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold. The programmer <em>must</em> guarantee this.</p>
  <p>The recommended method for the conversion is</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> i: <span class="dt">u32</span> = <span class="dv">1</span>;
  
  <span class="co">// explicit cast</span>
  <span class="kw">let</span> p_imm: *<span class="kw">const</span> <span class="dt">u32</span> = &amp;i <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u32</span>;
  <span class="kw">let</span> <span class="kw">mut</span> m: <span class="dt">u32</span> = <span class="dv">2</span>;
  
  <span class="co">// implicit coercion</span>
  <span class="kw">let</span> p_mut: *<span class="kw">mut</span> <span class="dt">u32</span> = &amp;<span class="kw">mut</span> m;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> ref_imm: &amp;<span class="dt">u32</span> = &amp;*p_imm;
      <span class="kw">let</span> ref_mut: &amp;<span class="kw">mut</span> <span class="dt">u32</span> = &amp;<span class="kw">mut</span> *p_mut;
  }</code></pre></div>
  <p>The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>. The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly; for example, it requires that <code>x</code> is a pointer (unlike <code>transmute</code>).</p>
  </section>
  </section>
  <section id="sec--unsafe" class="level2">
  <h2><code>unsafe</code></h2>
  <p>Rust‚Äôs main draw is its powerful static guarantees about behavior. But safety checks are conservative by nature: there are some programs that are actually safe, but the compiler is not able to verify this is true. To write these kinds of programs, we need to tell the compiler to relax its restrictions a bit. For this, Rust has a keyword, <code>unsafe</code>. Code using <code>unsafe</code> has less restrictions than normal code does.</p>
  <p>Let‚Äôs go over the syntax, and then we‚Äôll talk semantics. <code>unsafe</code> is used in four contexts. The first one is to mark a function as unsafe:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">fn</span> danger_will_robinson() {
      <span class="co">// scary stuff</span>
  }</code></pre></div>
  <p>All functions called from <a href="#sec--ffi">FFI</a> must be marked as <code>unsafe</code>, for example. The second use of <code>unsafe</code> is an unsafe block:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> {
      <span class="co">// scary stuff</span>
  }</code></pre></div>
  <p>The third is for unsafe traits:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">trait</span> Scary { }</code></pre></div>
  <p>And the fourth is for <code>impl</code>ementing one of those traits:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">impl</span> Scary <span class="kw">for</span> <span class="dt">i32</span> {}</code></pre></div>
  <p>It‚Äôs important to be able to explicitly delineate code that may have bugs that cause big problems. If a Rust program segfaults, you can be sure it‚Äôs somewhere in the sections marked <code>unsafe</code>.</p>
  <section id="what-does-safe-mean" class="level3">
  <h3>What does ‚Äòsafe‚Äô mean?</h3>
  <p>Safe, in the context of Rust, means ‚Äòdoesn‚Äôt do anything unsafe‚Äô. It‚Äôs also important to know that there are certain behaviors that are probably not desirable in your code, but are expressly <em>not</em> unsafe:</p>
  <ul>
  <li>Deadlocks</li>
  <li>Leaks of memory or other resources</li>
  <li>Exiting without calling destructors</li>
  <li>Integer overflow</li>
  </ul>
  <p>Rust cannot prevent all kinds of software problems. Buggy code can and will be written in Rust. These things aren‚Äôt great, but they don‚Äôt qualify as <code>unsafe</code> specifically.</p>
  <p>In addition, the following are all undefined behaviors in Rust, and must be avoided, even when writing <code>unsafe</code> code:</p>
  <ul>
  <li>Data races</li>
  <li>Dereferencing a null/dangling raw pointer</li>
  <li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a> (uninitialized) memory</li>
  <li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a> with raw pointers.</li>
  <li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM‚Äôs scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing guarantees.</li>
  <li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&gt;</code></li>
  <li>Invoking undefined behavior via compiler intrinsics:</li>
  <li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code> (<code>offset</code> intrinsic), with the exception of one byte past the end which is permitted.</li>
  <li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code> intrinsics) on overlapping buffers</li>
  <li>Invalid values in primitive types, even in private fields/locals:</li>
  <li>Null/dangling references or boxes</li>
  <li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
  <li>A discriminant in an <code>enum</code> not included in its type definition</li>
  <li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
  <li>Non-UTF-8 byte sequences in a <code>str</code></li>
  <li>Unwinding into Rust from foreign code or unwinding from Rust into foreign code.</li>
  </ul>
  </section>
  <section id="unsafe-superpowers" class="level3">
  <h3>Unsafe Superpowers</h3>
  <p>In both unsafe functions and unsafe blocks, Rust will let you do three things that you normally can not do. Just three. Here they are:</p>
  <ol type="1">
  <li>Access or update a <a href="#static">static mutable variable</a>.</li>
  <li>Dereference a raw pointer.</li>
  <li>Call unsafe functions. This is the most powerful ability.</li>
  </ol>
  <p>That‚Äôs it. It‚Äôs important that <code>unsafe</code> does not, for example, ‚Äòturn off the borrow checker‚Äô. Adding <code>unsafe</code> to some random Rust code doesn‚Äôt change its semantics, it won‚Äôt just start accepting anything. But it will let you write things that <em>do</em> break some of the rules.</p>
  <p>You will also encounter the <code>unsafe</code> keyword when writing bindings to foreign (non-Rust) interfaces. You‚Äôre encouraged to write a safe, native Rust interface around the methods provided by the library.</p>
  <p>Let‚Äôs go over the basic three abilities listed, in order.</p>
  <section id="access-or-update-a-static-mut" class="level4">
  <h4>Access or update a <code>static mut</code></h4>
  <p>Rust has a feature called ‚Äò<code>static mut</code>‚Äô which allows for mutable global state. Doing so can cause a data race, and as such is inherently not safe. For more details, see the <a href="#static">static</a> section of the book.</p>
  </section>
  <section id="dereference-a-raw-pointer" class="level4">
  <h4>Dereference a raw pointer</h4>
  <p>Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of different memory safety and security issues. In some senses, the ability to dereference an arbitrary pointer is one of the most dangerous things you can do. For more on raw pointers, see <a href="#sec--raw-pointers">their section of the book</a>.</p>
  </section>
  <section id="call-unsafe-functions" class="level4">
  <h4>Call unsafe functions</h4>
  <p>This last ability works with both aspects of <code>unsafe</code>: you can only call functions marked <code>unsafe</code> from inside an unsafe block.</p>
  <p>This ability is powerful and varied. Rust exposes some <a href="#sec--intrinsics">compiler intrinsics</a> as unsafe functions, and some unsafe functions bypass safety checks, trading safety for speed.</p>
  <p>I‚Äôll repeat again: even though you <em>can</em> do arbitrary things in unsafe blocks and functions doesn‚Äôt mean you should. The compiler will act as though you‚Äôre upholding its invariants, so be careful!</p>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--nightly-rust" class="level1">
  <h1>Nightly Rust</h1>
  <p>Rust provides three distribution channels for Rust: nightly, beta, and stable. Unstable features are only available on nightly Rust. For more details on this process, see ‚Äò<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Stability as a deliverable</a>‚Äô.</p>
  <p>To install nightly Rust, you can use <code>rustup.sh</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -s https://static.rust-lang.org/rustup.sh <span class="kw">|</span> <span class="kw">sh</span> -s -- --channel=nightly</code></pre></div>
  <p>If you‚Äôre concerned about the <a href="http://curlpipesh.tumblr.com">potential insecurity</a> of using <code>curl | sh</code>, please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -f -L https://static.rust-lang.org/rustup.sh -O
  $ <span class="kw">sh</span> rustup.sh --channel=nightly</code></pre></div>
  <p>If you‚Äôre on Windows, please download either the <a href="https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.msi">32-bit installer</a> or the <a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
  <section id="uninstalling-1" class="level4">
  <h4>Uninstalling</h4>
  <p>If you decide you don‚Äôt want Rust anymore, we‚Äôll be a bit sad, but that‚Äôs okay. Not every programming language is great for everyone. Just run the uninstall script:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> /usr/local/lib/rustlib/uninstall.sh</code></pre></div>
  <p>If you used the Windows installer, just re-run the <code>.msi</code> and it will give you an uninstall option.</p>
  <p>Some people, and somewhat rightfully so, get very upset when we tell you to <code>curl | sh</code>. Basically, when you do this, you are trusting that the good people who maintain Rust aren‚Äôt going to hack your computer and do bad things. That‚Äôs a good instinct! If you‚Äôre one of those people, please check out the documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building Rust from Source</a>, or <a href="https://www.rust-lang.org/install.html">the official binary downloads</a>.</p>
  <p>Oh, we should also mention the officially supported platforms:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
  <li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
  </ul>
  <p>We extensively test Rust on these platforms, and a few others, too, like Android. But these are the ones most likely to work, as they have the most testing.</p>
  <p>Finally, a comment about Windows. Rust considers Windows to be a first-class platform upon release, but if we‚Äôre honest, the Windows experience isn‚Äôt as integrated as the Linux/OS X experience is. We‚Äôre working on it! If anything does not work, it is a bug. Please let us know if that happens. Each and every commit is tested against Windows just like any other platform.</p>
  <p>If you‚Äôve got Rust installed, you can open up a shell, and type this:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> --version</code></pre></div>
  <p>You should see the version number, commit hash, commit date and build date:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">rustc</span> 1.0.0-nightly (f11f3e7ba 2015-01-04) <span class="kw">(built</span> 2015-01-06<span class="kw">)</span></code></pre></div>
  <p>If you did, Rust has been installed successfully! Congrats!</p>
  <p>This installer also installs a copy of the documentation locally, so you can read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</code> is the location. On Windows, it‚Äôs in a <code>share/doc</code> directory, inside wherever you installed Rust to.</p>
  <p>If not, there are a number of places where you can get help. The easiest is <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which you can access through <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click that link, and you‚Äôll be chatting with other Rustaceans (a silly nickname we call ourselves), and we can help you out. Other great resources include <a href="https://users.rust-lang.org/">the user‚Äôs forum</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
  </section>
  <section id="sec--compiler-plugins" class="level2">
  <h2>Compiler Plugins</h2>
  <section id="introduction-2" class="level3">
  <h3>Introduction</h3>
  <p><code>rustc</code> can load compiler plugins, which are user-provided libraries that extend the compiler‚Äôs behavior with new syntax extensions, lint checks, etc.</p>
  <p>A plugin is a dynamic library crate with a designated <em>registrar</em> function that registers extensions with <code>rustc</code>. Other crates can load these extensions using the crate attribute <code>#![plugin(...)]</code>. See the <a href="http://doc.rust-lang.org/rustc/plugin/index.html"><code>rustc::plugin</code></a> documentation for more about the mechanics of defining and loading a plugin.</p>
  <p>If present, arguments passed as <code>#![plugin(foo(... args ...))]</code> are not interpreted by rustc itself. They are provided to the plugin through the <code>Registry</code>‚Äôs <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args"><code>args</code> method</a>.</p>
  <p>In the vast majority of cases, a plugin should <em>only</em> be used through <code>#![plugin]</code> and not through an <code>extern crate</code> item. Linking a plugin would pull in all of libsyntax and librustc as dependencies of your crate. This is generally unwanted unless you are building another plugin. The <code>plugin_as_library</code> lint checks these guidelines.</p>
  <p>The usual practice is to put compiler plugins in their own crate, separate from any <code>macro_rules!</code> macros or ordinary Rust code meant to be used by consumers of a library.</p>
  </section>
  <section id="syntax-extensions" class="level3">
  <h3>Syntax extensions</h3>
  <p>Plugins can extend Rust‚Äôs syntax in various ways. One kind of syntax extension is the procedural macro. These are invoked the same way as <a href="#sec--macros">ordinary macros</a>, but the expansion is performed by arbitrary Rust code that manipulates <a href="http://doc.rust-lang.org/syntax/ast/index.html">syntax trees</a> at compile time.</p>
  <p>Let‚Äôs write a plugin <a href="https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.rs</code></a> that implements Roman numeral integer literals.</p>
  <pre class="ignore"><code>#![crate_type=&quot;dylib&quot;]
  #![feature(plugin_registrar, rustc_private)]
  
  extern crate syntax;
  extern crate rustc;
  
  use syntax::codemap::Span;
  use syntax::parse::token;
  use syntax::ast::{TokenTree, TtToken};
  use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
  use syntax::ext::build::AstBuilder;  // trait for expr_usize
  use rustc::plugin::Registry;
  
  fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult + 'static&gt; {
  
      static NUMERALS: &amp;'static [(&amp;'static str, u32)] = &amp;[
          (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
          (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
          (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
          (&quot;I&quot;,    1)];
  
      let text = match args {
          [TtToken(_, token::Ident(s, _))] =&gt; s.to_string(),
          _ =&gt; {
              cx.span_err(sp, &quot;argument should be a single identifier&quot;);
              return DummyResult::any(sp);
          }
      };
  
      let mut text = &amp;*text;
      let mut total = 0;
      while !text.is_empty() {
          match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
              Some(&amp;(rn, val)) =&gt; {
                  total += val;
                  text = &amp;text[rn.len()..];
              }
              None =&gt; {
                  cx.span_err(sp, &quot;invalid Roman numeral&quot;);
                  return DummyResult::any(sp);
              }
          }
      }
  
      MacEager::expr(cx.expr_u32(sp, total))
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_macro(&quot;rn&quot;, expand_rn);
  }</code></pre>
  <p>Then we can use <code>rn!()</code> like any other macro:</p>
  <pre class="ignore"><code>#![feature(plugin)]
  #![plugin(roman_numerals)]
  
  fn main() {
      assert_eq!(rn!(MMXV), 2015);
  }</code></pre>
  <p>The advantages over a simple <code>fn(&amp;str) -&gt; u32</code> are:</p>
  <ul>
  <li>The (arbitrarily complex) conversion is done at compile time.</li>
  <li>Input validation is also performed at compile time.</li>
  <li>It can be extended to allow use in patterns, which effectively gives a way to define new literal syntax for any data type.</li>
  </ul>
  <p>In addition to procedural macros, you can define new <a href="http://doc.rust-lang.org/reference.html#derive"><code>derive</code></a>-like attributes and other kinds of extensions. See <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension"><code>Registry::register_syntax_extension</code></a> and the <a href="https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html"><code>SyntaxExtension</code> enum</a>. For a more involved macro example, see <a href="https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs"><code>regex_macros</code></a>.</p>
  <section id="tips-and-tricks" class="level4">
  <h4>Tips and tricks</h4>
  <p>Some of the <a href="#debugging-macro-code">macro debugging tips</a> are applicable.</p>
  <p>You can use <a href="http://doc.rust-lang.org/syntax/parse/index.html"><code>syntax::parse</code></a> to turn token trees into higher-level syntax elements like expressions:</p>
  <pre class="ignore"><code>fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult+'static&gt; {
  
      let mut parser = cx.new_parser_from_tts(args);
  
      let expr: P&lt;Expr&gt; = parser.parse_expr();</code></pre>
  <p>Looking through <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs"><code>libsyntax</code> parser code</a> will give you a feel for how the parsing infrastructure works.</p>
  <p>Keep the <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>s</a> of everything you parse, for better error reporting. You can wrap <a href="http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html"><code>Spanned</code></a> around your custom data structures.</p>
  <p>Calling <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a> will immediately abort compilation. It‚Äôs better to instead call <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err"><code>ExtCtxt::span_err</code></a> and return <a href="http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code></a>, so that the compiler can continue and find further errors.</p>
  <p>To print syntax fragments for debugging, you can use <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><code>span_note</code></a> together with <a href="https://doc.rust-lang.org/syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to_string</code></a>.</p>
  <p>The example above produced an integer literal using <a href="http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize"><code>AstBuilder::expr_usize</code></a>. As an alternative to the <code>AstBuilder</code> trait, <code>libsyntax</code> provides a set of <a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">quasiquote macros</a>. They are undocumented and very rough around the edges. However, the implementation may be a good starting point for an improved quasiquote as an ordinary plugin library.</p>
  </section>
  </section>
  <section id="lint-plugins" class="level3">
  <h3>Lint plugins</h3>
  <p>Plugins can extend <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">Rust‚Äôs lint infrastructure</a> with additional checks for code style, safety, etc. You can see <a href="https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><code>src/test/auxiliary/lint_plugin_test.rs</code></a> for a full example, the core of which is reproduced here:</p>
  <pre class="ignore"><code>declare_lint!(TEST_LINT, Warn,
                &quot;Warn about items named 'lintme'&quot;);
  
  struct Pass;
  
  impl LintPass for Pass {
      fn get_lints(&amp;self) -&gt; LintArray {
          lint_array!(TEST_LINT)
      }
  
      fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
          if it.ident.name == &quot;lintme&quot; {
              cx.span_lint(TEST_LINT, it.span, &quot;item is named 'lintme'&quot;);
          }
      }
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_lint_pass(box Pass as LintPassObject);
  }</code></pre>
  <p>Then code like</p>
  <pre class="ignore"><code>#![plugin(lint_plugin_test)]
  
  fn lintme() { }</code></pre>
  <p>will produce a compiler warning:</p>
  <pre class="txt"><code>foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
  foo.rs:4 fn lintme() { }
           ^~~~~~~~~~~~~~~</code></pre>
  <p>The components of a lint plugin are:</p>
  <ul>
  <li><p>one or more <code>declare_lint!</code> invocations, which define static <a href="http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><code>Lint</code></a> structs;</p></li>
  <li><p>a struct holding any state needed by the lint pass (here, none);</p></li>
  <li><p>a <a href="http://doc.rust-lang.org/rustc/lint/trait.LintPass.html"><code>LintPass</code></a> implementation defining how to check each syntax element. A single <code>LintPass</code> may call <code>span_lint</code> for several different <code>Lint</code>s, but should register them all through the <code>get_lints</code> method.</p></li>
  </ul>
  <p>Lint passes are syntax traversals, but they run at a late stage of compilation where type information is available. <code>rustc</code>‚Äôs <a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">built-in lints</a> mostly use the same infrastructure as lint plugins, and provide examples of how to access type information.</p>
  <p>Lints defined by plugins are controlled by the usual <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">attributes and compiler flags</a>, e.g. <code>#[allow(test_lint)]</code> or <code>-A test-lint</code>. These identifiers are derived from the first argument to <code>declare_lint!</code>, with appropriate case and punctuation conversion.</p>
  <p>You can run <code>rustc -W help foo.rs</code> to see a list of lints known to <code>rustc</code>, including those provided by plugins loaded by <code>foo.rs</code>.</p>
  </section>
  </section>
  <section id="sec--inline-assembly" class="level2">
  <h2>Inline Assembly</h2>
  <p>For extremely low-level manipulations and performance reasons, one might wish to control the CPU directly. Rust supports using inline assembly to do this via the <code>asm!</code> macro. The syntax roughly matches that of GCC &amp; Clang:</p>
  <pre class="ignore"><code>asm!(assembly template
     : output operands
     : input operands
     : clobbers
     : options
     );</code></pre>
  <p>Any use of <code>asm</code> is feature gated (requires <code>#![feature(asm)]</code> on the crate to allow) and of course requires an <code>unsafe</code> block.</p>
  <blockquote>
  <p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but all platforms are supported.</p>
  </blockquote>
  <section id="assembly-template" class="level4">
  <h4>Assembly template</h4>
  <p>The <code>assembly template</code> is the only required parameter and must be a literal string (i.e. <code>&quot;&quot;</code>)</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>asm<span class="at">)]</span>
  
  <span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>target_arch <span class="at">=</span> <span class="st">&quot;x86&quot;</span><span class="at">,</span> target_arch <span class="at">=</span> <span class="st">&quot;x86_64&quot;</span><span class="at">))]</span>
  <span class="kw">fn</span> foo() {
      <span class="kw">unsafe</span> {
          <span class="pp">asm!</span>(<span class="st">&quot;NOP&quot;</span>);
      }
  }
  
  <span class="co">// other platforms</span>
  <span class="at">#[</span>cfg<span class="at">(</span>not<span class="at">(</span>any<span class="at">(</span>target_arch <span class="at">=</span> <span class="st">&quot;x86&quot;</span><span class="at">,</span> target_arch <span class="at">=</span> <span class="st">&quot;x86_64&quot;</span><span class="at">)))]</span>
  <span class="kw">fn</span> foo() { <span class="co">/* ... */</span> }
  
  <span class="kw">fn</span> main() {
      <span class="co">// ...</span>
      foo();
      <span class="co">// ...</span>
  }</code></pre></div>
  <p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted from now on.)</p>
  <p>Output operands, input operands, clobbers and options are all optional but you must add the right number of <code>:</code> if you skip them:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">asm!</span>(<span class="st">&quot;xor %eax, %eax&quot;</span>
      :
      :
      : <span class="st">&quot;{eax}&quot;</span>
     );</code></pre></div>
  <p>Whitespace also doesn‚Äôt matter:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">asm!</span>(<span class="st">&quot;xor %eax, %eax&quot;</span> ::: <span class="st">&quot;{eax}&quot;</span>);</code></pre></div>
  </section>
  <section id="operands" class="level4">
  <h4>Operands</h4>
  <p>Input and output operands follow the same format: <code>: &quot;constraints1&quot;(expr1), &quot;constraints2&quot;(expr2), ...&quot;</code>. Output operand expressions must be mutable lvalues, or not yet assigned:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add(a: <span class="dt">i32</span>, b: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      <span class="kw">let</span> c: <span class="dt">i32</span>;
      <span class="kw">unsafe</span> {
          <span class="pp">asm!</span>(<span class="st">&quot;add $2, $0&quot;</span>
               : <span class="st">&quot;=r&quot;</span>(c)
               : <span class="st">&quot;0&quot;</span>(a), <span class="st">&quot;r&quot;</span>(b)
               );
      }
      c
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(add(<span class="dv">3</span>, <span class="dv">14159</span>), <span class="dv">14162</span>)
  }</code></pre></div>
  <p>If you would like to use real operands in this position, however, you are required to put curly braces <code>{}</code> around the register that you want, and you are required to put the specific size of the operand. This is useful for very low level programming, where which register you use is important:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> result: <span class="dt">u8</span>;
  <span class="pp">asm!</span>(<span class="st">&quot;in %dx, %al&quot;</span> : <span class="st">&quot;={al}&quot;</span>(result) : <span class="st">&quot;{dx}&quot;</span>(port));
  result</code></pre></div>
  </section>
  <section id="clobbers" class="level4">
  <h4>Clobbers</h4>
  <p>Some instructions modify registers which might otherwise have held different values so we use the clobbers list to indicate to the compiler not to assume any values loaded into those registers will stay valid.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Put the value 0x200 in eax</span>
  <span class="pp">asm!</span>(<span class="st">&quot;mov $$0x200, %eax&quot;</span> : <span class="co">/* no outputs */</span> : <span class="co">/* no inputs */</span> : <span class="st">&quot;{eax}&quot;</span>);</code></pre></div>
  <p>Input and output registers need not be listed since that information is already communicated by the given constraints. Otherwise, any other registers used either implicitly or explicitly should be listed.</p>
  <p>If the assembly changes the condition code register <code>cc</code> should be specified as one of the clobbers. Similarly, if the assembly modifies memory, <code>memory</code> should also be specified.</p>
  </section>
  <section id="options" class="level4">
  <h4>Options</h4>
  <p>The last section, <code>options</code> is specific to Rust. The format is comma separated literal strings (i.e. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). It‚Äôs used to specify some extra info about the inline assembly:</p>
  <p>Current valid options are:</p>
  <ol type="1">
  <li><em>volatile</em> - specifying this is analogous to <code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
  <li><em>alignstack</em> - certain instructions expect the stack to be aligned a certain way (i.e.¬†SSE) and specifying this indicates to the compiler to insert its usual stack alignment code</li>
  <li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</li>
  </ol>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> result: <span class="dt">i32</span>;
  <span class="kw">unsafe</span> {
     <span class="pp">asm!</span>(<span class="st">&quot;mov eax, 2&quot;</span> : <span class="st">&quot;={eax}&quot;</span>(result) : : : <span class="st">&quot;intel&quot;</span>)
  }
  <span class="pp">println!</span>(<span class="st">&quot;eax is currently {}&quot;</span>, result);</code></pre></div>
  </section>
  <section id="more-information" class="level4">
  <h4>More Information</h4>
  <p>The current implementation of the <code>asm!</code> macro is a direct binding to <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVM‚Äôs inline assembler expressions</a>, so be sure to check out <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">their documentation as well</a> for more information about clobbers, constraints, etc.</p>
  </section>
  </section>
  <section id="sec--no-stdlib" class="level2">
  <h2>No stdlib</h2>
  <p>By default, <code>std</code> is linked to every Rust crate. In some contexts, this is undesirable, and can be avoided with the <code>#![no_std]</code> attribute attached to the crate.</p>
  <pre class="ignore"><code>// a minimal library
  #![crate_type=&quot;lib&quot;]
  #![feature(no_std)]
  #![no_std]
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>Obviously there‚Äôs more to life than just libraries: one can use <code>#[no_std]</code> with an executable, controlling the entry point is possible in two ways: the <code>#[start]</code> attribute, or overriding the default shim for the C <code>main</code> function with your own.</p>
  <p>The function marked <code>#[start]</code> is passed the command line parameters in the same format as C:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>lang_items<span class="at">,</span> start<span class="at">,</span> no_std<span class="at">,</span> libc<span class="at">)]</span>
  <span class="at">#![</span>no_std<span class="at">]</span>
  
  <span class="co">// Pull in the system libc library for what crt0.o likely requires</span>
  <span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="co">// Entry point for this program</span>
  <span class="at">#[</span>start<span class="at">]</span>
  <span class="kw">fn</span> start(_argc: <span class="dt">isize</span>, _argv: *<span class="kw">const</span> *<span class="kw">const</span> <span class="dt">u8</span>) -&gt; <span class="dt">isize</span> {
      <span class="dv">0</span>
  }
  
  <span class="co">// These functions and traits are used by the compiler, but not</span>
  <span class="co">// for a bare-bones hello world. These are normally</span>
  <span class="co">// provided by libstd.</span>
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;eh_personality&quot;</span><span class="at">]</span> <span class="kw">extern</span> <span class="kw">fn</span> eh_personality() {}
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;panic_fmt&quot;</span><span class="at">]</span> <span class="kw">fn</span> panic_fmt() -&gt; ! { <span class="kw">loop</span> {} }</code></pre></div>
  <p>To override the compiler-inserted <code>main</code> shim, one has to disable it with <code>#![no_main]</code> and then create the appropriate symbol with the correct ABI and the correct name, which requires overriding the compiler‚Äôs name mangling too:</p>
  <pre class="ignore"><code>#![feature(no_std)]
  #![no_std]
  #![no_main]
  #![feature(lang_items, start)]
  
  extern crate libc;
  
  #[no_mangle] // ensure that this symbol is called `main` in the output
  pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
      0
  }
  
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  #[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
  # #[lang = &quot;eh_unwind_resume&quot;] extern fn rust_eh_unwind_resume() {}
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>The compiler currently makes a few assumptions about symbols which are available in the executable to call. Normally these functions are provided by the standard library, but without it you must define your own.</p>
  <p>The first of these two functions, <code>eh_personality</code>, is used by the failure mechanisms of the compiler. This is often mapped to GCC‚Äôs personality function (see the <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">libstd implementation</a> for more information), but crates which do not trigger a panic can be assured that this function is never called. The second function, <code>panic_fmt</code>, is also used by the failure mechanisms of the compiler.</p>
  <section id="using-libcore" class="level4">
  <h4>Using libcore</h4>
  <blockquote>
  <p><strong>Note</strong>: the core library‚Äôs structure is unstable, and it is recommended to use the standard library instead wherever possible.</p>
  </blockquote>
  <p>With the above techniques, we‚Äôve got a bare-metal executable running some Rust code. There is a good deal of functionality provided by the standard library, however, that is necessary to be productive in Rust. If the standard library is not sufficient, then <a href="http://doc.rust-lang.org/core/index.html">libcore</a> is designed to be used instead.</p>
  <p>The core library has very few dependencies and is much more portable than the standard library itself. Additionally, the core library has most of the necessary functionality for writing idiomatic and effective Rust code.</p>
  <p>As an example, here is a program that will calculate the dot product of two vectors provided from C, using idiomatic Rust practices.</p>
  <pre class="ignore"><code>#![feature(lang_items, start, no_std, core, libc)]
  #![no_std]
  
  # extern crate libc;
  extern crate core;
  
  use core::prelude::*;
  
  use core::mem;
  
  #[no_mangle]
  pub extern fn dot_product(a: *const u32, a_len: u32,
                            b: *const u32, b_len: u32) -&gt; u32 {
      use core::raw::Slice;
  
      // Convert the provided arrays into Rust slices.
      // The core::raw module guarantees that the Slice
      // structure has the same memory layout as a &amp;[T]
      // slice.
      //
      // This is an unsafe operation because the compiler
      // cannot tell the pointers are valid.
      let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
          mem::transmute((
              Slice { data: a, len: a_len as usize },
              Slice { data: b, len: b_len as usize },
          ))
      };
  
      // Iterate over the slices, collecting the result
      let mut ret = 0;
      for (i, j) in a_slice.iter().zip(b_slice.iter()) {
          ret += (*i) * (*j);
      }
      return ret;
  }
  
  #[lang = &quot;panic_fmt&quot;]
  extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                      file: &amp;str,
                      line: u32) -&gt; ! {
      loop {}
  }
  
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  # #[lang = &quot;eh_unwind_resume&quot;] extern fn rust_eh_unwind_resume() {}
  # #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
  # fn main() {}</code></pre>
  <p>Note that there is one extra lang item here which differs from the examples above, <code>panic_fmt</code>. This must be defined by consumers of libcore because the core library declares panics, but it does not define it. The <code>panic_fmt</code> lang item is this crate‚Äôs definition of panic, and it must be guaranteed to never return.</p>
  <p>As can be seen in this example, the core library is intended to provide the power of Rust in all circumstances, regardless of platform requirements. Further libraries, such as liballoc, add functionality to libcore which make other platform-specific assumptions, but continue to be more portable than the standard library itself.</p>
  </section>
  </section>
  <section id="sec--intrinsics" class="level2">
  <h2>Intrinsics</h2>
  <blockquote>
  <p><strong>Note</strong>: intrinsics will forever have an unstable interface, it is recommended to use the stable interfaces of libcore rather than intrinsics directly.</p>
  </blockquote>
  <p>These are imported as if they were FFI functions, with the special <code>rust-intrinsic</code> ABI. For example, if one was in a freestanding context, but wished to be able to <code>transmute</code> between types, and perform efficient pointer arithmetic, one would import those functions via a declaration like</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>intrinsics<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="st">&quot;rust-intrinsic&quot;</span> {
      <span class="kw">fn</span> transmute&lt;T, U&gt;(x: T) -&gt; U;
  
      <span class="kw">fn</span> offset&lt;T&gt;(dst: *<span class="kw">const</span> T, offset: <span class="dt">isize</span>) -&gt; *<span class="kw">const</span> T;
  }</code></pre></div>
  <p>As with any other FFI functions, these are always <code>unsafe</code> to call.</p>
  </section>
  <section id="sec--lang-items" class="level2">
  <h2>Lang items</h2>
  <blockquote>
  <p><strong>Note</strong>: lang items are often provided by crates in the Rust distribution, and lang items themselves have an unstable interface. It is recommended to use officially distributed crates instead of defining your own lang items.</p>
  </blockquote>
  <p>The <code>rustc</code> compiler has certain pluggable operations, that is, functionality that isn‚Äôt hard-coded into the language, but is implemented in libraries, with a special marker to tell the compiler it exists. The marker is the attribute <code>#[lang = &quot;...&quot;]</code> and there are various different values of <code>...</code>, i.e.¬†various different ‚Äòlang items‚Äô.</p>
  <p>For example, <code>Box</code> pointers require two lang items, one for allocation and one for deallocation. A freestanding program that uses the <code>Box</code> sugar for dynamic allocations via <code>malloc</code> and <code>free</code>:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>lang_items<span class="at">,</span> box_syntax<span class="at">,</span> start<span class="at">,</span> no_std<span class="at">,</span> libc<span class="at">)]</span>
  <span class="at">#![</span>no_std<span class="at">]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> libc;
  
  <span class="kw">extern</span> {
      <span class="kw">fn</span> abort() -&gt; !;
  }
  
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;owned_box&quot;</span><span class="at">]</span>
  <span class="kw">pub</span> <span class="kw">struct</span> <span class="dt">Box</span>&lt;T&gt;(*<span class="kw">mut</span> T);
  
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;exchange_malloc&quot;</span><span class="at">]</span>
  <span class="kw">unsafe</span> <span class="kw">fn</span> allocate(size: <span class="dt">usize</span>, _align: <span class="dt">usize</span>) -&gt; *<span class="kw">mut</span> <span class="dt">u8</span> {
      <span class="kw">let</span> p = libc::malloc(size <span class="kw">as</span> libc::<span class="dt">size_t</span>) <span class="kw">as</span> *<span class="kw">mut</span> <span class="dt">u8</span>;
  
      <span class="co">// malloc failed</span>
      <span class="kw">if</span> p <span class="kw">as</span> <span class="dt">usize</span> == <span class="dv">0</span> {
          abort();
      }
  
      p
  }
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;exchange_free&quot;</span><span class="at">]</span>
  <span class="kw">unsafe</span> <span class="kw">fn</span> deallocate(ptr: *<span class="kw">mut</span> <span class="dt">u8</span>, _size: <span class="dt">usize</span>, _align: <span class="dt">usize</span>) {
      libc::free(ptr <span class="kw">as</span> *<span class="kw">mut</span> libc::<span class="dt">c_void</span>)
  }
  
  <span class="at">#[</span>start<span class="at">]</span>
  <span class="kw">fn</span> main(argc: <span class="dt">isize</span>, argv: *<span class="kw">const</span> *<span class="kw">const</span> <span class="dt">u8</span>) -&gt; <span class="dt">isize</span> {
      <span class="kw">let</span> x = <span class="kw">box</span> <span class="dv">1</span>;
  
      <span class="dv">0</span>
  }
  
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;eh_personality&quot;</span><span class="at">]</span> <span class="kw">extern</span> <span class="kw">fn</span> eh_personality() {}
  <span class="at">#[</span>lang <span class="at">=</span> <span class="st">&quot;panic_fmt&quot;</span><span class="at">]</span> <span class="kw">fn</span> panic_fmt() -&gt; ! { <span class="kw">loop</span> {} }</code></pre></div>
  <p>Note the use of <code>abort</code>: the <code>exchange_malloc</code> lang item is assumed to return a valid pointer, and so needs to do the check internally.</p>
  <p>Other features provided by lang items include:</p>
  <ul>
  <li>overloadable operators via traits: the traits corresponding to the <code>==</code>, <code>&lt;</code>, dereferencing (<code>*</code>) and <code>+</code> (etc.) operators are all marked with lang items; those specific four are <code>eq</code>, <code>ord</code>, <code>deref</code>, and <code>add</code> respectively.</li>
  <li>stack unwinding and general failure; the <code>eh_personality</code>, <code>fail</code> and <code>fail_bounds_checks</code> lang items.</li>
  <li>the traits in <code>std::marker</code> used to indicate types of various kinds; lang items <code>send</code>, <code>sync</code> and <code>copy</code>.</li>
  <li>the marker types and variance indicators found in <code>std::marker</code>; lang items <code>covariant_type</code>, <code>contravariant_lifetime</code>, etc.</li>
  </ul>
  <p>Lang items are loaded lazily by the compiler; e.g.¬†if one never uses <code>Box</code> then there is no need to define functions for <code>exchange_malloc</code> and <code>exchange_free</code>. <code>rustc</code> will emit an error when an item is needed but not found in the current crate or any that it depends on.</p>
  </section>
  <section id="sec--advanced-linking" class="level2">
  <h2>Advanced linking</h2>
  <p>The common cases of linking with Rust have been covered earlier in this book, but supporting the range of linking possibilities made available by other languages is important for Rust to achieve seamless interaction with native libraries.</p>
  <section id="link-args" class="level3">
  <h3>Link args</h3>
  <p>There is one other way to tell <code>rustc</code> how to customize linking, and that is via the <code>link_args</code> attribute. This attribute is applied to <code>extern</code> blocks and specifies raw flags which need to get passed to the linker when producing an artifact. An example usage would be:</p>
  <pre class="no_run"><code>#![feature(link_args)]
  
  #[link_args = &quot;-foo -bar -baz&quot;]
  extern {}
  # fn main() {}</code></pre>
  <p>Note that this feature is currently hidden behind the <code>feature(link_args)</code> gate because this is not a sanctioned way of performing linking. Right now <code>rustc</code> shells out to the system linker (<code>gcc</code> on most systems, <code>link.exe</code> on MSVC), so it makes sense to provide extra command line arguments, but this will not always be the case. In the future <code>rustc</code> may use LLVM directly to link native libraries, in which case <code>link_args</code> will have no meaning. You can achieve the same effect as the <code>link-args</code> attribute with the <code>-C link-args</code> argument to <code>rustc</code>.</p>
  <p>It is highly recommended to <em>not</em> use this attribute, and rather use the more formal <code>#[link(...)]</code> attribute on <code>extern</code> blocks instead.</p>
  </section>
  <section id="static-linking" class="level3">
  <h3>Static linking</h3>
  <p>Static linking refers to the process of creating output that contains all required libraries and so doesn‚Äôt need libraries installed on every system where you want to use your compiled project. Pure-Rust dependencies are statically linked by default so you can use created binaries and libraries without installing Rust everywhere. By contrast, native libraries (e.g. <code>libc</code> and <code>libm</code>) are usually dynamically linked, but it is possible to change this and statically link them as well.</p>
  <p>Linking is a very platform-dependent topic, and static linking may not even be possible on some platforms! This section assumes some basic familiarity with linking on your platform of choice.</p>
  <section id="linux" class="level4">
  <h4>Linux</h4>
  <p>By default, all Rust programs on Linux will link to the system <code>libc</code> along with a number of other libraries. Let‚Äôs look at an example on a 64-bit Linux machine with GCC and <code>glibc</code> (by far the most common <code>libc</code> on Linux):</p>
  <pre class="text"><code>$ cat example.rs
  fn main() {}
  $ rustc example.rs
  $ ldd example
          linux-vdso.so.1 =&gt;  (0x00007ffd565fd000)
          libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
          libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
          librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
          libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
          libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
          /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
          libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)</code></pre>
  <p>Dynamic linking on Linux can be undesirable if you wish to use new library features on old systems or target systems which do not have the required dependencies for your program to run.</p>
  <p>Static linking is supported via an alternative <code>libc</code>, <code>musl</code>. You can compile your own version of Rust with <code>musl</code> enabled and install it into a custom directory with the instructions below:</p>
  <pre class="text"><code>$ mkdir musldist
  $ PREFIX=$(pwd)/musldist
  $
  $ # Build musl
  $ curl -O http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
  $ tar xf musl-1.1.10.tar.gz
  $ cd musl-1.1.10/
  musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
  musl-1.1.10 $ make
  musl-1.1.10 $ make install
  musl-1.1.10 $ cd ..
  $ du -h musldist/lib/libc.a
  2.2M    musldist/lib/libc.a
  $
  $ # Build libunwind.a
  $ curl -O http://llvm.org/releases/3.7.0/llvm-3.7.0.src.tar.xz
  $ tar xf llvm-3.7.0.src.tar.xz
  $ cd llvm-3.7.0.src/projects/
  llvm-3.7.0.src/projects $ curl http://llvm.org/releases/3.7.0/libcxxabi-3.7.0.src.tar.
  ‚Ü≥ xz | tar xJf -
  llvm-3.7.0.src/projects $ mv libcxxabi-3.7.0.src libcxxabi
  llvm-3.7.0.src/projects $ curl http://llvm.org/releases/3.7.0/libunwind-3.7.0.src.tar.
  ‚Ü≥ xz | tar xJf -
  llvm-3.7.0.src/projects $ mv libunwind-3.7.0.src libunwind
  llvm-3.7.0.src/projects $ mkdir libunwind/build
  llvm-3.7.0.src/projects $ cd libunwind/build
  llvm-3.7.0.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABL
  ‚Ü≥ E_SHARED=0 ..
  llvm-3.7.0.src/projects/libunwind/build $ make
  llvm-3.7.0.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
  llvm-3.7.0.src/projects/libunwind/build $ cd ../../../../
  $ du -h musldist/lib/libunwind.a
  164K    musldist/lib/libunwind.a
  $
  $ # Build musl-enabled rust
  $ git clone https://github.com/rust-lang/rust.git muslrust
  $ cd muslrust
  muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix
  ‚Ü≥ =$PREFIX
  muslrust $ make
  muslrust $ make install
  muslrust $ cd ..
  $ du -h musldist/bin/rustc
  12K     musldist/bin/rustc</code></pre>
  <p>You now have a build of a <code>musl</code>-enabled Rust! Because we‚Äôve installed it to a custom prefix we need to make sure our system can find the binaries and appropriate libraries when we try and run it:</p>
  <pre class="text"><code>$ export PATH=$PREFIX/bin:$PATH
  $ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH</code></pre>
  <p>Let‚Äôs try it out!</p>
  <pre class="text"><code>$ echo 'fn main() { println!(&quot;hi!&quot;); panic!(&quot;failed&quot;); }' &gt; example.rs
  $ rustc --target=x86_64-unknown-linux-musl example.rs
  $ ldd example
          not a dynamic executable
  $ ./example
  hi!
  thread '&lt;main&gt;' panicked at 'failed', example.rs:1</code></pre>
  <p>Success! This binary can be copied to almost any Linux machine with the same machine architecture and run without issues.</p>
  <p><code>cargo build</code> also permits the <code>--target</code> option so you should be able to build your crates as normal. However, you may need to recompile your native libraries against <code>musl</code> before they can be linked against.</p>
  </section>
  </section>
  </section>
  <section id="sec--benchmark-tests" class="level2">
  <h2>Benchmark Tests</h2>
  <p>Rust supports benchmark tests, which can test the performance of your code. Let‚Äôs make our <code>src/lib.rs</code> look like this (comments elided):</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
      <span class="kw">use</span> test::Bencher;
  
      <span class="at">#[</span>test<span class="at">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="pp">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  
      <span class="at">#[</span>bench<span class="at">]</span>
      <span class="kw">fn</span> bench_add_two(b: &amp;<span class="kw">mut</span> Bencher) {
          b.iter(|| add_two(<span class="dv">2</span>));
      }
  }</code></pre></div>
  <p>Note the <code>test</code> feature gate, which enables this unstable feature.</p>
  <p>We‚Äôve imported the <code>test</code> crate, which contains our benchmarking support. We have a new function as well, with the <code>bench</code> attribute. Unlike regular tests, which take no arguments, benchmark tests take a <code>&amp;mut Bencher</code>. This <code>Bencher</code> provides an <code>iter</code> method, which takes a closure. This closure contains the code we‚Äôd like to benchmark.</p>
  <p>We can run benchmark tests with <code>cargo bench</code>:</p>
  <div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> bench
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/steve/tmp/adder)
       <span class="kw">Running</span> target/release/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> tests::it_works ... ignored
  <span class="kw">test</span> tests::bench_add_two ... bench:         1 ns/iter (+/- 0)
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">1</span> ignored<span class="kw">;</span> <span class="kw">1</span> measured</code></pre></div>
  <p>Our non-benchmark test was ignored. You may have noticed that <code>cargo bench</code> takes a bit longer than <code>cargo test</code>. This is because Rust runs our benchmark a number of times, and then takes the average. Because we‚Äôre doing so little work in this example, we have a <code>1 ns/iter (+/- 0)</code>, but this would show the variance if there was one.</p>
  <p>Advice on writing benchmarks:</p>
  <ul>
  <li>Move setup code outside the <code>iter</code> loop; only put the part you want to measure inside</li>
  <li>Make the code do ‚Äúthe same thing‚Äù on each iteration; do not accumulate or change state</li>
  <li>Make the outer function idempotent too; the benchmark runner is likely to run it many times</li>
  <li>Make the inner <code>iter</code> loop short and fast so benchmark runs are fast and the calibrator can adjust the run-length at fine resolution</li>
  <li>Make the code in the <code>iter</code> loop do something simple, to assist in pinpointing performance improvements (or regressions)</li>
  </ul>
  <section id="gotcha-optimizations" class="level4">
  <h4>Gotcha: optimizations</h4>
  <p>There‚Äôs another tricky part to writing benchmarks: benchmarks compiled with optimizations activated can be dramatically changed by the optimizer so that the benchmark is no longer benchmarking what one expects. For example, the compiler might recognize that some calculation has no external effects and remove it entirely.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  <span class="kw">use</span> test::Bencher;
  
  <span class="at">#[</span>bench<span class="at">]</span>
  <span class="kw">fn</span> bench_xor_1000_ints(b: &amp;<span class="kw">mut</span> Bencher) {
      b.iter(|| {
          (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new);
      });
  }</code></pre></div>
  <p>gives the following results</p>
  <pre class="text"><code>running 1 test
  test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>The benchmarking runner offers two ways to avoid this. Either, the closure that the <code>iter</code> method receives can return an arbitrary value which forces the optimizer to consider the result used and ensures it cannot remove the computation entirely. This could be done for the example above by adjusting the <code>b.iter</code> call to</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">b.iter(|| {
      <span class="co">// note lack of `;` (could also use an explicit `return`).</span>
      (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new)
  });</code></pre></div>
  <p>Or, the other option is to call the generic <code>test::black_box</code> function, which is an opaque ‚Äúblack box‚Äù to the optimizer and so forces it to consider any argument as used.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>test<span class="at">)]</span>
  
  <span class="kw">extern</span> <span class="kw">crate</span> test;
  
  b.iter(|| {
      <span class="kw">let</span> n = test::black_box(<span class="dv">1000</span>);
  
      (<span class="dv">0.</span>.n).fold(<span class="dv">0</span>, |a, b| a ^ b)
  })</code></pre></div>
  <p>Neither of these read or modify the value, and are very cheap for small values. Larger values can be passed indirectly to reduce overhead (e.g. <code>black_box(&amp;huge_struct)</code>).</p>
  <p>Performing either of the above changes gives the following benchmarking results</p>
  <pre class="text"><code>running 1 test
  test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>However, the optimizer can still modify a testcase in an undesirable manner even when using either of the above.</p>
  </section>
  </section>
  <section id="sec--box-syntax-and-patterns" class="level2">
  <h2>Box Syntax and Patterns</h2>
  <p>Currently the only stable way to create a <code>Box</code> is via the <code>Box::new</code> method. Also it is not possible in stable Rust to destructure a <code>Box</code> in a match pattern. The unstable <code>box</code> keyword can be used to both create and destructure a <code>Box</code>. An example usage would be:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>box_syntax<span class="at">,</span> box_patterns<span class="at">)]</span>
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> b = <span class="cn">Some</span>(<span class="kw">box</span> <span class="dv">5</span>);
      <span class="kw">match</span> b {
          <span class="cn">Some</span>(<span class="kw">box</span> n) <span class="kw">if</span> n &lt; <span class="dv">0</span> =&gt; {
              <span class="pp">println!</span>(<span class="st">&quot;Box contains negative number {}&quot;</span>, n);
          },
          <span class="cn">Some</span>(<span class="kw">box</span> n) <span class="kw">if</span> n &gt;= <span class="dv">0</span> =&gt; {
              <span class="pp">println!</span>(<span class="st">&quot;Box contains non-negative number {}&quot;</span>, n);
          },
          <span class="cn">None</span> =&gt; {
              <span class="pp">println!</span>(<span class="st">&quot;No box&quot;</span>);
          },
          _ =&gt; <span class="pp">unreachable!</span>()
      }
  }</code></pre></div>
  <p>Note that these features are currently hidden behind the <code>box_syntax</code> (box creation) and <code>box_patterns</code> (destructuring and pattern matching) gates because the syntax may still change in the future.</p>
  <section id="returning-pointers" class="level3">
  <h3>Returning Pointers</h3>
  <p>In many languages with pointers, you‚Äôd return a pointer from a function so as to avoid copying a large data structure. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> BigStruct {
      one: <span class="dt">i32</span>,
      two: <span class="dt">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: <span class="dt">Box</span>&lt;BigStruct&gt;) -&gt; <span class="dt">Box</span>&lt;BigStruct&gt; {
      <span class="dt">Box</span>::new(*x)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y = foo(x);
  }</code></pre></div>
  <p>The idea is that by passing around a box, you‚Äôre only copying a pointer, rather than the hundred <code>i32</code>s that make up the <code>BigStruct</code>.</p>
  <p>This is an antipattern in Rust. Instead, write this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>box_syntax<span class="at">)]</span>
  
  <span class="kw">struct</span> BigStruct {
      one: <span class="dt">i32</span>,
      two: <span class="dt">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="dt">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: <span class="dt">Box</span>&lt;BigStruct&gt;) -&gt; BigStruct {
      *x
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dt">Box</span>::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y: <span class="dt">Box</span>&lt;BigStruct&gt; = <span class="kw">box</span> foo(x);
  }</code></pre></div>
  <p>This gives you flexibility without sacrificing performance.</p>
  <p>You may think that this gives us terrible performance: return a value and then immediately box it up ?! Isn‚Äôt this pattern the worst of both worlds? Rust is smarter than that. There is no copy in this code. <code>main</code> allocates enough room for the <code>box</code>, passes a pointer to that memory into <code>foo</code> as <code>x</code>, and then <code>foo</code> writes the value straight into the <code>Box&lt;T&gt;</code>.</p>
  <p>This is important enough that it bears repeating: pointers are not for optimizing returning values from your code. Allow the caller to choose how they want to use your output.</p>
  </section>
  </section>
  <section id="sec--slice-patterns" class="level2">
  <h2>Slice Patterns</h2>
  <p>If you want to match against a slice or array, you can use <code>&amp;</code> with the <code>slice_patterns</code> feature:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>slice_patterns<span class="at">)]</span>
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="st">&quot;match_this&quot;</span>, <span class="st">&quot;1&quot;</span>];
  
      <span class="kw">match</span> &amp;v[..] {
          [<span class="st">&quot;match_this&quot;</span>, second] =&gt; <span class="pp">println!</span>(<span class="st">&quot;The second element is {}&quot;</span>, second),
          _ =&gt; {},
      }
  }</code></pre></div>
  <p>The <code>advanced_slice_patterns</code> gate lets you use <code>..</code> to indicate any number of elements inside a pattern matching a slice. This wildcard can only be used once for a given array. If there‚Äôs an identifier before the <code>..</code>, the result of the slice will be bound to that name. For example:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>advanced_slice_patterns<span class="at">,</span> slice_patterns<span class="at">)]</span>
  
  <span class="kw">fn</span> is_symmetric(list: &amp;[<span class="dt">u32</span>]) -&gt; <span class="dt">bool</span> {
      <span class="kw">match</span> list {
          [] | [_] =&gt; <span class="cn">true</span>,
          [x, inside.., y] <span class="kw">if</span> x == y =&gt; is_symmetric(inside),
          _ =&gt; <span class="cn">false</span>
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="pp">assert!</span>(is_symmetric(sym));
  
      <span class="kw">let</span> not_sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="pp">assert!</span>(!is_symmetric(not_sym));
  }</code></pre></div>
  </section>
  <section id="sec--associated-constants" class="level2">
  <h2>Associated Constants</h2>
  <p>With the <code>associated_consts</code> feature, you can define constants like this:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">1</span>, <span class="dt">i32</span>::ID);
  }</code></pre></div>
  <p>Any implementor of <code>Foo</code> will have to define <code>ID</code>. Without the definition:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
  }</code></pre></div>
  <p>gives</p>
  <pre class="text"><code>error: not all trait items implemented, missing: `ID` [E0046]
       impl Foo for i32 {
       }</code></pre>
  <p>A default value can be implemented as well:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">trait</span> Foo {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i32</span> {
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="dt">i64</span> {
      <span class="kw">const</span> ID: <span class="dt">i32</span> = <span class="dv">5</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="pp">assert_eq!</span>(<span class="dv">1</span>, <span class="dt">i32</span>::ID);
      <span class="pp">assert_eq!</span>(<span class="dv">5</span>, <span class="dt">i64</span>::ID);
  }</code></pre></div>
  <p>As you can see, when implementing <code>Foo</code>, you can leave it unimplemented, as with <code>i32</code>. It will then use the default value. But, as in <code>i64</code>, we can also add our own definition.</p>
  <p>Associated constants don‚Äôt have to be associated with a trait. An <code>impl</code> block for a <code>struct</code> works fine too:</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>feature<span class="at">(</span>associated_consts<span class="at">)]</span>
  
  <span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">pub</span> <span class="kw">const</span> FOO: <span class="dt">u32</span> = <span class="dv">3</span>;
  }</code></pre></div>
  </section>
  </section>
  <section id="sec--glossary" class="level1">
  <h1>Glossary</h1>
  <p>Not every Rustacean has a background in systems programming, nor in computer science, so we‚Äôve added explanations of terms that might be unfamiliar.</p>
  <section id="abstract-syntax-tree" class="level5">
  <h5>Abstract Syntax Tree</h5>
  <p>When a compiler is compiling your program, it does a number of different things. One of the things that it does is turn the text of your program into an ‚Äòabstract syntax tree‚Äô, or ‚ÄòAST‚Äô. This tree is a representation of the structure of your program. For example, <code>2 + 3</code> can be turned into a tree:</p>
  <pre class="text"><code>  +
   / \
  2   3</code></pre>
  <p>And <code>2 + (3 * 4)</code> would look like this:</p>
  <pre class="text"><code>  +
   / \
  2   *
     / \
    3   4</code></pre>
  </section>
  <section id="arity" class="level5">
  <h5>Arity</h5>
  <p>Arity refers to the number of arguments a function or operation takes.</p>
  <div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">2</span>, <span class="dv">3</span>);
  <span class="kw">let</span> y = (<span class="dv">4</span>, <span class="dv">6</span>);
  <span class="kw">let</span> z = (<span class="dv">8</span>, <span class="dv">2</span>, <span class="dv">6</span>);</code></pre></div>
  <p>In the example above <code>x</code> and <code>y</code> have arity 2. <code>z</code> has arity 3.</p>
  </section>
  <section id="dst-dynamically-sized-type" class="level5">
  <h5>DST (Dynamically Sized Type)</h5>
  <p>A type without a statically known size or alignment. (<a href="../nomicon/exotic-sizes.html#dynamically-sized-types-(dsts)">more info</a>)</p>
  </section>
  <section id="expression" class="level5">
  <h5>Expression</h5>
  <p>In computer programming, an expression is a combination of values, constants, variables, operators and functions that evaluate to a single value. For example, <code>2 + (3 * 4)</code> is an expression that returns the value 14. It is worth noting that expressions can have side-effects. For example, a function included in an expression might perform actions other than simply returning a value.</p>
  </section>
  <section id="expression-oriented-language" class="level5">
  <h5>Expression-Oriented Language</h5>
  <p>In early programming languages, <a href="#expression">expressions</a> and <a href="#statement">statements</a> were two separate syntactic categories: expressions had a value and statements did things. However, later languages blurred this distinction, allowing expressions to do things and statements to have a value. In an expression-oriented language, (nearly) every statement is an expression and therefore returns a value. Consequently, these expression statements can themselves form part of larger expressions.</p>
  </section>
  <section id="statement" class="level5">
  <h5>Statement</h5>
  <p>In computer programming, a statement is the smallest standalone element of a programming language that commands a computer to perform an action.</p>
  </section>
  </section>
  <section id="sec--bibliography" class="level1">
  <h1>Bibliography</h1>
  <p>This is a reading list of material relevant to Rust. It includes prior research that has - at one time or another - influenced the design of Rust, as well as publications about Rust.</p>
  <section id="type-system" class="level5">
  <h5>Type system</h5>
  <ul>
  <li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
  <li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
  <li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
  <li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
  <li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
  <li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
  <li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
  <li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
  <li><a href="http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
  </ul>
  </section>
  <section id="concurrency" class="level5">
  <h5>Concurrency</h5>
  <ul>
  <li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
  <li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
  <li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
  <li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
  <li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
  <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
  <li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
  <li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java‚Äôs fork/join library, particularly its application of work stealing to non-strict computation</li>
  <li><a href="http://www.stanford.edu/~ouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
  <li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
  <li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
  <li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
  <li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
  <li><a href="http://www.mpi-sws.org/~turon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
  <li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
  <li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoc-based reclamation</a>.</li>
  </ul>
  </section>
  <section id="others" class="level5">
  <h5>Others</h5>
  <ul>
  <li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
  </ul>
  </section>
  <section id="papers-about-rust" class="level5">
  <h5>Papers <em>about</em> Rust</h5>
  <ul>
  <li><a href="http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a Systems Level Language</a>. Early GPU work by Eric Holk.</li>
  <li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old idea</a></li>
  <li>not exactly about rust, but by nmatsakis</li>
  <li><a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming Language</a>. Early formalization of a subset of the type system, by Eric Reed.</li>
  <li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using Rust</a>. By Lars Bergstrom.</li>
  <li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in Rust</a>. Undergrad paper by Michael Sproul.</li>
  <li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in Rust</a>. Undergrad paper by Alex Light.</li>
  <li><a href>Evaluation of performance and productivity metrics of potential programming languages in the HPC environment</a>. Bachelor‚Äôs thesis by Florian Wilkens. Compares C, Go and Rust.</li>
  <li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library in Rust</a>. By Geoffroy Couprie, research for VLC.</li>
  <li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate Representation</a>. An experimental IR implemented in Impala, a Rust-like language.</li>
  <li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil Codes</a>. Another paper using Impala.</li>
  <li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and friends</a>. Linus Farnstrand‚Äôs master‚Äôs thesis.</li>
  <li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for Rust</a>. Philip Munksgaard‚Äôs master‚Äôs thesis. Research for Servo.</li>
  </ul>
  </section>
  </section>
  <section class="footnotes">
  <hr />
  <ol>
  <li id="fn1"><p>We can make the memory live longer by transferring ownership, sometimes called ‚Äòmoving out of the box‚Äô. More complex examples will be covered later.<a href="#fnref1">‚Ü©</a></p></li>
  <li id="fn2"><p><code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> actually won‚Äôt compile since <code>UnsafeCell&lt;T&gt;</code> isn‚Äôt <code>Send</code> or <code>Sync</code>, but we can wrap it in a type and implement <code>Send</code>/<code>Sync</code> for it manually to get <code>Arc&lt;Wrapper&lt;T&gt;&gt;</code> where <code>Wrapper</code> is <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.<a href="#fnref2">‚Ü©</a></p></li>
  <li id="fn3"><p><code>&amp;[T]</code> and <code>&amp;mut [T]</code> are <em>slices</em>; they consist of a pointer and a length and can refer to a portion of a vector or array. <code>&amp;mut [T]</code> can have its elements mutated, however its length cannot be touched.<a href="#fnref3">‚Ü©</a></p></li>
  <li id="fn4"><p>The actual definition of <code>vec!</code> in libcollections differs from the one presented here, for reasons of efficiency and reusability.<a href="#fnref4">‚Ü©</a></p></li>
  </ol>
  </section>
</article>

</body>
</html>
