% Псевдонимы типов

Ключевое слово `type` позволяет объявить псевдоним другого типа:

```rust
type Name = String;
```

Затем вы можете использовать этот псевдоним вместо реального типа:

```rust
type Name = String;

let x: Name = "Hello".to_string();
```

Однако, обратите внимание на то что *псевдоним* не объявляет новый тип. Rust
строго типизированный язык, например у вас не получится сравнить значения двух
различных типов:

```rust,ignore
let x: i32 = 5;
let y: i64 = 5;

if x == y {
   // ...
}
```

Вы получите ошибку при компиляции:

```text
error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
```

Но если мы используем псевдоним:

```rust
type Num = i32;

let x: i32 = 5;
let y: Num = 5;

if x == y {
   // ...
}
```

То этот пример скомпилируется без ошибок. Значения типа `Num` всегда будут такие
же как и у типа `i32`.

Вы также можете использовать псевдонимы типов с обобщённым кодом:

```rust
use std::result;

enum ConcreteError {
    Foo,
    Bar,
}

type Result<T> = result::Result<T, ConcreteError>;
```

В этом примере мы создаем свою версию типа `Result`, который всегда будет
использовать перечисление `ConcreteError` в `Result<T, E>` вместо типа `E`.
Псевдонимы типов часто используются в модулях стандартной библиотеки для
создания своих псевдонимов для `Result<T, E>`. Например, [io::Result][ioresult].

[ioresult]: http://doc.rust-lang.org/std/io/type.Result.html
